<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>AnddyMao&#39;s Bolg</title>
  
  <subtitle>Yesterday you said tomorrow</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://anddymao.com/"/>
  <updated>2020-01-19T07:00:47.101Z</updated>
  <id>http://anddymao.com/</id>
  
  <author>
    <name>AnddyMao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2019年终总结：拓展新边界</title>
    <link href="http://anddymao.com/2020/01/18/2020-1-18-2019%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <id>http://anddymao.com/2020/01/18/2020-1-18-2019年终总结/</id>
    <published>2020-01-18T06:00:00.000Z</published>
    <updated>2020-01-19T07:00:47.101Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>今天是年前最后的一个周末假期了，在家里已经收拾好行李，再上几天班就可以回家，然后就告别这个城市了。<br>我每年都会在公众号写一篇年终总结，进行总结反思。写文章可能比写代码更难，不想动笔，就先写下工作与技术方面的总结，这个更实在一点。以后每年都在博客更新一篇总结，作为一名程序员，分享一点自己的心得与反思，给看到的人，也给未来的自己。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="19年回首"><a href="#19年回首" class="headerlink" title="19年回首"></a>19年回首</h3><p>19年是毕业的第五个年头了，在互联网行业也进入资深级别了，不管实力有没有达到，别人对你的要求就会如此了。14年毕业后，其实从12年开始就接触android，一直是一名android开发工程师。移动端越来越成熟，竞争越来越激烈，对程序员的要求也越来也高，这一行也变得越来越难。所以对自己的定位也得变，专注的方向是Android和移动端，或者也可以叫大前端和终端，因为任何方向都需要资深工程师，不必要非要转算法或者后端等其它方向。技术上一专多通，以技术去带动提升业务。</p><p>今年工作方面最重要的成功是做了一个音视频特效sdk：xmstreaming。突破了自己技术的边界，直接用C和C++做音视频开发，开始很艰难，中间很艰难，上线更艰难，但结果很完美，收获了很多，也拓展了自己的技术栈。</p><p>面试招人，带了一个实习生，社招两个，校招发出多个offer，需要招进来的是队友，未来坐在自己身边的人，非常慎重的考察，也要照顾面试者的体验。作为一名技术者需要的是专业范，不能有傲慢。</p><p>技术分享上，博客写了九篇，一些经验总结，平时事情太多，很多东西没有去深入研究。在公司做了两三次技术分享。总结能有更多的沉淀。github没有新项目，工作太忙碌，放假根本不想再做。</p><p>技术学习上。今年技术书籍阅读比较少，粗略看了几本c++的书。技术书籍我分三类，一类是思想类，一类是基础，一类是工具类。可以阅读前两种，第三种买下来一般也是放着，真正需要用的时候google搜索更好用，有更新的信息。学习的方式主要是博客和github，尤其音视频方向资料比较少，主要看老工程的源码去学习。</p><h3 id="变化"><a href="#变化" class="headerlink" title="变化"></a>变化</h3><p>自己去年自己的期望就是还能改变，还能相信未来。这年度最大的变化就是trans到了武汉，虽然还在执行中。我的规划是未来回武汉，因为工作和家庭都重要。所以有朋友推荐武汉的岗位，就找到部门聊了聊，十一前聊的，当天就确定了想让我过去，拖到十一月申请，十二月多才开始在新部门干活，年后二月份再到武汉工作。周期很长，因为决定需要慎重，年龄越大，未来的可能性越少，一个选择的代价就是要放弃其它所有的可能选择。北京有更多的互联网企业和机会，想看一看自己的选择有多少，能力如何。选了两家强度适中的大中厂试了试，都面试都到hr面，最后是一个需求和匹配度问题，拿到其中一个offer，涨薪幅度也非常给力，其它方面也都挺好的。但最终考虑下来还是放弃了，回武汉新部门也很不错，有很多适合我做的，也有很多需要我的地方，未来也有机会，但更多的是选择了未来的生活方式，生活压力小一些，离家人更近。</p><h3 id="20年展望"><a href="#20年展望" class="headerlink" title="20年展望"></a>20年展望</h3><p>一直以来工作上都是一个高效的执行者，20年的目标是尝试突破这个层次，能以更高的视角去看待事物。<br>技术上把握思想，有心得有总结。从做一个需求到做一个业务，提升自己的认知，多思考与总结。<br>工作上完成技术上的优化整合，创造价值，进行团队培养，提升影响力。<br>博客上增加文章产出，进行更多的分享。<br>技术上持续学习。多读一点思想上的书。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>19年年景不好，马爸爸却说是未来10年最好的一年。满满的焦虑感，互联网行业又是焦虑最多的地方，35岁被裁员被优化被输送社会，我不相信我们行业的未来是这样的，我觉得只是以后暴富的机会少了而已，进入一个行业成熟稳定期，而资深的工程师与技术人员总是被需要的，企业也是一直会抱怨招不到人的，只是看你是不是那个被需要的人。提升自己，多思考，这篇说得有点多了，就这样了。</p>]]></content>
    
    <summary type="html">
    
      年前最后一个周末了，再坚持几天，新年快乐！
    
    </summary>
    
    
      <category term="生活" scheme="http://anddymao.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>Flutter与Android端的通信流程浅析</title>
    <link href="http://anddymao.com/2019/11/10/2019-11-10-Flutter%E4%B8%8EAndroid%E7%AB%AF%E7%9A%84%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B%E6%B5%85%E6%9E%90/"/>
    <id>http://anddymao.com/2019/11/10/2019-11-10-Flutter与Android端的通信流程浅析/</id>
    <published>2019-11-10T06:00:00.000Z</published>
    <updated>2020-01-19T02:36:48.919Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Flutter 官方提供了一种 Platform Channel 的方案，用于 Dart 和平台之间相互通信。</p><p>我们主要分析下Flutter和Android的通信过程，只分析到java层代码。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>Platform Channel提供了三种封装的调用方式，用于不同情景下的使用：</p><p>1.MethodChannel 用于Flutter主动调用Native的方法，并获取相应的返回值<br>2.EventChannel  用于Flutter监听Native的消息，无法回复消息<br>3.BasicMessageChannel 用于Flutter与native双向字符串和半结构化的数据传递</p><h3 id="MethodChannel"><a href="#MethodChannel" class="headerlink" title="MethodChannel"></a>MethodChannel</h3><h4 id="android端"><a href="#android端" class="headerlink" title="android端"></a>android端</h4><p>在Java代码里面添加一个MethodChannel.MethodCallHandler用于处理方法回调，dart端调用方法会调用到这里的onMethodCall，然后根据方法名和参数做对应处理即可。<br>把MethodCallHandler要设置到一个MethodChannel里，对应一个独一的限定名。flutterView实际是一个BinaryMessenger。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMethodChannel</span> <span class="keyword">implements</span> <span class="title">MethodChannel</span>.<span class="title">MethodCallHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Activity activity;</span><br><span class="line">    <span class="keyword">private</span> MethodChannel channel;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MyMethodChannel <span class="title">registerWith</span><span class="params">(FlutterView flutterView)</span> </span>&#123;</span><br><span class="line">        MethodChannel channel = <span class="keyword">new</span> MethodChannel(flutterView, <span class="string">"MyMethodChannel"</span>);</span><br><span class="line">        MyMethodChannel methodChannelPlugin = <span class="keyword">new</span> MyMethodChannel((Activity) flutterView.getContext(), channel);</span><br><span class="line">        channel.setMethodCallHandler(methodChannelPlugin);</span><br><span class="line">        <span class="keyword">return</span> methodChannelPlugin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MyMethodChannel</span><span class="params">(Activity activity, MethodChannel channel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.channel = channel;</span><br><span class="line">        <span class="keyword">this</span>.activity = activity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMethodCall</span><span class="params">(MethodCall methodCall, MethodChannel.Result result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (methodCall.method) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"send"</span>:</span><br><span class="line">                result.success(<span class="string">"android端收到方法："</span> + methodCall.arguments);</span><br><span class="line">                Toast.makeText(activity, methodCall.arguments + <span class="string">""</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                result.notImplemented();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在FlutterActivity创建时调用registerWith就可以</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">FlutterActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        GeneratedPluginRegistrant.registerWith(<span class="keyword">this</span>);</span><br><span class="line">        MyMethodChannel.registerWith(getFlutterView());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Flutter端"><a href="#Flutter端" class="headerlink" title="Flutter端"></a>Flutter端</h4><p>dart根据MethodChannel的限定名创建MethodChannel，然后调用异步方法，使用future获取回调，即java的Result。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  MethodChannel _methodChannel = MethodChannel(<span class="string">"MyMethodChannel"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _sendToNative() &#123;</span><br><span class="line">    Future&lt;<span class="built_in">String</span>&gt; future =</span><br><span class="line">    _methodChannel.invokeMethod(<span class="string">"send"</span>, _counter);</span><br><span class="line">    future.then((message) &#123;</span><br><span class="line">      setState(() &#123;</span><br><span class="line">        _counter = <span class="string">"返回值："</span> + message;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="EventChannel"><a href="#EventChannel" class="headerlink" title="EventChannel"></a>EventChannel</h3><h4 id="android端-1"><a href="#android端-1" class="headerlink" title="android端"></a>android端</h4><p>dart端注册后java的onListen被调用，拿到EventSink，用于发送消息到dart，有success，error，endOfStream三个方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyEventChannel</span> <span class="keyword">implements</span> <span class="title">EventChannel</span>.<span class="title">StreamHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Activity activity;</span><br><span class="line">    <span class="keyword">private</span> EventChannel channel;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MyEventChannel <span class="title">registerWith</span><span class="params">(FlutterView flutterView)</span> </span>&#123;</span><br><span class="line">        EventChannel channel = <span class="keyword">new</span> EventChannel(flutterView, <span class="string">"MyEventChannel"</span>);</span><br><span class="line">        MyEventChannel eventChannel = <span class="keyword">new</span> MyEventChannel((Activity) flutterView.getContext(), channel);</span><br><span class="line">        channel.setStreamHandler(eventChannel);</span><br><span class="line">        <span class="keyword">return</span> eventChannel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MyEventChannel</span><span class="params">(Activity activity, EventChannel channel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.channel = channel;</span><br><span class="line">        <span class="keyword">this</span>.activity = activity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onListen</span><span class="params">(Object o, EventChannel.EventSink eventSink)</span> </span>&#123;</span><br><span class="line">        activity.getWindow().getDecorView().postDelayed(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                eventSink.success(<span class="string">"success"</span>);</span><br><span class="line">                eventSink.error(<span class="string">"failed1"</span>,<span class="string">"failed2"</span>,-<span class="number">1</span>);</span><br><span class="line">                eventSink.endOfStream();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCancel</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Flutter端-1"><a href="#Flutter端-1" class="headerlink" title="Flutter端"></a>Flutter端</h4><p>使用eventChannel注册监听，监听三个方法onEvent，onError,onDone，和java的三个方法对应。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _onEvent(<span class="built_in">Object</span> event) &#123;</span><br><span class="line">  _counter = event.toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _onError(<span class="built_in">Object</span> error) &#123;</span><br><span class="line">  _counter = error.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _onDone() &#123;</span><br><span class="line">  _counter =<span class="string">"done"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> initState() &#123;</span><br><span class="line">  <span class="keyword">super</span>.initState();</span><br><span class="line">  _counter = <span class="string">"init"</span>;</span><br><span class="line">  EventChannel eventChannel =  EventChannel(<span class="string">'MyEventChannel'</span>);</span><br><span class="line">  eventChannel.receiveBroadcastStream().listen(_onEvent,onError:_onError,onDone: _onDone);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="BasicMessageChannel"><a href="#BasicMessageChannel" class="headerlink" title="BasicMessageChannel"></a>BasicMessageChannel</h3><h4 id="Android端"><a href="#Android端" class="headerlink" title="Android端"></a>Android端</h4><p>创建了一个MessageHandler用于接受消息，用BasicMessageChannel可以发送消息，发送消息可以等待回答，接受消息可以回答，得到回答后一次消息就结束了。是Android端和flutter的双向单次通信。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMessageChannel</span> <span class="keyword">implements</span> <span class="title">BasicMessageChannel</span>.<span class="title">MessageHandler</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Activity activity;</span><br><span class="line">    <span class="keyword">private</span> BasicMessageChannel channel;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MyMessageChannel <span class="title">registerWith</span><span class="params">(FlutterView flutterView)</span> </span>&#123;</span><br><span class="line">        BasicMessageChannel channel = <span class="keyword">new</span> BasicMessageChannel(flutterView, <span class="string">"MyMessageChannel"</span>, StringCodec.INSTANCE);</span><br><span class="line">        MyMessageChannel eventChannel = <span class="keyword">new</span> MyMessageChannel((Activity) flutterView.getContext(), channel);</span><br><span class="line">        channel.setMessageHandler(eventChannel);</span><br><span class="line">        <span class="keyword">return</span> eventChannel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSendMessage</span><span class="params">()</span></span>&#123;</span><br><span class="line">        channel.send(<span class="string">"给flutter发消息了"</span>);</span><br><span class="line">        channel.send(<span class="string">"给flutter发消息了，请回答"</span>, <span class="keyword">new</span> BasicMessageChannel.Reply() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reply</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">                Toast.makeText(activity,o.toString(),Toast.LENGTH_LONG).show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MyMessageChannel</span><span class="params">(Activity activity, BasicMessageChannel channel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.channel = channel;</span><br><span class="line">        <span class="keyword">this</span>.activity = activity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(String s, BasicMessageChannel.Reply&lt;String&gt; reply)</span> </span>&#123;</span><br><span class="line">        Toast.makeText(activity,s,Toast.LENGTH_LONG).show();</span><br><span class="line">        reply.reply(<span class="string">"知道了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Flutter端-2"><a href="#Flutter端-2" class="headerlink" title="Flutter端"></a>Flutter端</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> basicMessageChannel = <span class="keyword">const</span> BasicMessageChannel(<span class="string">'MyMessageChannel'</span>, StringCodec());</span><br><span class="line">basicMessageChannel.setMessageHandler(</span><br><span class="line">      (<span class="built_in">String</span> message) =&gt; Future&lt;<span class="built_in">String</span>&gt;(() &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      _counter = message;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"flutter:知道了"</span>;</span><br><span class="line">  &#125;),</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">Future&lt;<span class="built_in">String</span>&gt; future= basicMessageChannel.send(<span class="string">"来自flutter的message"</span>);</span><br><span class="line">future.then((message) &#123;</span><br><span class="line">  setState(() &#123;</span><br><span class="line">    _counter = message;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="原理浅析"><a href="#原理浅析" class="headerlink" title="原理浅析"></a>原理浅析</h2><p>主要分析下Android端框架的事件流程，我们从EventChannel入手</p><h3 id="事件注册流程"><a href="#事件注册流程" class="headerlink" title="事件注册流程"></a>事件注册流程</h3><p>EventChannel创建需要传入一个BinaryMessenger，然后给它设置一个EventChannel.StreamHandler.setStreamHandler：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@UiThread</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStreamHandler</span><span class="params">(EventChannel.StreamHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.messenger.setMessageHandler(<span class="keyword">this</span>.name, handler == <span class="keyword">null</span> ? <span class="keyword">null</span> : <span class="keyword">new</span> EventChannel.IncomingStreamRequestHandler(handler));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置setStreamHandler方法，用了一个IncomingStreamRequestHandler包装StreamHandler，IncomingStreamRequestHandler就是BinaryMessengerHandler类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BinaryReply</span> </span>&#123;</span><br><span class="line">    <span class="meta">@UiThread</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reply</span><span class="params">(@Nullable ByteBuffer var1)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BinaryMessageHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@UiThread</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(@Nullable ByteBuffer var1, @NonNull BinaryMessenger.BinaryReply var2)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BinaryMessageHandler就一个方法onMessage,接收消息的方法，原始数据是ByteBuffer类型，另一个参数BinaryReply接口,可以回调回复一个ByteBuffer的消息。</p><p>IncomingStreamRequestHandler代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">IncomingStreamRequestHandler</span> <span class="keyword">implements</span> <span class="title">BinaryMessageHandler</span> </span>&#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> EventChannel.StreamHandler handler;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;EventChannel.EventSink&gt; activeSink = <span class="keyword">new</span> AtomicReference((Object)<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">      IncomingStreamRequestHandler(EventChannel.StreamHandler handler) &#123;</span><br><span class="line">          <span class="keyword">this</span>.handler = handler;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(ByteBuffer message, BinaryReply reply)</span> </span>&#123;</span><br><span class="line">          MethodCall call = EventChannel.<span class="keyword">this</span>.codec.decodeMethodCall(message);</span><br><span class="line">          <span class="keyword">if</span> (call.method.equals(<span class="string">"listen"</span>)) &#123;</span><br><span class="line">              <span class="keyword">this</span>.onListen(call.arguments, reply);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (call.method.equals(<span class="string">"cancel"</span>)) &#123;</span><br><span class="line">              <span class="keyword">this</span>.onCancel(call.arguments, reply);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              reply.reply((ByteBuffer)<span class="keyword">null</span>);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onListen</span><span class="params">(Object arguments, BinaryReply callback)</span> </span>&#123;</span><br><span class="line">          EventChannel.EventSink eventSink = <span class="keyword">new</span> EventChannel.IncomingStreamRequestHandler.EventSinkImplementation();</span><br><span class="line">          EventChannel.EventSink oldSink = (EventChannel.EventSink)<span class="keyword">this</span>.activeSink.getAndSet(eventSink);</span><br><span class="line">          <span class="keyword">if</span> (oldSink != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="keyword">this</span>.handler.onCancel((Object)<span class="keyword">null</span>);</span><br><span class="line">              &#125; <span class="keyword">catch</span> (RuntimeException var7) &#123;</span><br><span class="line">                  Log.e(<span class="string">"EventChannel#"</span> + EventChannel.<span class="keyword">this</span>.name, <span class="string">"Failed to close existing event stream"</span>, var7);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">this</span>.handler.onListen(arguments, eventSink);</span><br><span class="line">              callback.reply(EventChannel.<span class="keyword">this</span>.codec.encodeSuccessEnvelope((Object)<span class="keyword">null</span>));</span><br><span class="line">          &#125; <span class="keyword">catch</span> (RuntimeException var6) &#123;</span><br><span class="line">              <span class="keyword">this</span>.activeSink.set((Object)<span class="keyword">null</span>);</span><br><span class="line">              Log.e(<span class="string">"EventChannel#"</span> + EventChannel.<span class="keyword">this</span>.name, <span class="string">"Failed to open event stream"</span>, var6);</span><br><span class="line">              callback.reply(EventChannel.<span class="keyword">this</span>.codec.encodeErrorEnvelope(<span class="string">"error"</span>, var6.getMessage(), (Object)<span class="keyword">null</span>));</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onCancel</span><span class="params">(Object arguments, BinaryReply callback)</span> </span>&#123;</span><br><span class="line">          EventChannel.EventSink oldSink = (EventChannel.EventSink)<span class="keyword">this</span>.activeSink.getAndSet((Object)<span class="keyword">null</span>);</span><br><span class="line">          <span class="keyword">if</span> (oldSink != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="keyword">this</span>.handler.onCancel(arguments);</span><br><span class="line">                  callback.reply(EventChannel.<span class="keyword">this</span>.codec.encodeSuccessEnvelope((Object)<span class="keyword">null</span>));</span><br><span class="line">              &#125; <span class="keyword">catch</span> (RuntimeException var5) &#123;</span><br><span class="line">                  Log.e(<span class="string">"EventChannel#"</span> + EventChannel.<span class="keyword">this</span>.name, <span class="string">"Failed to close event stream"</span>, var5);</span><br><span class="line">                  callback.reply(EventChannel.<span class="keyword">this</span>.codec.encodeErrorEnvelope(<span class="string">"error"</span>, var5.getMessage(), (Object)<span class="keyword">null</span>));</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              callback.reply(EventChannel.<span class="keyword">this</span>.codec.encodeErrorEnvelope(<span class="string">"error"</span>, <span class="string">"No active stream to cancel"</span>, (Object)<span class="keyword">null</span>));</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>onMessage分发下去三个方法，开始监听和取消监听，名称不对就立即回复空消息。<br>onListen中创建EventChannel.EventSink，并回调给EventChannel.StreamHandler，就是我们自己写的继承方法了，然后在reply回复操作成功，可以看出每个消息都必须有回复。</p><h3 id="事件调用流程"><a href="#事件调用流程" class="headerlink" title="事件调用流程"></a>事件调用流程</h3><p>事件调用由EventSink发起，看EventSinkImplementation：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EventSinkImplementation</span> <span class="keyword">implements</span> <span class="title">EventChannel</span>.<span class="title">EventSink</span> </span>&#123;</span><br><span class="line">           <span class="keyword">final</span> AtomicBoolean hasEnded;</span><br><span class="line"></span><br><span class="line">           <span class="function"><span class="keyword">private</span> <span class="title">EventSinkImplementation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="keyword">this</span>.hasEnded = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="meta">@UiThread</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">success</span><span class="params">(Object event)</span> </span>&#123;</span><br><span class="line">               <span class="keyword">if</span> (!<span class="keyword">this</span>.hasEnded.get() &amp;&amp; IncomingStreamRequestHandler.<span class="keyword">this</span>.activeSink.get() == <span class="keyword">this</span>) &#123;</span><br><span class="line">                   EventChannel.<span class="keyword">this</span>.messenger.send(EventChannel.<span class="keyword">this</span>.name, EventChannel.<span class="keyword">this</span>.codec.encodeSuccessEnvelope(event));</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="meta">@UiThread</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">error</span><span class="params">(String errorCode, String errorMessage, Object errorDetails)</span> </span>&#123;</span><br><span class="line">               <span class="keyword">if</span> (!<span class="keyword">this</span>.hasEnded.get() &amp;&amp; IncomingStreamRequestHandler.<span class="keyword">this</span>.activeSink.get() == <span class="keyword">this</span>) &#123;</span><br><span class="line">                   EventChannel.<span class="keyword">this</span>.messenger.send(EventChannel.<span class="keyword">this</span>.name, EventChannel.<span class="keyword">this</span>.codec.encodeErrorEnvelope(errorCode, errorMessage, errorDetails));</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="meta">@UiThread</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endOfStream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="keyword">if</span> (!<span class="keyword">this</span>.hasEnded.getAndSet(<span class="keyword">true</span>) &amp;&amp; IncomingStreamRequestHandler.<span class="keyword">this</span>.activeSink.get() == <span class="keyword">this</span>) &#123;</span><br><span class="line">                   EventChannel.<span class="keyword">this</span>.messenger.send(EventChannel.<span class="keyword">this</span>.name, (ByteBuffer)<span class="keyword">null</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>所有的事件发送都由BinaryMessenger转发，由MethodCodec编码成ByteBuffer类型数据。<br>BinaryMessenger实际是FlutterView：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@UiThread</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String channel, ByteBuffer message)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.send(channel, message, (BinaryReply)<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@UiThread</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String channel, ByteBuffer message, BinaryReply callback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.isAttached()) &#123;</span><br><span class="line">        Log.d(<span class="string">"FlutterView"</span>, <span class="string">"FlutterView.send called on a detached view, channel="</span> + channel);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.mNativeView.send(channel, message, callback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FlutterNativeView：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@UiThread</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String channel, ByteBuffer message, BinaryReply callback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.isAttached()) &#123;</span><br><span class="line">        Log.d(<span class="string">"FlutterNativeView"</span>, <span class="string">"FlutterView.send called on a detached view, channel="</span> + channel);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.dartExecutor.send(channel, message, callback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DartExecutor:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@UiThread</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(@NonNull String channel, @Nullable ByteBuffer message, @Nullable BinaryReply callback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.messenger.send(channel, message, callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>DartMessenger：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@UiThread</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(@NonNull String channel, @NonNull ByteBuffer message)</span> </span>&#123;</span><br><span class="line">    Log.v(<span class="string">"DartMessenger"</span>, <span class="string">"Sending message over channel '"</span> + channel + <span class="string">"'"</span>);</span><br><span class="line">    <span class="keyword">this</span>.send(channel, message, (BinaryReply)<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(@NonNull String channel, @Nullable ByteBuffer message, @Nullable BinaryReply callback)</span> </span>&#123;</span><br><span class="line">    Log.v(<span class="string">"DartMessenger"</span>, <span class="string">"Sending message with callback over channel '"</span> + channel + <span class="string">"'"</span>);</span><br><span class="line">    <span class="keyword">int</span> replyId = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        replyId = <span class="keyword">this</span>.nextReplyId++;</span><br><span class="line">        <span class="keyword">this</span>.pendingReplies.put(replyId, callback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (message == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.flutterJNI.dispatchEmptyPlatformMessage(channel, replyId);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.flutterJNI.dispatchPlatformMessage(channel, message, message.position(), replyId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DartMessenger设置replayId,直接线性递增计数，BinaryReply会保存在map结构pendingReplies中，replyId和BinaryReply一一绑定。</p><p>EventChannel是单向通信，不需要BinaryReply，可以猜测MethodChannel和BaseMessageChannel需要用到BinaryReply，BinaryReply在哪里创建的呢？</p><p>DratMessage接受消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessageFromDart</span><span class="params">(@NonNull String channel, @Nullable <span class="keyword">byte</span>[] message, <span class="keyword">int</span> replyId)</span> </span>&#123;</span><br><span class="line">    Log.v(<span class="string">"DartMessenger"</span>, <span class="string">"Received message from Dart over channel '"</span> + channel + <span class="string">"'"</span>);</span><br><span class="line">    BinaryMessageHandler handler = (BinaryMessageHandler)<span class="keyword">this</span>.messageHandlers.get(channel);</span><br><span class="line">    <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Log.v(<span class="string">"DartMessenger"</span>, <span class="string">"Deferring to registered handler to process message."</span>);</span><br><span class="line">            ByteBuffer buffer = message == <span class="keyword">null</span> ? <span class="keyword">null</span> : ByteBuffer.wrap(message);</span><br><span class="line">            handler.onMessage(buffer, <span class="keyword">new</span> DartMessenger.Reply(<span class="keyword">this</span>.flutterJNI, replyId));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var6) &#123;</span><br><span class="line">            Log.e(<span class="string">"DartMessenger"</span>, <span class="string">"Uncaught exception in binary message listener"</span>, var6);</span><br><span class="line">            <span class="keyword">this</span>.flutterJNI.invokePlatformMessageEmptyResponseCallback(replyId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Log.v(<span class="string">"DartMessenger"</span>, <span class="string">"No registered handler for message. Responding to Dart with empty reply message."</span>);</span><br><span class="line">        <span class="keyword">this</span>.flutterJNI.invokePlatformMessageEmptyResponseCallback(replyId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlePlatformMessageResponse</span><span class="params">(<span class="keyword">int</span> replyId, @Nullable <span class="keyword">byte</span>[] reply)</span> </span>&#123;</span><br><span class="line">    Log.v(<span class="string">"DartMessenger"</span>, <span class="string">"Received message reply from Dart."</span>);</span><br><span class="line">    BinaryReply callback = (BinaryReply)<span class="keyword">this</span>.pendingReplies.remove(replyId);</span><br><span class="line">    <span class="keyword">if</span> (callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Log.v(<span class="string">"DartMessenger"</span>, <span class="string">"Invoking registered callback for reply from Dart."</span>);</span><br><span class="line">            callback.reply(reply == <span class="keyword">null</span> ? <span class="keyword">null</span> : ByteBuffer.wrap(reply));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var5) &#123;</span><br><span class="line">            Log.e(<span class="string">"DartMessenger"</span>, <span class="string">"Uncaught exception in binary message reply handler"</span>, var5);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接受dart消息时会创建DartMessenger.Reply，然后回调给BinaryMessageHandler。处理回调消息时根据replayId移除BinaryReply，然后再回调reply方法，所以reply是能且仅能调用一次。</p><p>Reply代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Reply</span> <span class="keyword">implements</span> <span class="title">BinaryReply</span> </span>&#123;</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FlutterJNI flutterJNI;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> replyId;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean done = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    Reply(<span class="meta">@NonNull</span> FlutterJNI flutterJNI, <span class="keyword">int</span> replyId) &#123;</span><br><span class="line">        <span class="keyword">this</span>.flutterJNI = flutterJNI;</span><br><span class="line">        <span class="keyword">this</span>.replyId = replyId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reply</span><span class="params">(@Nullable ByteBuffer reply)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.done.getAndSet(<span class="keyword">true</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Reply already submitted"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (reply == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.flutterJNI.invokePlatformMessageEmptyResponseCallback(<span class="keyword">this</span>.replyId);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.flutterJNI.invokePlatformMessageResponseCallback(<span class="keyword">this</span>.replyId, reply, reply.position());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过AtomicBoolean使reply只能调用一次，多次调用会抛出”Reply already submitted”异常。</p><p>FlutterJNI：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@UiThread</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchPlatformMessage</span><span class="params">(@NonNull String channel, @Nullable ByteBuffer message, <span class="keyword">int</span> position, <span class="keyword">int</span> responseId)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.ensureRunningOnMainThread();</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.isAttached()) &#123;</span><br><span class="line">          <span class="keyword">this</span>.nativeDispatchPlatformMessage(<span class="keyword">this</span>.nativePlatformViewId, channel, message, position, responseId);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          Log.w(<span class="string">"FlutterJNI"</span>, <span class="string">"Tried to send a platform message to Flutter, but FlutterJNI was detached from native C++. Could not send. Channel: "</span> + channel + <span class="string">". Response ID: "</span> + responseId);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">nativeDispatchPlatformMessage</span><span class="params">(<span class="keyword">long</span> var1, @NonNull String var3, @Nullable ByteBuffer var4, <span class="keyword">int</span> var5, <span class="keyword">int</span> var6)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Called by native.</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unused"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handlePlatformMessage</span><span class="params">(@NonNull <span class="keyword">final</span> String channel, <span class="keyword">byte</span>[] message, <span class="keyword">final</span> <span class="keyword">int</span> replyId)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (platformMessageHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">    platformMessageHandler.handleMessageFromDart(channel, message, replyId);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看到通过层层转调后到native方法nativeDispatchPlatformMessage，参数分别是还是channel名称，ByteBuffer数据，数据长度，回答id。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>每个消息都有一个来回的传递，完成一个闭环。先分析从dart到android的调用，EventChannel的启动监听就是一个（BasicMessageChannel的dart消息，MethodChannel的方法调用也是），我们分析其流程：</p><p>1.Dart调用listen方法通过 Platform Channel 机制调用到FlutterJNI的handlePlatformMessage，并随赠一个replyId<br>2.FlutterJNI调用DartMessenger的handleMessageFromDart<br>3.DartMessenger创建reply并转发到BinaryMessageHandler<br>4.IncomingStreamRequestHandler接受到listen消息创建EventSink，reply回复成功或者失败<br>5.Reply通过FlutterJNI回复消息给Platform Channel，对应之前的replyId</p><p>EventChannel发送消息不需要回复，MethodChannel不能发送消息（只能接受方法调用然后回复），BasicMessageChannel可以发送消息并等待回复，分析其流程：</p><p>1.BasicMessageChannel发送消息,需要回调就创建一个IncomingReplyHandler的BinaryReply<br>2.FlutterView发送消息，层层向下转发到DartMessenger<br>3.DartMessenger发送消息，有BinaryReply就replyId自增并绑定BinaryReply到map中<br>4.flutterJNI发送消息到Platform Channel并随带replyId<br>5.Dart层回复通过Platform Channel调用到FlutterJNI的handlePlatformMessageResponse返回replyId<br>6.DartMessenger收到消息回复则移除replyId，调用BinaryReply的回复方法</p><p>两套流程里面都有replyId，但两者却是不冲突的，replyId由发送者创建，每次通信都有方向，只能回复一次，所以不会有id冲突问题。android发送的replyId和dart发送的replyId可以一样，但底层知道方向，维持了两套，不会冲突。</p>]]></content>
    
    <summary type="html">
    
      Flutter与native三种通信方式的使用与数据传递解析
    
    </summary>
    
    
      <category term="Android" scheme="http://anddymao.com/tags/Android/"/>
    
      <category term="Flutter" scheme="http://anddymao.com/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Activity启动与StartingWindow流程深入解析</title>
    <link href="http://anddymao.com/2019/11/02/2019-11-2-Activity%E5%90%AF%E5%8A%A8%E4%B8%8EStartingWindow/"/>
    <id>http://anddymao.com/2019/11/02/2019-11-2-Activity启动与StartingWindow/</id>
    <published>2019-11-02T06:00:00.000Z</published>
    <updated>2020-01-19T02:36:48.919Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础介绍"><a href="#基础介绍" class="headerlink" title="基础介绍"></a>基础介绍</h2><p>Starting Window就是一个用于在Activity创建并初始化成功前显示的临时窗口，拥有的Window Type是TYPE_APPLICATION_STARTING。<br>在startActivity，从而能够立即响应，当activity显示第一帧后会移除这个窗口。</p><p>设置windowDisablePreview属性可以控制Starting Window是否显示，默认是开启，Starting Window样式根据activity的主题生成。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;item name=<span class="string">"android:windowDisablePreview"</span>&gt;<span class="literal">true</span>&lt;/item&gt;</span><br></pre></td></tr></table></figure><p>Starting Window是每个Activity都可以设置的，默认的黑或者白其实就是startWindow，比如从Activity A启动Activity B，A执行onPause后界面就会进入Starting Window了，<br>此时B的onCreate可能都还没执行，直到B的第一帧显示出来后Starting Window才会消失。所以在onCreate改变主题没法影响到startWindow。</p><h2 id="Activity启动流程"><a href="#Activity启动流程" class="headerlink" title="Activity启动流程"></a>Activity启动流程</h2><p>我基于android-28源码分析下整个流程。</p><h3 id="应用启动AMS"><a href="#应用启动AMS" class="headerlink" title="应用启动AMS"></a>应用启动AMS</h3><p>Activity启动流程，首先在应用进程调用startActivity方法，然后调用到Instrumentation，Instrumentation再调用到AMS,我们看下Instrumentation:execStartActivity方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ActivityResult <span class="title">execStartActivity</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">         Context who, IBinder contextThread, IBinder token, Activity target,</span></span></span><br><span class="line"><span class="function"><span class="params">         Intent intent, <span class="keyword">int</span> requestCode, Bundle options)</span> </span>&#123;</span><br><span class="line">     IApplicationThread whoThread = (IApplicationThread) contextThread;</span><br><span class="line">     Uri referrer = target != <span class="keyword">null</span> ? target.onProvideReferrer() : <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">if</span> (referrer != <span class="keyword">null</span>) &#123;</span><br><span class="line">         intent.putExtra(Intent.EXTRA_REFERRER, referrer);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (mActivityMonitors != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">synchronized</span> (mSync) &#123;</span><br><span class="line">             <span class="keyword">final</span> <span class="keyword">int</span> N = mActivityMonitors.size();</span><br><span class="line">             <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">                 <span class="keyword">final</span> ActivityMonitor am = mActivityMonitors.get(i);</span><br><span class="line">                 ActivityResult result = <span class="keyword">null</span>;</span><br><span class="line">                 <span class="keyword">if</span> (am.ignoreMatchingSpecificIntents()) &#123;</span><br><span class="line">                     result = am.onStartActivity(intent);</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">                     am.mHits++;</span><br><span class="line">                     <span class="keyword">return</span> result;</span><br><span class="line">                 &#125; <span class="keyword">else</span> <span class="keyword">if</span> (am.match(who, <span class="keyword">null</span>, intent)) &#123;</span><br><span class="line">                     am.mHits++;</span><br><span class="line">                     <span class="keyword">if</span> (am.isBlocking()) &#123;</span><br><span class="line">                         <span class="keyword">return</span> requestCode &gt;= <span class="number">0</span> ? am.getResult() : <span class="keyword">null</span>;</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         intent.migrateExtraStreamToClipData();</span><br><span class="line">         intent.prepareToLeaveProcess(who);</span><br><span class="line">         <span class="keyword">int</span> result = ActivityManager.getService()</span><br><span class="line">             .startActivity(whoThread, who.getBasePackageName(), intent,</span><br><span class="line">                     intent.resolveTypeIfNeeded(who.getContentResolver()),</span><br><span class="line">                     token, target != <span class="keyword">null</span> ? target.mEmbeddedID : <span class="keyword">null</span>,</span><br><span class="line">                     requestCode, <span class="number">0</span>, <span class="keyword">null</span>, options);</span><br><span class="line">         checkStartActivityResult(result, intent);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Failure from system"</span>, e);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>ActivityManager.getService()获取到IActivityManager的binder引用，然后执行binder方法startActivity，checkStartActivityResult处理返回结果，启动失败都是在这处理的，常见如permission和class not found问题。</p><h3 id="AMS启动Activity"><a href="#AMS启动Activity" class="headerlink" title="AMS启动Activity"></a>AMS启动Activity</h3><h4 id="ActivityManagerService"><a href="#ActivityManagerService" class="headerlink" title="ActivityManagerService"></a>ActivityManagerService</h4><p>ActivityManagerService的startActivity方法会调用startActivityAsUser，startActivityAsUser代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">startActivityAsUser</span><span class="params">(IApplicationThread caller, String callingPackage,</span></span></span><br><span class="line"><span class="function"><span class="params">        Intent intent, String resolvedType, IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> startFlags, ProfilerInfo profilerInfo, Bundle bOptions, <span class="keyword">int</span> userId,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> validateIncomingUser)</span> </span>&#123;</span><br><span class="line">    enforceNotIsolatedCaller(<span class="string">"startActivity"</span>);</span><br><span class="line"></span><br><span class="line">    userId = mActivityStartController.checkTargetUser(userId, validateIncomingUser,</span><br><span class="line">            Binder.getCallingPid(), Binder.getCallingUid(), <span class="string">"startActivityAsUser"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Switch to user app stacks here.</span></span><br><span class="line">    <span class="keyword">return</span> mActivityStartController.obtainStarter(intent, <span class="string">"startActivityAsUser"</span>)</span><br><span class="line">            .setCaller(caller)</span><br><span class="line">            .setCallingPackage(callingPackage)</span><br><span class="line">            .setResolvedType(resolvedType)</span><br><span class="line">            .setResultTo(resultTo)</span><br><span class="line">            .setResultWho(resultWho)</span><br><span class="line">            .setRequestCode(requestCode)</span><br><span class="line">            .setStartFlags(startFlags)</span><br><span class="line">            .setProfilerInfo(profilerInfo)</span><br><span class="line">            .setActivityOptions(bOptions)</span><br><span class="line">            .setMayWait(userId)</span><br><span class="line">            .execute();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ActivityStarter"><a href="#ActivityStarter" class="headerlink" title="ActivityStarter"></a>ActivityStarter</h4><p>ActivityManagerService通过控制器ActivityStartController设置参数最后执行ActivityStarter的execute方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// TODO(b/64750076): Look into passing request directly to these methods to allow</span></span><br><span class="line">        <span class="comment">// for transactional diffs and preprocessing.</span></span><br><span class="line">        <span class="keyword">if</span> (mRequest.mayWait) &#123;</span><br><span class="line">            <span class="keyword">return</span> startActivityMayWait(mRequest.caller, mRequest.callingUid,</span><br><span class="line">                    mRequest.callingPackage, mRequest.intent, mRequest.resolvedType,</span><br><span class="line">                    mRequest.voiceSession, mRequest.voiceInteractor, mRequest.resultTo,</span><br><span class="line">                    mRequest.resultWho, mRequest.requestCode, mRequest.startFlags,</span><br><span class="line">                    mRequest.profilerInfo, mRequest.waitResult, mRequest.globalConfig,</span><br><span class="line">                    mRequest.activityOptions, mRequest.ignoreTargetSecurity, mRequest.userId,</span><br><span class="line">                    mRequest.inTask, mRequest.reason,</span><br><span class="line">                    mRequest.allowPendingRemoteAnimationRegistryLookup);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> startActivity(mRequest.caller, mRequest.intent, mRequest.ephemeralIntent,</span><br><span class="line">                    mRequest.resolvedType, mRequest.activityInfo, mRequest.resolveInfo,</span><br><span class="line">                    mRequest.voiceSession, mRequest.voiceInteractor, mRequest.resultTo,</span><br><span class="line">                    mRequest.resultWho, mRequest.requestCode, mRequest.callingPid,</span><br><span class="line">                    mRequest.callingUid, mRequest.callingPackage, mRequest.realCallingPid,</span><br><span class="line">                    mRequest.realCallingUid, mRequest.startFlags, mRequest.activityOptions,</span><br><span class="line">                    mRequest.ignoreTargetSecurity, mRequest.componentSpecified,</span><br><span class="line">                    mRequest.outActivity, mRequest.inTask, mRequest.reason,</span><br><span class="line">                    mRequest.allowPendingRemoteAnimationRegistryLookup);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        onExecutionComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>execute调用startActivityMayWait或者startActivity，这两个方法最后都会调用到startActivityUnchecked。</p><p>startActivityUnchecked获取到Activity的信息ActivityRecord，ActivityRecord是activity历史栈中的一个节点，代表一个activity.<br>startActivityUnchecked再调用到ActivityStackSupervisor的resumeFocusedStackTopActivityLocked方法。</p><h4 id="ActivityStack和ActivityStackSupervisor"><a href="#ActivityStack和ActivityStackSupervisor" class="headerlink" title="ActivityStack和ActivityStackSupervisor"></a>ActivityStack和ActivityStackSupervisor</h4><p>ActivityStack是activity的栈，ActivityStackSupervisor是ActivityStack的监督者，核心调用转到了ActivityStackSupervisor实现，里面调用顺序如下：</p><p>ActivityStackSupervisor： resumeFocusedStackTopActivityLocked<br>ActivityStack: resumeTopActivityUncheckedLocked<br>ActivityStackSupervisor: resumeTopActivityInnerLocked<br>ActivityStackSupervisor: startSpecificActivityLocked<br>ActivityStackSupervisor: realStartActivityLocked</p><p>realStartActivityLocked就是真正启动activity的地方了，里面调用到了LaunchActivityItem，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ClientTransaction clientTransaction = ClientTransaction.obtain(app.thread,</span><br><span class="line">          r.appToken);</span><br><span class="line">  clientTransaction.addCallback(LaunchActivityItem.obtain(<span class="keyword">new</span> Intent(r.intent),</span><br><span class="line">          System.identityHashCode(r), r.info,</span><br><span class="line">          <span class="comment">// <span class="doctag">TODO:</span> Have this take the merged configuration instead of separate global</span></span><br><span class="line">          <span class="comment">// and override configs.</span></span><br><span class="line">          mergedConfiguration.getGlobalConfiguration(),</span><br><span class="line">          mergedConfiguration.getOverrideConfiguration(), r.compat,</span><br><span class="line">          r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle,</span><br><span class="line">          r.persistentState, results, newIntents, mService.isNextTransitionForward(),</span><br><span class="line">          profilerInfo));</span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">// Schedule transaction.</span></span><br><span class="line">   mService.getLifecycleManager().scheduleTransaction(clientTransaction);</span><br></pre></td></tr></table></figure><p>clientTransaction添加了一个LaunchActivityItem的事务，LaunchActivityItem留待后续再详解。</p><h4 id="ClientTransaction事务传递"><a href="#ClientTransaction事务传递" class="headerlink" title="ClientTransaction事务传递"></a>ClientTransaction事务传递</h4><p>ClientLifecycleManager的scheduleTransaction方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleTransaction</span><span class="params">(ClientTransaction transaction)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> IApplicationThread client = transaction.getClient();</span><br><span class="line">    transaction.schedule();</span><br><span class="line">    <span class="keyword">if</span> (!(client <span class="keyword">instanceof</span> Binder)) &#123;</span><br><span class="line">        <span class="comment">// If client is not an instance of Binder - it's a remote call and at this point it is</span></span><br><span class="line">        <span class="comment">// safe to recycle the object. All objects used for local calls will be recycled after</span></span><br><span class="line">        <span class="comment">// the transaction is executed on client in ActivityThread.</span></span><br><span class="line">        transaction.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ClientTransaction的schedule方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">schedule</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.mClient.scheduleTransaction(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ApplicationThread的scheduleTransaction方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleTransaction</span><span class="params">(ClientTransaction transaction)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    ActivityThread.<span class="keyword">this</span>.scheduleTransaction(transaction);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ClientTransaction的scheduleTransaction方法,层层调用下来，调用到mClient的scheduleTransaction，mClient是IApplicationThread类型，IApplicationThread是一个控制接口，android.app.IApplicationThread.Stub继承Binder并实现IApplicationThread，<br>最后又被ActivityThread中的ApplicationThread实现。这是一个binder方法，调用到了应用进程，执行ApplicationThread的scheduleTransaction方法。</p><h3 id="用户进程ActivityThread启动Activity"><a href="#用户进程ActivityThread启动Activity" class="headerlink" title="用户进程ActivityThread启动Activity"></a>用户进程ActivityThread启动Activity</h3><h4 id="scheduleTransaction"><a href="#scheduleTransaction" class="headerlink" title="scheduleTransaction"></a>scheduleTransaction</h4><p>ActivityThread的scheduleTransaction方法，实际在父类ClientTransactionHandler中，发送一个消息执行事务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleTransaction</span><span class="params">(ClientTransaction transaction)</span> </span>&#123;</span><br><span class="line">    transaction.preExecute(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.sendMessage(<span class="number">159</span>, transaction);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在H（handler）中被执行，这里到了应用主线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">159</span>:</span><br><span class="line">     ClientTransaction transaction = (ClientTransaction)msg.obj;</span><br><span class="line">     ActivityThread.<span class="keyword">this</span>.mTransactionExecutor.execute(transaction);</span><br><span class="line">     <span class="keyword">if</span> (ActivityThread.isSystem()) &#123;</span><br><span class="line">         transaction.recycle();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><h4 id="ClientTransaction事务"><a href="#ClientTransaction事务" class="headerlink" title="ClientTransaction事务"></a>ClientTransaction事务</h4><p>这里有个execute方法，事务执行器启动了事务。这个就是之前被添加的LaunchActivityItem，看其execute方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(ClientTransactionHandler client, IBinder token,</span></span></span><br><span class="line"><span class="function"><span class="params">        PendingTransactionActions pendingActions)</span> </span>&#123;</span><br><span class="line">    Trace.traceBegin(TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"activityStart"</span>);</span><br><span class="line">    ActivityClientRecord r = <span class="keyword">new</span> ActivityClientRecord(token, mIntent, mIdent, mInfo,</span><br><span class="line">            mOverrideConfig, mCompatInfo, mReferrer, mVoiceInteractor, mState, mPersistentState,</span><br><span class="line">            mPendingResults, mPendingNewIntents, mIsForward,</span><br><span class="line">            mProfilerInfo, client);</span><br><span class="line">    client.handleLaunchActivity(r, pendingActions, <span class="keyword">null</span> <span class="comment">/* customIntent */</span>);</span><br><span class="line">    Trace.traceEnd(TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道ClientTransactionHandler的实现就是ActivityThread，这个事务处理已经在用户主线程了，看对应handleLaunchActivity方法。</p><h4 id="activity创建"><a href="#activity创建" class="headerlink" title="activity创建"></a>activity创建</h4><p>ActivityThread的handleLaunchActivity方法，进行窗口和配置的初始化，然后调用performLaunchActivity。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Activity <span class="title">handleLaunchActivity</span><span class="params">(ActivityThread.ActivityClientRecord r, PendingTransactionActions pendingActions, Intent customIntent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.unscheduleGcIdler();</span><br><span class="line">    <span class="keyword">this</span>.mSomeActivitiesChanged = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (r.profilerInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.mProfiler.setProfiler(r.profilerInfo);</span><br><span class="line">        <span class="keyword">this</span>.mProfiler.startProfiling();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.handleConfigurationChanged((Configuration)<span class="keyword">null</span>, (CompatibilityInfo)<span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (!ThreadedRenderer.sRendererDisabled) &#123;</span><br><span class="line">        GraphicsEnvironment.earlyInitEGL();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    WindowManagerGlobal.initialize();</span><br><span class="line">    Activity a = <span class="keyword">this</span>.performLaunchActivity(r, customIntent);</span><br><span class="line">    <span class="keyword">if</span> (a != <span class="keyword">null</span>) &#123;</span><br><span class="line">        r.createdConfig = <span class="keyword">new</span> Configuration(<span class="keyword">this</span>.mConfiguration);</span><br><span class="line">        <span class="keyword">this</span>.reportSizeConfigurations(r);</span><br><span class="line">        <span class="keyword">if</span> (!r.activity.mFinished &amp;&amp; pendingActions != <span class="keyword">null</span>) &#123;</span><br><span class="line">            pendingActions.setOldState(r.state);</span><br><span class="line">            pendingActions.setRestoreInstanceState(<span class="keyword">true</span>);</span><br><span class="line">            pendingActions.setCallOnPostCreate(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ActivityManager.getService().finishActivity(r.token, <span class="number">0</span>, (Intent)<span class="keyword">null</span>, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException var6) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var6.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>performLaunchActivity获取到了classloader，然后调用mInstrumentation.newActivity创建activity：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span><span class="params">(ActivityThread.ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class="line">       ActivityInfo aInfo = r.activityInfo;</span><br><span class="line">       <span class="keyword">if</span> (r.packageInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">           r.packageInfo = <span class="keyword">this</span>.getPackageInfo((ApplicationInfo)aInfo.applicationInfo, r.compatInfo, <span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       ComponentName component = r.intent.getComponent();</span><br><span class="line">       <span class="keyword">if</span> (component == <span class="keyword">null</span>) &#123;</span><br><span class="line">           component = r.intent.resolveActivity(<span class="keyword">this</span>.mInitialApplication.getPackageManager());</span><br><span class="line">           r.intent.setComponent(component);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (r.activityInfo.targetActivity != <span class="keyword">null</span>) &#123;</span><br><span class="line">           component = <span class="keyword">new</span> ComponentName(r.activityInfo.packageName, r.activityInfo.targetActivity);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       ContextImpl appContext = <span class="keyword">this</span>.createBaseContextForActivity(r);</span><br><span class="line">       Activity activity = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           ClassLoader cl = appContext.getClassLoader();</span><br><span class="line">           activity = <span class="keyword">this</span>.mInstrumentation.newActivity(cl, component.getClassName(), r.intent);</span><br><span class="line">           StrictMode.incrementExpectedActivityCount(activity.getClass());</span><br><span class="line">           r.intent.setExtrasClassLoader(cl);</span><br><span class="line">           r.intent.prepareToEnterProcess();</span><br><span class="line">           <span class="keyword">if</span> (r.state != <span class="keyword">null</span>) &#123;</span><br><span class="line">               r.state.setClassLoader(cl);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception var14) &#123;</span><br><span class="line">           <span class="keyword">if</span> (!<span class="keyword">this</span>.mInstrumentation.onException(activity, var14)) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Unable to instantiate activity "</span> + component + <span class="string">": "</span> + var14.toString(), var14);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           Application app = r.packageInfo.makeApplication(<span class="keyword">false</span>, <span class="keyword">this</span>.mInstrumentation);</span><br><span class="line">           <span class="keyword">if</span> (activity != <span class="keyword">null</span>) &#123;</span><br><span class="line">               CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager());</span><br><span class="line">               Configuration config = <span class="keyword">new</span> Configuration(<span class="keyword">this</span>.mCompatConfiguration);</span><br><span class="line">               <span class="keyword">if</span> (r.overrideConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   config.updateFrom(r.overrideConfig);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               Window window = <span class="keyword">null</span>;</span><br><span class="line">               <span class="keyword">if</span> (r.mPendingRemoveWindow != <span class="keyword">null</span> &amp;&amp; r.mPreserveWindow) &#123;</span><br><span class="line">                   window = r.mPendingRemoveWindow;</span><br><span class="line">                   r.mPendingRemoveWindow = <span class="keyword">null</span>;</span><br><span class="line">                   r.mPendingRemoveWindowManager = <span class="keyword">null</span>;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               appContext.setOuterContext(activity);</span><br><span class="line">               activity.attach(appContext, <span class="keyword">this</span>, <span class="keyword">this</span>.getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor, window, r.configCallback);</span><br><span class="line">               <span class="keyword">if</span> (customIntent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   activity.mIntent = customIntent;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               r.lastNonConfigurationInstances = <span class="keyword">null</span>;</span><br><span class="line">               <span class="keyword">this</span>.checkAndBlockForNetworkAccess();</span><br><span class="line">               activity.mStartedActivity = <span class="keyword">false</span>;</span><br><span class="line">               <span class="keyword">int</span> theme = r.activityInfo.getThemeResource();</span><br><span class="line">               <span class="keyword">if</span> (theme != <span class="number">0</span>) &#123;</span><br><span class="line">                   activity.setTheme(theme);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               activity.mCalled = <span class="keyword">false</span>;</span><br><span class="line">               <span class="keyword">if</span> (r.isPersistable()) &#123;</span><br><span class="line">                   <span class="keyword">this</span>.mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="keyword">this</span>.mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (!activity.mCalled) &#123;</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> SuperNotCalledException(<span class="string">"Activity "</span> + r.intent.getComponent().toShortString() + <span class="string">" did not call through to super.onCreate()"</span>);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               r.activity = activity;</span><br><span class="line">               r.stopped = <span class="keyword">true</span>;</span><br><span class="line">               <span class="keyword">if</span> (!r.activity.mFinished) &#123;</span><br><span class="line">                   activity.performStart();</span><br><span class="line">                   r.stopped = <span class="keyword">false</span>;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (!r.activity.mFinished) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (r.isPersistable()) &#123;</span><br><span class="line">                       <span class="keyword">if</span> (r.state != <span class="keyword">null</span> || r.persistentState != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           <span class="keyword">this</span>.mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state, r.persistentState);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r.state != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       <span class="keyword">this</span>.mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (!r.activity.mFinished) &#123;</span><br><span class="line">                   activity.mCalled = <span class="keyword">false</span>;</span><br><span class="line">                   <span class="keyword">if</span> (r.isPersistable()) &#123;</span><br><span class="line">                       <span class="keyword">this</span>.mInstrumentation.callActivityOnPostCreate(activity, r.state, r.persistentState);</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       <span class="keyword">this</span>.mInstrumentation.callActivityOnPostCreate(activity, r.state);</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">if</span> (!activity.mCalled) &#123;</span><br><span class="line">                       <span class="keyword">throw</span> <span class="keyword">new</span> SuperNotCalledException(<span class="string">"Activity "</span> + r.intent.getComponent().toShortString() + <span class="string">" did not call through to super.onPostCreate()"</span>);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           r.paused = <span class="keyword">true</span>;</span><br><span class="line">           <span class="keyword">this</span>.mActivities.put(r.token, r);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (SuperNotCalledException var12) &#123;</span><br><span class="line">           <span class="keyword">throw</span> var12;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception var13) &#123;</span><br><span class="line">           <span class="keyword">if</span> (!<span class="keyword">this</span>.mInstrumentation.onException(activity, var13)) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Unable to start activity "</span> + component + <span class="string">": "</span> + var13.toString(), var13);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> activity;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>Instrumentation创建activity：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Activity <span class="title">newActivity</span><span class="params">(ClassLoader cl, String className, Intent intent)</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException, ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Activity)cl.loadClass(className).newInstance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>应用启动activity<br>1.Activity:startActivityForResult<br>2.Instrumentation:execStartActivity<br>3.ActivityManagerService:startActivity</p><p>AMS启动Activity<br>1.ActivityManagerService:startActivity AMS检查用户信息调用到Activity启动器<br>2.ActivityStarter:startActivityUnchecked Activity启动器获取到activity栈等信息，设置一些状态<br>3.ActivityStackSupervisor：realStartActivityLocked添加使用LaunchActivityItem事务并使用IApplicationThread安排进计划</p><p>ActivityThread创建Activity<br>1.ActivityThread:scheduleTransaction安排事务，发送一个消息给handler<br>2.ActivityThread在Handler主线程中执行事务，即LaunchActivityItem的execute方法<br>3.ActivityThread：handleLaunchActivity到performLaunchActivity获取classloader，创建window<br>4.Instrumentation的newActivity通过classloader加载activity类</p><h2 id="Starting-Window-流程"><a href="#Starting-Window-流程" class="headerlink" title="Starting Window 流程"></a>Starting Window 流程</h2><h3 id="Starting-Window显示"><a href="#Starting-Window显示" class="headerlink" title="Starting Window显示"></a>Starting Window显示</h3><h4 id="调用入口"><a href="#调用入口" class="headerlink" title="调用入口"></a>调用入口</h4><p>Starting Window是启动activity立即显示的，所以在AMS启动activity中被创建的，果然在ActivityStarter找到了对应方法。</p><p>ActivityStarter调用startActivityUnchecked时会调用setTargetStackAndMoveToFrontIfNeeded：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Figure out which task and activity to bring to front when we have found an existing matching</span></span><br><span class="line"><span class="comment"> * activity record in history. May also clear the task if needed.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> intentActivity Existing matching activity.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> ActivityRecord&#125; brought to front.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> ActivityRecord <span class="title">setTargetStackAndMoveToFrontIfNeeded</span><span class="params">(ActivityRecord intentActivity)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      ...</span><br><span class="line">      intentActivity.showStartingWindow(<span class="keyword">null</span> <span class="comment">/* prev */</span>, <span class="keyword">false</span> <span class="comment">/* newTask */</span>,</span><br><span class="line">                        <span class="keyword">true</span> <span class="comment">/* taskSwitch */</span>);</span><br><span class="line">                        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法是已经有activity存在时恢复activity调用的，恢复前会调用showStartingWindow显示StartingWindow。</p><p>又在resumeTopActivityInnerLocked和moveTaskToFrontLocked等处找到了showStartingWindow的调用。<br>resumeTopActivityInnerLocked是前面正常启动activity的步骤，moveTaskToFrontLocked应该是把activity移到前台的调用，<br>都是activity回到前台时需要，符合我们的理解。</p><p>ActivityRecord的showStartingWindow方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showStartingWindow</span><span class="params">(ActivityRecord prev, <span class="keyword">boolean</span> newTask, <span class="keyword">boolean</span> taskSwitch,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> fromRecents)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mWindowContainerController == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mTaskOverlay) &#123;</span><br><span class="line">        <span class="comment">// We don't show starting window for overlay activities.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">final</span> CompatibilityInfo compatInfo =</span><br><span class="line">            service.compatibilityInfoForPackageLocked(info.applicationInfo);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> shown = mWindowContainerController.addStartingWindow(packageName, theme,</span><br><span class="line">            compatInfo, nonLocalizedLabel, labelRes, icon, logo, windowFlags,</span><br><span class="line">            prev != <span class="keyword">null</span> ? prev.appToken : <span class="keyword">null</span>, newTask, taskSwitch, isProcessRunning(),</span><br><span class="line">            allowTaskSnapshot(),</span><br><span class="line">            mState.ordinal() &gt;= RESUMED.ordinal() &amp;&amp; mState.ordinal() &lt;= STOPPED.ordinal(),</span><br><span class="line">            fromRecents);</span><br><span class="line">    <span class="keyword">if</span> (shown) &#123;</span><br><span class="line">        mStartingWindowState = STARTING_WINDOW_SHOWN;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="判断主题是否添加"><a href="#判断主题是否添加" class="headerlink" title="判断主题是否添加"></a>判断主题是否添加</h4><p>mWindowContainerController.addStartingWindow，<br>这里获取了主题样式，判断是否要显示starting window，如果是透明或者是窗口模式等等就不会显示，之前讲的windowDisablePreview熟悉也是在这里获取，不可用就直接false，最后调用scheduleAddStartingWindow。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addStartingWindow</span><span class="params">(String pkg, <span class="keyword">int</span> theme, CompatibilityInfo compatInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">         CharSequence nonLocalizedLabel, <span class="keyword">int</span> labelRes, <span class="keyword">int</span> icon, <span class="keyword">int</span> logo, <span class="keyword">int</span> windowFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">         IBinder transferFrom, <span class="keyword">boolean</span> newTask, <span class="keyword">boolean</span> taskSwitch, <span class="keyword">boolean</span> processRunning,</span></span></span><br><span class="line"><span class="function"><span class="params">         <span class="keyword">boolean</span> allowTaskSnapshot, <span class="keyword">boolean</span> activityCreated, <span class="keyword">boolean</span> fromRecents)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">synchronized</span>(mWindowMap) &#123;</span><br><span class="line">         <span class="keyword">if</span> (DEBUG_STARTING_WINDOW) Slog.v(TAG_WM, <span class="string">"setAppStartingWindow: token="</span> + mToken</span><br><span class="line">                 + <span class="string">" pkg="</span> + pkg + <span class="string">" transferFrom="</span> + transferFrom + <span class="string">" newTask="</span> + newTask</span><br><span class="line">                 + <span class="string">" taskSwitch="</span> + taskSwitch + <span class="string">" processRunning="</span> + processRunning</span><br><span class="line">                 + <span class="string">" allowTaskSnapshot="</span> + allowTaskSnapshot);</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (mContainer == <span class="keyword">null</span>) &#123;</span><br><span class="line">             Slog.w(TAG_WM, <span class="string">"Attempted to set icon of non-existing app token: "</span> + mToken);</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// If the display is frozen, we won't do anything until the actual window is</span></span><br><span class="line">         <span class="comment">// displayed so there is no reason to put in the starting window.</span></span><br><span class="line">         <span class="keyword">if</span> (!mContainer.okToDisplay()) &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (mContainer.startingData != <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">final</span> WindowState mainWin = mContainer.findMainWindow();</span><br><span class="line">         <span class="keyword">if</span> (mainWin != <span class="keyword">null</span> &amp;&amp; mainWin.mWinAnimator.getShown()) &#123;</span><br><span class="line">             <span class="comment">// App already has a visible window...why would you want a starting window?</span></span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">final</span> TaskSnapshot snapshot = mService.mTaskSnapshotController.getSnapshot(</span><br><span class="line">                 mContainer.getTask().mTaskId, mContainer.getTask().mUserId,</span><br><span class="line">                 <span class="keyword">false</span> <span class="comment">/* restoreFromDisk */</span>, <span class="keyword">false</span> <span class="comment">/* reducedResolution */</span>);</span><br><span class="line">         <span class="keyword">final</span> <span class="keyword">int</span> type = getStartingWindowType(newTask, taskSwitch, processRunning,</span><br><span class="line">                 allowTaskSnapshot, activityCreated, fromRecents, snapshot);</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (type == STARTING_WINDOW_TYPE_SNAPSHOT) &#123;</span><br><span class="line">             <span class="keyword">return</span> createSnapshot(snapshot);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// If this is a translucent window, then don't show a starting window -- the current</span></span><br><span class="line">         <span class="comment">// effect (a full-screen opaque starting window that fades away to the real contents</span></span><br><span class="line">         <span class="comment">// when it is ready) does not work for this.</span></span><br><span class="line">         <span class="keyword">if</span> (DEBUG_STARTING_WINDOW) Slog.v(TAG_WM, <span class="string">"Checking theme of starting window: 0x"</span></span><br><span class="line">                 + Integer.toHexString(theme));</span><br><span class="line">         <span class="keyword">if</span> (theme != <span class="number">0</span>) &#123;</span><br><span class="line">             AttributeCache.Entry ent = AttributeCache.instance().get(pkg, theme,</span><br><span class="line">                     com.android.internal.R.styleable.Window, mService.mCurrentUserId);</span><br><span class="line">             <span class="keyword">if</span> (ent == <span class="keyword">null</span>) &#123;</span><br><span class="line">                 <span class="comment">// Whoops!  App doesn't exist. Um. Okay. We'll just pretend like we didn't</span></span><br><span class="line">                 <span class="comment">// see that.</span></span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">final</span> <span class="keyword">boolean</span> windowIsTranslucent = ent.array.getBoolean(</span><br><span class="line">                     com.android.internal.R.styleable.Window_windowIsTranslucent, <span class="keyword">false</span>);</span><br><span class="line">             <span class="keyword">final</span> <span class="keyword">boolean</span> windowIsFloating = ent.array.getBoolean(</span><br><span class="line">                     com.android.internal.R.styleable.Window_windowIsFloating, <span class="keyword">false</span>);</span><br><span class="line">             <span class="keyword">final</span> <span class="keyword">boolean</span> windowShowWallpaper = ent.array.getBoolean(</span><br><span class="line">                     com.android.internal.R.styleable.Window_windowShowWallpaper, <span class="keyword">false</span>);</span><br><span class="line">             <span class="keyword">final</span> <span class="keyword">boolean</span> windowDisableStarting = ent.array.getBoolean(</span><br><span class="line">                     com.android.internal.R.styleable.Window_windowDisablePreview, <span class="keyword">false</span>);</span><br><span class="line">             <span class="keyword">if</span> (DEBUG_STARTING_WINDOW) Slog.v(TAG_WM, <span class="string">"Translucent="</span> + windowIsTranslucent</span><br><span class="line">                     + <span class="string">" Floating="</span> + windowIsFloating</span><br><span class="line">                     + <span class="string">" ShowWallpaper="</span> + windowShowWallpaper);</span><br><span class="line">             <span class="keyword">if</span> (windowIsTranslucent) &#123;</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span> (windowIsFloating || windowDisableStarting) &#123;</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span> (windowShowWallpaper) &#123;</span><br><span class="line">                 <span class="keyword">if</span> (mContainer.getDisplayContent().mWallpaperController.getWallpaperTarget()</span><br><span class="line">                         == <span class="keyword">null</span>) &#123;</span><br><span class="line">                     <span class="comment">// If this theme is requesting a wallpaper, and the wallpaper</span></span><br><span class="line">                     <span class="comment">// is not currently visible, then this effectively serves as</span></span><br><span class="line">                     <span class="comment">// an opaque window and our starting window transition animation</span></span><br><span class="line">                     <span class="comment">// can still work.  We just need to make sure the starting window</span></span><br><span class="line">                     <span class="comment">// is also showing the wallpaper.</span></span><br><span class="line">                     windowFlags |= FLAG_SHOW_WALLPAPER;</span><br><span class="line">                 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (mContainer.transferStartingWindow(transferFrom)) &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// There is no existing starting window, and we don't want to create a splash screen, so</span></span><br><span class="line">         <span class="comment">// that's it!</span></span><br><span class="line">         <span class="keyword">if</span> (type != STARTING_WINDOW_TYPE_SPLASH_SCREEN) &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (DEBUG_STARTING_WINDOW) Slog.v(TAG_WM, <span class="string">"Creating SplashScreenStartingData"</span>);</span><br><span class="line">         mContainer.startingData = <span class="keyword">new</span> SplashScreenStartingData(mService, pkg, theme,</span><br><span class="line">                 compatInfo, nonLocalizedLabel, labelRes, icon, logo, windowFlags,</span><br><span class="line">                 mContainer.getMergedOverrideConfiguration());</span><br><span class="line">         scheduleAddStartingWindow();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="创建窗口"><a href="#创建窗口" class="headerlink" title="创建窗口"></a>创建窗口</h4><p>scheduleAddStartingWindow有一个动画控制handler，把Starting Windows放到了第一个消息：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">scheduleAddStartingWindow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="comment">// Note: we really want to do sendMessageAtFrontOfQueue() because we</span></span><br><span class="line">         <span class="comment">// want to process the message ASAP, before any other queued</span></span><br><span class="line">         <span class="comment">// messages.</span></span><br><span class="line">         <span class="keyword">if</span> (!mService.mAnimationHandler.hasCallbacks(mAddStartingWindow)) &#123;</span><br><span class="line">             <span class="keyword">if</span> (DEBUG_STARTING_WINDOW) Slog.v(TAG_WM, <span class="string">"Enqueueing ADD_STARTING"</span>);</span><br><span class="line">             mService.mAnimationHandler.postAtFrontOfQueue(mAddStartingWindow);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">```     </span><br><span class="line"></span><br><span class="line">mAddStartingWindow是一个runnable，mAddStartingWindow创建并添加了surface，如果发现了中断就用surface.remove()移除界面。</span><br><span class="line">```java</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Runnable mAddStartingWindow = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> StartingData startingData;</span><br><span class="line">            <span class="keyword">final</span> AppWindowToken container;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (mWindowMap) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mContainer == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG_STARTING_WINDOW) Slog.v(TAG_WM, <span class="string">"mContainer was null while trying to"</span></span><br><span class="line">                            + <span class="string">" add starting window"</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// There can only be one adding request, silly caller!</span></span><br><span class="line">                mService.mAnimationHandler.removeCallbacks(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">                startingData = mContainer.startingData;</span><br><span class="line">                container = mContainer;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (startingData == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Animation has been canceled... do nothing.</span></span><br><span class="line">                <span class="keyword">if</span> (DEBUG_STARTING_WINDOW)</span><br><span class="line">                    Slog.v(TAG_WM, <span class="string">"startingData was nulled out before handling"</span></span><br><span class="line">                            + <span class="string">" mAddStartingWindow: "</span> + mContainer);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (DEBUG_STARTING_WINDOW) Slog.v(TAG_WM, <span class="string">"Add starting "</span></span><br><span class="line">                    + AppWindowContainerController.<span class="keyword">this</span> + <span class="string">": startingData="</span></span><br><span class="line">                    + container.startingData);</span><br><span class="line"></span><br><span class="line">            StartingSurface surface = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                surface = startingData.createStartingSurface(container);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                Slog.w(TAG_WM, <span class="string">"Exception when adding starting window"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (surface != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> abort = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">synchronized</span> (mWindowMap) &#123;</span><br><span class="line">                    <span class="comment">// If the window was successfully added, then</span></span><br><span class="line">                    <span class="comment">// we need to remove it.</span></span><br><span class="line">                    <span class="keyword">if</span> (container.removed || container.startingData == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (DEBUG_STARTING_WINDOW) Slog.v(TAG_WM,</span><br><span class="line">                                <span class="string">"Aborted starting "</span> + container</span><br><span class="line">                                        + <span class="string">": removed="</span> + container.removed</span><br><span class="line">                                        + <span class="string">" startingData="</span> + container.startingData);</span><br><span class="line">                        container.startingWindow = <span class="keyword">null</span>;</span><br><span class="line">                        container.startingData = <span class="keyword">null</span>;</span><br><span class="line">                        abort = <span class="keyword">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        container.startingSurface = surface;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG_STARTING_WINDOW &amp;&amp; !abort) Slog.v(TAG_WM,</span><br><span class="line">                            <span class="string">"Added starting "</span> + mContainer</span><br><span class="line">                                    + <span class="string">": startingWindow="</span></span><br><span class="line">                                    + container.startingWindow + <span class="string">" startingView="</span></span><br><span class="line">                                    + container.startingSurface);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (abort) &#123;</span><br><span class="line">                    surface.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (DEBUG_STARTING_WINDOW) &#123;</span><br><span class="line">                Slog.v(TAG_WM, <span class="string">"Surface returned was null: "</span> + mContainer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>createStartingSurface属于StartingData的虚方法，实现在SplashScreenStartingData中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function">StartingSurface <span class="title">createStartingSurface</span><span class="params">(AppWindowToken atoken)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mService.mPolicy.addSplashScreen(atoken.token, mPkg, mTheme, mCompatInfo,</span><br><span class="line">            mNonLocalizedLabel, mLabelRes, mIcon, mLogo, mWindowFlags,</span><br><span class="line">            mMergedOverrideConfiguration, atoken.getDisplayContent().getDisplayId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用到PhoneWindowManager的addSplashScreen方法，根据样式添加界面，最后通过熟悉的WindowManager.addView显示在界面上，window的类型是TYPE_APPLICATION_STARTING。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> StartingSurface <span class="title">addSplashScreen</span><span class="params">(IBinder appToken, String packageName, <span class="keyword">int</span> theme,</span></span></span><br><span class="line"><span class="function"><span class="params">         CompatibilityInfo compatInfo, CharSequence nonLocalizedLabel, <span class="keyword">int</span> labelRes, <span class="keyword">int</span> icon,</span></span></span><br><span class="line"><span class="function"><span class="params">         <span class="keyword">int</span> logo, <span class="keyword">int</span> windowFlags, Configuration overrideConfig, <span class="keyword">int</span> displayId)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (!SHOW_SPLASH_SCREENS) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (packageName == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     WindowManager wm = <span class="keyword">null</span>;</span><br><span class="line">     View view = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         Context context = mContext;</span><br><span class="line">         <span class="keyword">if</span> (DEBUG_SPLASH_SCREEN) Slog.d(TAG, <span class="string">"addSplashScreen "</span> + packageName</span><br><span class="line">                 + <span class="string">": nonLocalizedLabel="</span> + nonLocalizedLabel + <span class="string">" theme="</span></span><br><span class="line">                 + Integer.toHexString(theme));</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Obtain proper context to launch on the right display.</span></span><br><span class="line">         <span class="keyword">final</span> Context displayContext = getDisplayContext(context, displayId);</span><br><span class="line">         <span class="keyword">if</span> (displayContext == <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="comment">// Can't show splash screen on requested display, so skip showing at all.</span></span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         context = displayContext;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (theme != context.getThemeResId() || labelRes != <span class="number">0</span>) &#123;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 context = context.createPackageContext(packageName, CONTEXT_RESTRICTED);</span><br><span class="line">                 context.setTheme(theme);</span><br><span class="line">             &#125; <span class="keyword">catch</span> (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">                 <span class="comment">// Ignore</span></span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (overrideConfig != <span class="keyword">null</span> &amp;&amp; !overrideConfig.equals(EMPTY)) &#123;</span><br><span class="line">             <span class="keyword">if</span> (DEBUG_SPLASH_SCREEN) Slog.d(TAG, <span class="string">"addSplashScreen: creating context based"</span></span><br><span class="line">                     + <span class="string">" on overrideConfig"</span> + overrideConfig + <span class="string">" for splash screen"</span>);</span><br><span class="line">             <span class="keyword">final</span> Context overrideContext = context.createConfigurationContext(overrideConfig);</span><br><span class="line">             overrideContext.setTheme(theme);</span><br><span class="line">             <span class="keyword">final</span> TypedArray typedArray = overrideContext.obtainStyledAttributes(</span><br><span class="line">                     com.android.internal.R.styleable.Window);</span><br><span class="line">             <span class="keyword">final</span> <span class="keyword">int</span> resId = typedArray.getResourceId(R.styleable.Window_windowBackground, <span class="number">0</span>);</span><br><span class="line">             <span class="keyword">if</span> (resId != <span class="number">0</span> &amp;&amp; overrideContext.getDrawable(resId) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                 <span class="comment">// We want to use the windowBackground for the override context if it is</span></span><br><span class="line">                 <span class="comment">// available, otherwise we use the default one to make sure a themed starting</span></span><br><span class="line">                 <span class="comment">// window is displayed for the app.</span></span><br><span class="line">                 <span class="keyword">if</span> (DEBUG_SPLASH_SCREEN) Slog.d(TAG, <span class="string">"addSplashScreen: apply overrideConfig"</span></span><br><span class="line">                         + overrideConfig + <span class="string">" to starting window resId="</span> + resId);</span><br><span class="line">                 context = overrideContext;</span><br><span class="line">             &#125;</span><br><span class="line">             typedArray.recycle();</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">final</span> PhoneWindow win = <span class="keyword">new</span> PhoneWindow(context);</span><br><span class="line">         win.setIsStartingWindow(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">         CharSequence label = context.getResources().getText(labelRes, <span class="keyword">null</span>);</span><br><span class="line">         <span class="comment">// Only change the accessibility title if the label is localized</span></span><br><span class="line">         <span class="keyword">if</span> (label != <span class="keyword">null</span>) &#123;</span><br><span class="line">             win.setTitle(label, <span class="keyword">true</span>);</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             win.setTitle(nonLocalizedLabel, <span class="keyword">false</span>);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         win.setType(</span><br><span class="line">             WindowManager.LayoutParams.TYPE_APPLICATION_STARTING);</span><br><span class="line"></span><br><span class="line">         <span class="keyword">synchronized</span> (mWindowManagerFuncs.getWindowManagerLock()) &#123;</span><br><span class="line">             <span class="comment">// Assumes it's safe to show starting windows of launched apps while</span></span><br><span class="line">             <span class="comment">// the keyguard is being hidden. This is okay because starting windows never show</span></span><br><span class="line">             <span class="comment">// secret information.</span></span><br><span class="line">             <span class="keyword">if</span> (mKeyguardOccluded) &#123;</span><br><span class="line">                 windowFlags |= FLAG_SHOW_WHEN_LOCKED;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Force the window flags: this is a fake window, so it is not really</span></span><br><span class="line">         <span class="comment">// touchable or focusable by the user.  We also add in the ALT_FOCUSABLE_IM</span></span><br><span class="line">         <span class="comment">// flag because we do know that the next window will take input</span></span><br><span class="line">         <span class="comment">// focus, so we want to get the IME window up on top of us right away.</span></span><br><span class="line">         win.setFlags(</span><br><span class="line">             windowFlags|</span><br><span class="line">             WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE|</span><br><span class="line">             WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE|</span><br><span class="line">             WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM,</span><br><span class="line">             windowFlags|</span><br><span class="line">             WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE|</span><br><span class="line">             WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE|</span><br><span class="line">             WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM);</span><br><span class="line"></span><br><span class="line">         win.setDefaultIcon(icon);</span><br><span class="line">         win.setDefaultLogo(logo);</span><br><span class="line"></span><br><span class="line">         win.setLayout(WindowManager.LayoutParams.MATCH_PARENT,</span><br><span class="line">                 WindowManager.LayoutParams.MATCH_PARENT);</span><br><span class="line"></span><br><span class="line">         <span class="keyword">final</span> WindowManager.LayoutParams params = win.getAttributes();</span><br><span class="line">         params.token = appToken;</span><br><span class="line">         params.packageName = packageName;</span><br><span class="line">         params.windowAnimations = win.getWindowStyle().getResourceId(</span><br><span class="line">                 com.android.internal.R.styleable.Window_windowAnimationStyle, <span class="number">0</span>);</span><br><span class="line">         params.privateFlags |=</span><br><span class="line">                 WindowManager.LayoutParams.PRIVATE_FLAG_FAKE_HARDWARE_ACCELERATED;</span><br><span class="line">         params.privateFlags |= WindowManager.LayoutParams.PRIVATE_FLAG_SHOW_FOR_ALL_USERS;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (!compatInfo.supportsScreen()) &#123;</span><br><span class="line">             params.privateFlags |= WindowManager.LayoutParams.PRIVATE_FLAG_COMPATIBLE_WINDOW;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         params.setTitle(<span class="string">"Splash Screen "</span> + packageName);</span><br><span class="line">         addSplashscreenContent(win, context);</span><br><span class="line"></span><br><span class="line">         wm = (WindowManager) context.getSystemService(WINDOW_SERVICE);</span><br><span class="line">         view = win.getDecorView();</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (DEBUG_SPLASH_SCREEN) Slog.d(TAG, <span class="string">"Adding splash screen window for "</span></span><br><span class="line">             + packageName + <span class="string">" / "</span> + appToken + <span class="string">": "</span> + (view.getParent() != <span class="keyword">null</span> ? view : <span class="keyword">null</span>));</span><br><span class="line"></span><br><span class="line">         wm.addView(view, params);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Only return the view if it was successfully added to the</span></span><br><span class="line">         <span class="comment">// window manager... which we can tell by it having a parent.</span></span><br><span class="line">         <span class="keyword">return</span> view.getParent() != <span class="keyword">null</span> ? <span class="keyword">new</span> SplashScreenSurface(view, appToken) : <span class="keyword">null</span>;</span><br><span class="line">     &#125; <span class="keyword">catch</span> (WindowManager.BadTokenException e) &#123;</span><br><span class="line">         <span class="comment">// ignore</span></span><br><span class="line">         Log.w(TAG, appToken + <span class="string">" already running, starting window not displayed. "</span> +</span><br><span class="line">                 e.getMessage());</span><br><span class="line">     &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">         <span class="comment">// don't crash if something else bad happens, for example a</span></span><br><span class="line">         <span class="comment">// failure loading resources because we are loading from an app</span></span><br><span class="line">         <span class="comment">// on external storage that has been unmounted.</span></span><br><span class="line">         Log.w(TAG, appToken + <span class="string">" failed creating starting window"</span>, e);</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (view != <span class="keyword">null</span> &amp;&amp; view.getParent() == <span class="keyword">null</span>) &#123;</span><br><span class="line">             Log.w(TAG, <span class="string">"view not successfully added to wm, removing view"</span>);</span><br><span class="line">             wm.removeViewImmediate(view);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="Starting-Window移除"><a href="#Starting-Window移除" class="headerlink" title="Starting Window移除"></a>Starting Window移除</h3><p>显示第一帧后Starting Window就可以消失了。</p><h4 id="调用入口-1"><a href="#调用入口-1" class="headerlink" title="调用入口"></a>调用入口</h4><p>在AppWindowToken:onFirstWindowDrawn找到了调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onFirstWindowDrawn</span><span class="params">(WindowState win, WindowStateAnimator winAnimator)</span> </span>&#123;</span><br><span class="line">    firstWindowDrawn = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We now have a good window to show, remove dead placeholders</span></span><br><span class="line">    removeDeadWindows();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (startingWindow != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_STARTING_WINDOW || DEBUG_ANIM) Slog.v(TAG, <span class="string">"Finish starting "</span></span><br><span class="line">                + win.mToken + <span class="string">": first real window is shown, no animation"</span>);</span><br><span class="line">        <span class="comment">// If this initial window is animating, stop it -- we will do an animation to reveal</span></span><br><span class="line">        <span class="comment">// it from behind the starting window, so there is no need for it to also be doing its</span></span><br><span class="line">        <span class="comment">// own stuff.</span></span><br><span class="line">        win.cancelAnimation();</span><br><span class="line">        <span class="keyword">if</span> (getController() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            getController().removeStartingWindow();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    updateReportedVisibilityLocked();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外还有handleClosingApps，notifyAppStopped等activity异常退出时也需要销毁掉 Starting Window，这里不一一看了，直接看remove流程。</p><h4 id="remove流程"><a href="#remove流程" class="headerlink" title="remove流程"></a>remove流程</h4><p>AppWindowContainerController的removeStartingWindow方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeStartingWindow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (mWindowMap) &#123;</span><br><span class="line">          <span class="keyword">if</span> (mContainer.startingWindow == <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (mContainer.startingData != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  <span class="comment">// Starting window has not been added yet, but it is scheduled to be added.</span></span><br><span class="line">                  <span class="comment">// Go ahead and cancel the request.</span></span><br><span class="line">                  <span class="keyword">if</span> (DEBUG_STARTING_WINDOW) Slog.v(TAG_WM,</span><br><span class="line">                          <span class="string">"Clearing startingData for token="</span> + mContainer);</span><br><span class="line">                  mContainer.startingData = <span class="keyword">null</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">final</span> StartingSurface surface;</span><br><span class="line">          <span class="keyword">if</span> (mContainer.startingData != <span class="keyword">null</span>) &#123;</span><br><span class="line">              surface = mContainer.startingSurface;</span><br><span class="line">              mContainer.startingData = <span class="keyword">null</span>;</span><br><span class="line">              mContainer.startingSurface = <span class="keyword">null</span>;</span><br><span class="line">              mContainer.startingWindow = <span class="keyword">null</span>;</span><br><span class="line">              mContainer.startingDisplayed = <span class="keyword">false</span>;</span><br><span class="line">              <span class="keyword">if</span> (surface == <span class="keyword">null</span> &amp;&amp; DEBUG_STARTING_WINDOW) &#123;</span><br><span class="line">                  Slog.v(TAG_WM, <span class="string">"startingWindow was set but startingSurface==null, couldn't "</span></span><br><span class="line">                          + <span class="string">"remove"</span>);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">if</span> (DEBUG_STARTING_WINDOW) &#123;</span><br><span class="line">                  Slog.v(TAG_WM, <span class="string">"Tried to remove starting window but startingWindow was null:"</span></span><br><span class="line">                          + mContainer);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (DEBUG_STARTING_WINDOW) Slog.v(TAG_WM, <span class="string">"Schedule remove starting "</span> + mContainer</span><br><span class="line">                  + <span class="string">" startingWindow="</span> + mContainer.startingWindow</span><br><span class="line">                  + <span class="string">" startingView="</span> + mContainer.startingSurface);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Use the same thread to remove the window as we used to add it, as otherwise we end up</span></span><br><span class="line">          <span class="comment">// with things in the view hierarchy being called from different threads.</span></span><br><span class="line">          mService.mAnimationHandler.post(() -&gt; &#123;</span><br><span class="line">              <span class="keyword">if</span> (DEBUG_STARTING_WINDOW) Slog.v(TAG_WM, <span class="string">"Removing startingView="</span> + surface);</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  surface.remove();</span><br><span class="line">              &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                  Slog.w(TAG_WM, <span class="string">"Exception when removing starting window"</span>, e);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>在mAnimationHandler中调用surface.remove()方法，和前面创建时一样。</p><p>StartingSurface的remove方法在SplashScreenSurface实现，直接调用WindowManager的removeView方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SplashScreenSurface</span> <span class="keyword">implements</span> <span class="title">StartingSurface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = PhoneWindowManager.TAG;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> View mView;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IBinder mAppToken;</span><br><span class="line"></span><br><span class="line">    SplashScreenSurface(View view, IBinder appToken) &#123;</span><br><span class="line">        mView = view;</span><br><span class="line">        mAppToken = appToken;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_SPLASH_SCREEN) Slog.v(TAG, <span class="string">"Removing splash screen window for "</span> + mAppToken + <span class="string">": "</span></span><br><span class="line">                        + <span class="keyword">this</span> + <span class="string">" Callers="</span> + Debug.getCallers(<span class="number">4</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> WindowManager wm = mView.getContext().getSystemService(WindowManager.class);</span><br><span class="line">        wm.removeView(mView);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>Starting Window显示<br>时机：AMS找到Activity信息后，创建activity前，直接由AMS进程控制<br>流程：<br>1.AppWindowContainerController:addStartingWindow 控制是否添加<br>2.scheduleAddStartingWindow把mAddStartingWindow放到mAnimationHandler中执行<br>3.SplashScreenStartingData:createStartingSurface创建窗口<br>4.PhoneWindowManager:addSplashScreen通过WMS添加view</p><p>Starting Window消失<br>时机：activity显示第一帧或者activity异常退出<br>流程：<br>1.AppWindowContainerController:removeStartingWindow 如果surface存在则发消息到mAnimationHandler<br>2.mAnimationHandler执行surface.remove();<br>3.SplashScreenSurface的remove方法通过WMS移除view</p>]]></content>
    
    <summary type="html">
    
      从Activity启动流程深入解析Starting Window
    
    </summary>
    
    
      <category term="Android" scheme="http://anddymao.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>视频滤镜框架movit介绍与流程解析</title>
    <link href="http://anddymao.com/2019/10/27/2019-10-27-movit/"/>
    <id>http://anddymao.com/2019/10/27/2019-10-27-movit/</id>
    <published>2019-10-27T06:00:00.000Z</published>
    <updated>2020-01-19T02:36:48.918Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础介绍"><a href="#基础介绍" class="headerlink" title="基础介绍"></a>基础介绍</h2><p>官方介绍：A library for high-quality, high-performance video filters。<br>一个高质量高性能的视频滤镜框架，采用GNU2协议。</p><p>源码链接：<br><a href="https://git.sesse.net/?p=movit;a=summary" target="_blank" rel="noopener">https://git.sesse.net/?p=movit;a=summary</a></p><p>采用C++编写，官方讲解基本没有，网上信息很少，只能靠源码了解了。</p><h2 id="类定义和结构"><a href="#类定义和结构" class="headerlink" title="类定义和结构"></a>类定义和结构</h2><p>先看make文件Makefile.in：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HDRS = effect_chain.h effect_util.h effect.h input.h image_format.h init.h util.h defs.h resource_pool.h fp16.h ycbcr.h version.h</span><br><span class="line">HDRS += $(INPUTS:=.h)</span><br><span class="line">HDRS += $(EFFECTS:=.h)</span><br></pre></td></tr></table></figure></p><p>这些就是movit的主要流程代码了.Effect_chain为核心，effect为基础单位，输入工具类为辅助，组合成了一个链式结构框架。</p><p>其余都是effect和input各种类型的实例，还有测试代码和着色器代码，可以先忽略。</p><h3 id="Effect"><a href="#Effect" class="headerlink" title="Effect"></a>Effect</h3><p>特效的基本单位，定义了一些公共的方法，对于一个OpenGL程序，需要顶点着色器，片段着色器，传入参数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">inform_input_size</span><span class="params">(<span class="keyword">unsigned</span> input_num, <span class="keyword">unsigned</span> width, <span class="keyword">unsigned</span> height)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// How many inputs this effect will take (a fixed number).</span></span><br><span class="line"><span class="comment">// If you have only one input, it will be called INPUT() in GLSL;</span></span><br><span class="line"><span class="comment">// if you have several, they will be INPUT1(), INPUT2(), and so on.</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">unsigned</span> <span class="title">num_inputs</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Inform the effect that it has been just added to the EffectChain.</span></span><br><span class="line"><span class="comment">// The primary use for this is to store the ResourcePool uesd by</span></span><br><span class="line"><span class="comment">// the chain; for modifications to it, rewrite_graph() below</span></span><br><span class="line"><span class="comment">// is probably a better fit.</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">inform_added</span><span class="params">(EffectChain *chain)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Let the effect rewrite the effect chain as it sees fit.</span></span><br><span class="line"><span class="comment">// Most effects won't need to do this, but this is very useful</span></span><br><span class="line"><span class="comment">// if you have an effect that consists of multiple sub-effects</span></span><br><span class="line"><span class="comment">// (for instance, two passes). The effect is given to its own</span></span><br><span class="line"><span class="comment">// pointer, and it can add new ones (by using add_node()</span></span><br><span class="line"><span class="comment">// and connect_node()) as it sees fit. This is called at</span></span><br><span class="line"><span class="comment">// EffectChain::finalize() time, when the entire graph is known,</span></span><br><span class="line"><span class="comment">// in the order that the effects were originally added.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Note that if the effect wants to take itself entirely out</span></span><br><span class="line"><span class="comment">// of the chain, it must set “disabled” to true and then disconnect</span></span><br><span class="line"><span class="comment">// itself from all other effects.</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">rewrite_graph</span><span class="params">(EffectChain *graph, Node *self)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns the GLSL fragment shader string for this effect.</span></span><br><span class="line"><span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">output_fragment_shader</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set all OpenGL state that this effect needs before rendering.</span></span><br><span class="line"><span class="comment">// The default implementation sets one uniform per registered parameter,</span></span><br><span class="line"><span class="comment">// but no other state.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// &lt;sampler_num&gt; is the first free texture sampler. If you want to use</span></span><br><span class="line"><span class="comment">// textures, you can bind a texture to GL_TEXTURE0 + &lt;sampler_num&gt;,</span></span><br><span class="line"><span class="comment">// and then increment the number (so that the next effect in the chain</span></span><br><span class="line"><span class="comment">// will use a different sampler).</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">set_gl_state</span><span class="params">(GLuint glsl_program_num, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; prefix, <span class="keyword">unsigned</span> *sampler_num)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If you set any special OpenGL state in set_gl_state(), you can clear it</span></span><br><span class="line"><span class="comment">// after rendering here. The default implementation does nothing.</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">clear_gl_state</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set a parameter; intended to be called from user code.</span></span><br><span class="line"><span class="comment">// Neither of these take ownership of the pointer.</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">set_int</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;key, <span class="keyword">int</span> value)</span> MUST_CHECK_RESULT</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">set_ivec2</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;key, <span class="keyword">const</span> <span class="keyword">int</span> *values)</span> MUST_CHECK_RESULT</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">set_float</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;key, <span class="keyword">float</span> value)</span> MUST_CHECK_RESULT</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">set_vec2</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;key, <span class="keyword">const</span> <span class="keyword">float</span> *values)</span> MUST_CHECK_RESULT</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">set_vec3</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;key, <span class="keyword">const</span> <span class="keyword">float</span> *values)</span> MUST_CHECK_RESULT</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">set_vec4</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;key, <span class="keyword">const</span> <span class="keyword">float</span> *values)</span> MUST_CHECK_RESULT</span>;</span><br></pre></td></tr></table></figure><p>rewrite_graph可以重写有向图，num_inputs返回输入节点个数，默认为1，set_gl_state是渲软前设置状态，可以动态设置参数。set_int等就是设置具体类型参数了。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>Input继承了Effect，num_inputs设置为0，get_color_space返回色彩空间，get_gamma_curve返回伽马曲线，用于色彩校正。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Input</span> :</span> <span class="keyword">public</span> Effect &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">num_inputs</span><span class="params">()</span> <span class="keyword">const</span> override </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Whether this input can deliver linear gamma directly if it's</span></span><br><span class="line"><span class="comment">// asked to. (If so, set the parameter “output_linear_gamma”</span></span><br><span class="line"><span class="comment">// to activate it.)</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">can_output_linear_gamma</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Whether this input can supply mipmaps if asked to (by setting</span></span><br><span class="line"><span class="comment">// the "needs_mipmaps" integer parameter set to 1).</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">can_supply_mipmaps</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">unsigned</span> <span class="title">get_width</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">unsigned</span> <span class="title">get_height</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Colorspace <span class="title">get_color_space</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> GammaCurve <span class="title">get_gamma_curve</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="image-format"><a href="#image-format" class="headerlink" title="image_format"></a>image_format</h3><p>image_format定义了一些结构体，色彩显示相关的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> MovitPixelFormat &#123;</span><br><span class="line">FORMAT_RGB,</span><br><span class="line">FORMAT_RGBA_PREMULTIPLIED_ALPHA,</span><br><span class="line">FORMAT_RGBA_POSTMULTIPLIED_ALPHA,</span><br><span class="line">FORMAT_BGR,</span><br><span class="line">FORMAT_BGRA_PREMULTIPLIED_ALPHA,</span><br><span class="line">FORMAT_BGRA_POSTMULTIPLIED_ALPHA,</span><br><span class="line">FORMAT_GRAYSCALE,</span><br><span class="line">FORMAT_RG,</span><br><span class="line">FORMAT_R</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> Colorspace &#123;</span><br><span class="line">COLORSPACE_INVALID = <span class="number">-1</span>,  <span class="comment">// For internal use.</span></span><br><span class="line">COLORSPACE_sRGB = <span class="number">0</span>,</span><br><span class="line">COLORSPACE_REC_709 = <span class="number">0</span>,  <span class="comment">// Same as sRGB.</span></span><br><span class="line">COLORSPACE_REC_601_525 = <span class="number">1</span>,</span><br><span class="line">COLORSPACE_REC_601_625 = <span class="number">2</span>,</span><br><span class="line">COLORSPACE_XYZ = <span class="number">3</span>,  <span class="comment">// Mostly useful for testing and debugging.</span></span><br><span class="line">COLORSPACE_REC_2020 = <span class="number">4</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> GammaCurve &#123;</span><br><span class="line">GAMMA_INVALID = <span class="number">-1</span>,  <span class="comment">// For internal use.</span></span><br><span class="line">GAMMA_LINEAR = <span class="number">0</span>,</span><br><span class="line">GAMMA_sRGB = <span class="number">1</span>,</span><br><span class="line">GAMMA_REC_601 = <span class="number">2</span>,</span><br><span class="line">GAMMA_REC_709 = <span class="number">2</span>,  <span class="comment">// Same as Rec. 601.</span></span><br><span class="line">GAMMA_REC_2020_10_BIT = <span class="number">2</span>,  <span class="comment">// Same as Rec. 601.</span></span><br><span class="line">GAMMA_REC_2020_12_BIT = <span class="number">3</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> YCbCrLumaCoefficients &#123;</span><br><span class="line">YCBCR_REC_601 = <span class="number">0</span>,</span><br><span class="line">YCBCR_REC_709 = <span class="number">1</span>,</span><br><span class="line">YCBCR_REC_2020 = <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ImageFormat</span> &#123;</span></span><br><span class="line">Colorspace color_space;</span><br><span class="line">GammaCurve gamma_curve;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>MovitPixelFormat是像素顺序结构，Colorspace是色彩空间，GammaCurve是伽马值，GAMMA_sRGB为1不校正。YCbCrLumaCoefficients是yuv亮度系数。</p><h3 id="utils"><a href="#utils" class="headerlink" title="utils"></a>utils</h3><p>包含一些工具方法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">read_file</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;filename)</span></span>;</span><br><span class="line"><span class="function">GLuint <span class="title">compile_shader</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;shader_src, GLenum type)</span></span>;</span><br><span class="line"><span class="comment">// Output a GLSL 3x3 matrix declaration.</span></span><br><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">output_glsl_mat3</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name, <span class="keyword">const</span> Eigen::Matrix3d &amp;m)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output GLSL scalar, 2-length and 3-length vector declarations.</span></span><br><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">output_glsl_float</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name, <span class="keyword">float</span> x)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">output_glsl_vec2</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name, <span class="keyword">float</span> x, <span class="keyword">float</span> y)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">output_glsl_vec3</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name, <span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">float</span> z)</span></span>;</span><br></pre></td></tr></table></figure><p>包括文件读取和gl操作的一些工具类。compile_shader编译shader，参数分别是shader的string和shader类型。<br>output_glsl_float等几个方法根据参数自动生成对应的glsl代码，实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">output_glsl_float</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;name, <span class="keyword">float</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// Use stringstream to be independent of the current locale in a thread-safe manner.</span></span><br><span class="line"><span class="built_in">stringstream</span> ss;</span><br><span class="line">ss.imbue(locale(<span class="string">"C"</span>));</span><br><span class="line">ss.precision(<span class="number">8</span>);</span><br><span class="line">ss &lt;&lt; scientific;</span><br><span class="line">ss &lt;&lt; <span class="string">"const float "</span> &lt;&lt; name &lt;&lt; <span class="string">" = "</span> &lt;&lt; x &lt;&lt; <span class="string">";\n"</span>;</span><br><span class="line"><span class="keyword">return</span> ss.str();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ResourcePool"><a href="#ResourcePool" class="headerlink" title="ResourcePool"></a>ResourcePool</h3><p>在多个EffectChains之间共享资源的类，如果有资源在多个EffectChain都要使用，每次获取释放会非常消耗资源，所以可以用ResourcePool，但是所有的EffectChains必须使用共享的OpenGLContext。</p><p>看公共方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResourcePool</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">ResourcePool(<span class="keyword">size_t</span> program_freelist_max_length = <span class="number">100</span>,</span><br><span class="line">             <span class="keyword">size_t</span> texture_freelist_max_bytes = <span class="number">100</span> &lt;&lt; <span class="number">20</span>,  <span class="comment">// 100 MB.</span></span><br><span class="line">             <span class="keyword">size_t</span> fbo_freelist_max_length = <span class="number">100</span>,  <span class="comment">// Per context.</span></span><br><span class="line">             <span class="keyword">size_t</span> vao_freelist_max_length = <span class="number">100</span>);  <span class="comment">// Per context.</span></span><br><span class="line">~ResourcePool();</span><br><span class="line"></span><br><span class="line"><span class="function">GLuint <span class="title">compile_glsl_program</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; vertex_shader,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; fragment_shader,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&amp; frag_shader_outputs)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">release_glsl_program</span><span class="params">(GLuint glsl_program_num)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">GLuint <span class="title">compile_glsl_compute_program</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; compile_shader)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">release_glsl_compute_program</span><span class="params">(GLuint glsl_program_num)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">GLuint <span class="title">use_glsl_program</span><span class="params">(GLuint glsl_program_num)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unuse_glsl_program</span><span class="params">(GLuint instance_program_num)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">GLuint <span class="title">create_2d_texture</span><span class="params">(GLint internal_format, GLsizei width, GLsizei height)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">release_2d_texture</span><span class="params">(GLuint texture_num)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">GLuint <span class="title">create_fbo</span><span class="params">(GLuint texture0_num,</span></span></span><br><span class="line"><span class="function"><span class="params">                  GLuint texture1_num = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                  GLuint texture2_num = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                  GLuint texture3_num = <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">release_fbo</span><span class="params">(GLuint fbo_num)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">GLuint <span class="title">create_vec2_vao</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">set</span>&lt;GLint&gt; &amp;attribute_indices,</span></span></span><br><span class="line"><span class="function"><span class="params">                       GLuint vbo_num)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">release_vec2_vao</span><span class="params">(<span class="keyword">const</span> GLuint vao_num)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clean_context</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>可以缓存glsl程序，纹理，FBO，VAO。</p><h3 id="YCbCrInput"><a href="#YCbCrInput" class="headerlink" title="YCbCrInput"></a>YCbCrInput</h3><p>yuv输入类。一个重点是格式设置，一个重点是看片段着色器</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> YCbCrInput::output_fragment_shader()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">string</span> frag_shader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ycbcr_input_splitting == YCBCR_INPUT_INTERLEAVED) &#123;</span><br><span class="line">frag_shader += <span class="string">"#define Y_CB_CR_SAME_TEXTURE 1\n"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ycbcr_input_splitting == YCBCR_INPUT_SPLIT_Y_AND_CBCR) &#123;</span><br><span class="line">cb_cr_offsets_equal =</span><br><span class="line">(<span class="built_in">fabs</span>(ycbcr_format.cb_x_position - ycbcr_format.cr_x_position) &lt; <span class="number">1e-6</span>) &amp;&amp;</span><br><span class="line">(<span class="built_in">fabs</span>(ycbcr_format.cb_y_position - ycbcr_format.cr_y_position) &lt; <span class="number">1e-6</span>);</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">256</span>];</span><br><span class="line"><span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span>(buf), <span class="string">"#define Y_CB_CR_SAME_TEXTURE 0\n#define CB_CR_SAME_TEXTURE 1\n#define CB_CR_OFFSETS_EQUAL %d\n"</span>,</span><br><span class="line">cb_cr_offsets_equal);</span><br><span class="line">frag_shader += buf;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">frag_shader += <span class="string">"#define Y_CB_CR_SAME_TEXTURE 0\n#define CB_CR_SAME_TEXTURE 0\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">frag_shader += read_file(<span class="string">"ycbcr_input.frag"</span>);</span><br><span class="line">frag_shader += <span class="string">"#undef CB_CR_SAME_TEXTURE\n#undef Y_CB_CR_SAME_TEXTURE\n"</span>;</span><br><span class="line"><span class="keyword">return</span> frag_shader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>里面读取了ycbcr_input.frag,看对应源码：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec4</span> FUNCNAME(<span class="type">vec2</span> tc) &#123;</span><br><span class="line"><span class="comment">// OpenGL's origin is bottom-left, but most graphics software assumes</span></span><br><span class="line"><span class="comment">// a top-left origin. Thus, for inputs that come from the user,</span></span><br><span class="line"><span class="comment">// we flip the y coordinate.</span></span><br><span class="line">tc.y = <span class="number">1.0</span> - tc.y;</span><br><span class="line"></span><br><span class="line"><span class="type">vec3</span> ycbcr;</span><br><span class="line"><span class="meta">#if Y_CB_CR_SAME_TEXTURE</span></span><br><span class="line">ycbcr = tex2D(PREFIX(tex_y), tc).xyz;</span><br><span class="line"><span class="meta">#else</span></span><br><span class="line">ycbcr.x = tex2D(PREFIX(tex_y), tc).x;</span><br><span class="line">  <span class="meta">#if CB_CR_SAME_TEXTURE</span></span><br><span class="line">    <span class="meta">#if CB_CR_OFFSETS_EQUAL</span></span><br><span class="line">ycbcr.yz = tex2D(PREFIX(tex_cbcr), tc + PREFIX(cb_offset)).xy;</span><br><span class="line">    <span class="meta">#else</span></span><br><span class="line">ycbcr.y = tex2D(PREFIX(tex_cbcr), tc + PREFIX(cb_offset)).x;</span><br><span class="line">ycbcr.z = tex2D(PREFIX(tex_cbcr), tc + PREFIX(cr_offset)).x;</span><br><span class="line">    <span class="meta">#endif</span></span><br><span class="line">  <span class="meta">#else</span></span><br><span class="line">ycbcr.y = tex2D(PREFIX(tex_cb), tc + PREFIX(cb_offset)).x;</span><br><span class="line">ycbcr.z = tex2D(PREFIX(tex_cr), tc + PREFIX(cr_offset)).x;</span><br><span class="line">  <span class="meta">#endif</span></span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line">ycbcr -= PREFIX(<span class="keyword">offset</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">vec4</span> rgba;</span><br><span class="line">rgba.rgb = PREFIX(inv_ycbcr_matrix) * ycbcr;</span><br><span class="line">rgba.a = <span class="number">1.0</span>;</span><br><span class="line"><span class="keyword">return</span> rgba;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有两个纹理输入，PREFIX(tex_y)和(PREFIX(tex_cbcr)，PREFIX是预处理标记，因为会对应多个Effect，shader代码会处理一遍防止重名等问题。<br>有y和ub的纹理就可以通过偏移量获取到yuv数据，然后通过转换矩阵转成rgb数据。</p><h3 id="EffectChain"><a href="#EffectChain" class="headerlink" title="EffectChain"></a>EffectChain</h3><p>最后介绍最重要的EffectChain，效果链，实际结构是有向图，节点Node定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Effect *effect;</span><br><span class="line"><span class="keyword">bool</span> disabled;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Edges in the graph (forward and backward).</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Node *&gt; outgoing_links;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Node *&gt; incoming_links;</span><br><span class="line"></span><br><span class="line"><span class="comment">// For unit tests only. Do not use from other code.</span></span><br><span class="line"><span class="comment">// Will contain an arbitrary choice if the node is in multiple phases.</span></span><br><span class="line">Phase *containing_phase;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Node是双向链表结构，而且输入和输出节点都可以是多个。</p><p>多个Node可以组成Phase，包含一个单独的glsl程序。所有的节点组成EffectChain，有时有些glsl程序输入发生了变化，不得不用多个glsl程序，就需要用到phase.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Phase</span> &#123;</span></span><br><span class="line">Node *output_node;</span><br><span class="line"></span><br><span class="line">GLuint glsl_program_num;  <span class="comment">// Owned by the resource_pool.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Position and texcoord attribute indexes, although it doesn't matter</span></span><br><span class="line"><span class="comment">// which is which, because they contain the same data.</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;GLint&gt; attribute_indexes;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Inputs are only inputs from other phases (ie., those that come from RTT);</span></span><br><span class="line"><span class="comment">// input textures are counted as part of &lt;effects&gt;.</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Phase *&gt; inputs;</span><br><span class="line"><span class="comment">// Bound sampler numbers for each input. Redundant in a sense</span></span><br><span class="line"><span class="comment">// (it always corresponds to the index), but we need somewhere</span></span><br><span class="line"><span class="comment">// to hold the value for the uniform.</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; input_samplers;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Node *&gt; effects;  <span class="comment">// In order.</span></span><br><span class="line"><span class="keyword">unsigned</span> output_width, output_height, virtual_output_width, virtual_output_height;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Whether this phase is compiled as a compute shader, ie., the last effect is</span></span><br><span class="line"><span class="comment">// marked as one.</span></span><br><span class="line"><span class="keyword">bool</span> is_compute_shader;</span><br><span class="line">Node *compute_shader_node;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If &lt;is_compute_shader&gt;, which image unit the output buffer is bound to.</span></span><br><span class="line"><span class="comment">// This is used as source for a Uniform&lt;int&gt; below.</span></span><br><span class="line"><span class="keyword">int</span> outbuf_image_unit;</span><br><span class="line"></span><br><span class="line"><span class="comment">// These are used in transforming from unnormalized to normalized coordinates</span></span><br><span class="line"><span class="comment">// in compute shaders.</span></span><br><span class="line"><span class="keyword">int</span> uniform_output_size[<span class="number">2</span>];</span><br><span class="line">Point2D inv_output_size, output_texcoord_adjust;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Identifier used to create unique variables in GLSL.</span></span><br><span class="line"><span class="comment">// Unique per-phase to increase cacheability of compiled shaders.</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::pair&lt;Node *, NodeLinkType&gt;, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; effect_ids;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Uniforms for this phase; combined from all the effects.</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Uniform&lt;<span class="keyword">int</span>&gt;&gt; uniforms_image2d;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Uniform&lt;<span class="keyword">int</span>&gt;&gt; uniforms_sampler2d;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Uniform&lt;<span class="keyword">bool</span>&gt;&gt; uniforms_bool;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Uniform&lt;<span class="keyword">int</span>&gt;&gt; uniforms_int;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Uniform&lt;<span class="keyword">int</span>&gt;&gt; uniforms_ivec2;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Uniform&lt;<span class="keyword">float</span>&gt;&gt; uniforms_float;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Uniform&lt;<span class="keyword">float</span>&gt;&gt; uniforms_vec2;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Uniform&lt;<span class="keyword">float</span>&gt;&gt; uniforms_vec3;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Uniform&lt;<span class="keyword">float</span>&gt;&gt; uniforms_vec4;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Uniform&lt;Eigen::Matrix3d&gt;&gt; uniforms_mat3;</span><br><span class="line"></span><br><span class="line"><span class="comment">// For measurement of GPU time used.</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;GLuint&gt; timer_query_objects_running;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;GLuint&gt; timer_query_objects_free;</span><br><span class="line"><span class="keyword">uint64_t</span> time_elapsed_ns;</span><br><span class="line"><span class="keyword">uint64_t</span> num_measured_iterations;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>包含glsl程序需要的要素，按顺序的Effect节点，输入必须也是Phase，输出是Node。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EffectChain</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">EffectChain(<span class="keyword">float</span> aspect_nom, <span class="keyword">float</span> aspect_denom, ResourcePool *resource_pool = <span class="literal">nullptr</span>);</span><br><span class="line">~EffectChain();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Input *<span class="title">add_input</span><span class="params">(Input *input)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Effect *<span class="title">add_effect</span><span class="params">(Effect *effect)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> add_effect(effect, last_added_effect());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Effect *<span class="title">add_effect</span><span class="params">(Effect *effect, Effect *input)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Effect *&gt; inputs;</span><br><span class="line">inputs.push_back(input);</span><br><span class="line"><span class="keyword">return</span> add_effect(effect, inputs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Effect *<span class="title">add_effect</span><span class="params">(Effect *effect, Effect *input1, Effect *input2)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Effect *&gt; inputs;</span><br><span class="line">inputs.push_back(input1);</span><br><span class="line">inputs.push_back(input2);</span><br><span class="line"><span class="keyword">return</span> add_effect(effect, inputs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Effect *<span class="title">add_effect</span><span class="params">(Effect *effect, Effect *input1, Effect *input2, Effect *input3)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Effect *&gt; inputs;</span><br><span class="line">inputs.push_back(input1);</span><br><span class="line">inputs.push_back(input2);</span><br><span class="line">inputs.push_back(input3);</span><br><span class="line"><span class="keyword">return</span> add_effect(effect, inputs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Effect *<span class="title">add_effect</span><span class="params">(Effect *effect, Effect *input1, Effect *input2, Effect *input3, Effect *input4)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Effect *&gt; inputs;</span><br><span class="line">inputs.push_back(input1);</span><br><span class="line">inputs.push_back(input2);</span><br><span class="line">inputs.push_back(input3);</span><br><span class="line">inputs.push_back(input4);</span><br><span class="line"><span class="keyword">return</span> add_effect(effect, inputs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Effect *<span class="title">add_effect</span><span class="params">(Effect *effect, Effect *input1, Effect *input2, Effect *input3, Effect *input4, Effect *input5)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Effect *&gt; inputs;</span><br><span class="line">inputs.push_back(input1);</span><br><span class="line">inputs.push_back(input2);</span><br><span class="line">inputs.push_back(input3);</span><br><span class="line">inputs.push_back(input4);</span><br><span class="line">inputs.push_back(input5);</span><br><span class="line"><span class="keyword">return</span> add_effect(effect, inputs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Effect *<span class="title">add_effect</span><span class="params">(Effect *effect, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Effect *&gt; &amp;inputs)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_output</span><span class="params">(<span class="keyword">const</span> ImageFormat &amp;format, OutputAlphaFormat alpha_format)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_ycbcr_output</span><span class="params">(<span class="keyword">const</span> ImageFormat &amp;format, OutputAlphaFormat alpha_format,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">const</span> YCbCrFormat &amp;ycbcr_format,</span></span></span><br><span class="line"><span class="function"><span class="params">      YCbCrOutputSplitting output_splitting = YCBCR_OUTPUT_INTERLEAVED,</span></span></span><br><span class="line"><span class="function"><span class="params">                      GLenum output_type = GL_UNSIGNED_BYTE)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change_ycbcr_output_format</span><span class="params">(<span class="keyword">const</span> YCbCrFormat &amp;ycbcr_format)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_dither_bits</span><span class="params">(<span class="keyword">unsigned</span> num_bits)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;num_dither_bits = num_bits;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_output_origin</span><span class="params">(OutputOrigin output_origin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;output_origin = output_origin;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_intermediate_format</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">GLenum intermediate_format,</span></span></span><br><span class="line"><span class="function"><span class="params">FramebufferTransformation transformation = NO_FRAMEBUFFER_TRANSFORMATION)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;intermediate_format = intermediate_format;</span><br><span class="line"><span class="keyword">this</span>-&gt;intermediate_transformation = transformation;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enable_phase_timing</span><span class="params">(<span class="keyword">bool</span> enable)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset_phase_timing</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_phase_timing</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">render_to_screen</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">render_to_fbo(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">render_to_fbo</span><span class="params">(GLuint fbo, <span class="keyword">unsigned</span> width, <span class="keyword">unsigned</span> height)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DestinationTexture</span> &#123;</span></span><br><span class="line">GLuint texnum;</span><br><span class="line">GLenum format;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">render_to_texture</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;DestinationTexture&gt; &amp;destinations, <span class="keyword">unsigned</span> width, <span class="keyword">unsigned</span> height)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Effect *<span class="title">last_added_effect</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nodes.empty()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> nodes.back()-&gt;effect;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">add_node</span><span class="params">(Effect *effect)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">connect_nodes</span><span class="params">(Node *sender, Node *receiver)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replace_receiver</span><span class="params">(Node *old_receiver, Node *new_receiver)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replace_sender</span><span class="params">(Node *new_sender, Node *receiver)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_node_between</span><span class="params">(Node *sender, Node *middle, Node *receiver)</span></span>;</span><br><span class="line"><span class="function">Node *<span class="title">find_node_for_effect</span><span class="params">(Effect *effect)</span> </span>&#123; <span class="keyword">return</span> node_map[effect]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">GLenum <span class="title">get_input_sampler</span><span class="params">(Node *node, <span class="keyword">unsigned</span> input_num)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">GLenum <span class="title">has_input_sampler</span><span class="params">(Node *node, <span class="keyword">unsigned</span> input_num)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ResourcePool *<span class="title">get_resource_pool</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> resource_pool; &#125;</span><br></pre></td></tr></table></figure><p>add_effect添加特效方法，finalize是生成glsl程序的方法，render_to_screen和render_to_fbo是渲染的方法，connect_nodes可以把输入和输出节点连接起来。</p><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>fp16是16位和32为数据转换工具类，defs和version就是一些通用定义。</p><h2 id="处理流程"><a href="#处理流程" class="headerlink" title="处理流程"></a>处理流程</h2><h3 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a>finalize</h3><p>EffectChain.cpp中有两千多行代码，看重要流程代码，理解整体过程。生成EffectChain会进行添加节点，包括节点之间的连接关系，完成后就调用finalize组装，对应代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> EffectChain::finalize()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; nodes.size(); ++i) &#123;</span><br><span class="line">nodes[i]-&gt;effect-&gt;rewrite_graph(<span class="keyword">this</span>, nodes[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">find_color_spaces_for_inputs();</span><br><span class="line"></span><br><span class="line">propagate_alpha();</span><br><span class="line"></span><br><span class="line">propagate_gamma_and_color_space();</span><br><span class="line"></span><br><span class="line">fix_internal_color_spaces();</span><br><span class="line">fix_internal_alpha(<span class="number">6</span>);</span><br><span class="line">fix_output_color_space();</span><br><span class="line">fix_output_alpha();</span><br><span class="line"></span><br><span class="line">fix_internal_gamma_by_asking_inputs(<span class="number">9</span>);</span><br><span class="line">fix_internal_gamma_by_inserting_nodes(<span class="number">10</span>);</span><br><span class="line">fix_output_gamma();</span><br><span class="line">propagate_alpha();</span><br><span class="line">fix_internal_alpha(<span class="number">13</span>);</span><br><span class="line">fix_internal_gamma_by_asking_inputs(<span class="number">15</span>);</span><br><span class="line">fix_internal_gamma_by_inserting_nodes(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">add_ycbcr_conversion_if_needed();</span><br><span class="line"></span><br><span class="line">add_dither_if_needed();</span><br><span class="line"></span><br><span class="line">add_dummy_effect_if_needed();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;Node *, Phase *&gt; completed_effects;</span><br><span class="line">construct_phase(find_output_node(), &amp;completed_effects);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (has_dummy_effect &amp;&amp; !phases[phases.size() - <span class="number">2</span>]-&gt;is_compute_shader) &#123;</span><br><span class="line">resource_pool-&gt;release_glsl_program(phases.back()-&gt;glsl_program_num);</span><br><span class="line"><span class="keyword">delete</span> phases.back();</span><br><span class="line">phases.pop_back();</span><br><span class="line">has_dummy_effect = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">assert(phases[<span class="number">0</span>]-&gt;inputs.empty());</span><br><span class="line"></span><br><span class="line">finalized = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先遍历每个节点，进行rewrite_graph，然后进行颜色空间等设置。关键步骤是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">construct_phase(find_output_node(), &amp;completed_effects)；</span><br></pre></td></tr></table></figure><p>生成了phase结构。第一个参数是find_output_node，查找输出节点：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Node *EffectChain::find_output_node()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;Node *&gt; output_nodes;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; nodes.size(); ++i) &#123;</span><br><span class="line">Node *node = nodes[i];</span><br><span class="line"><span class="keyword">if</span> (node-&gt;disabled) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (node-&gt;outgoing_links.empty()) &#123;</span><br><span class="line">output_nodes.push_back(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">assert(output_nodes.size() == <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> output_nodes[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有输出的节点的节点就是最终的输出节点，只能有一个输出节点。</p><p>第二个参数是map<node *, phase *>类型的地址，就是返回的数据。</node></p><h3 id="construct-phase"><a href="#construct-phase" class="headerlink" title="construct_phase"></a>construct_phase</h3><p>从给定的效果和随后的链开始构建glsl程序。当需要改变纹理bound时，就会结束一个程序，还有需要多个效果，输出大小改变时也会结束程序。<br>在输出开始用一个简单的深度优先搜索，就不用在每个phase中明确的递归。</p><p>主要逻辑代码，省略部分非主线流程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Phase *EffectChain::construct_phase(Node *output, <span class="built_in">map</span>&lt;Node *, Phase *&gt; *completed_effects)&#123;</span><br><span class="line">Phase *phase = <span class="keyword">new</span> Phase;</span><br><span class="line">phase-&gt;output_node = output;</span><br><span class="line">phase-&gt;is_compute_shader = <span class="literal">false</span>;</span><br><span class="line">phase-&gt;compute_shader_node = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">stack</span>&lt;Node *&gt; effects_todo_this_phase;</span><br><span class="line">effects_todo_this_phase.push(output);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!effects_todo_this_phase.empty()) &#123;</span><br><span class="line">Node *node = effects_todo_this_phase.top();</span><br><span class="line">effects_todo_this_phase.pop();</span><br><span class="line"></span><br><span class="line">phase-&gt;effects.push_back(node);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Find all the dependencies of this effect, and add them to the stack.</span></span><br><span class="line">assert(node-&gt;effect-&gt;num_inputs() == node-&gt;incoming_links.size());</span><br><span class="line"><span class="keyword">for</span> (Node *dep : node-&gt;incoming_links) &#123;</span><br><span class="line"><span class="keyword">bool</span> start_new_phase = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(多种情况...)&#123;</span><br><span class="line">start_new_phase = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line"><span class="keyword">if</span> (start_new_phase) &#123;</span><br><span class="line"><span class="comment">// Since we're starting a new phase here, we don't need to impose any</span></span><br><span class="line"><span class="comment">// new demands on this effect. Restore the status we had before we</span></span><br><span class="line"><span class="comment">// started looking at it.</span></span><br><span class="line">dep-&gt;needs_mipmaps = save_needs_mipmaps;</span><br><span class="line"></span><br><span class="line">phase-&gt;inputs.push_back(construct_phase(dep, completed_effects));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">effects_todo_this_phase.push(dep);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Propagate the one-to-one status down through the dependency.</span></span><br><span class="line">dep-&gt;one_to_one_sampling = node-&gt;one_to_one_sampling &amp;&amp;</span><br><span class="line">dep-&gt;effect-&gt;one_to_one_sampling();</span><br><span class="line">dep-&gt;strong_one_to_one_sampling = node-&gt;strong_one_to_one_sampling &amp;&amp;</span><br><span class="line">dep-&gt;effect-&gt;strong_one_to_one_sampling();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">node-&gt;incoming_link_type.push_back(start_new_phase ? IN_ANOTHER_PHASE : IN_SAME_PHASE);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">compile_glsl_program(phase);</span><br><span class="line"></span><br><span class="line">phases.push_back(phase);</span><br><span class="line">    <span class="keyword">return</span> phase;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从输出开始为phase添加节点，判断情况进行中断，如果需要添加新phase，则为新phase递归执行construct_phase方法，否则在当前处理node中添加节点，继续while循环。</p><h3 id="compile-glsl-program"><a href="#compile-glsl-program" class="headerlink" title="compile_glsl_program"></a>compile_glsl_program</h3><p>下一步是为每一个phase编译glsl程序。代码量也多，都是细致的操作代码，原理就是利用c的宏定义进行动态组合成一个glsl程序，相对多个程序需要内存拷贝，这样性能大大提高。解析下关键代码。</p><p>为每一个Node添加专属id：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Give each effect in the phase its own ID.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; phase-&gt;effects.size(); ++i) &#123;</span><br><span class="line">Node *node = phase-&gt;effects[i];</span><br><span class="line"><span class="keyword">char</span> effect_id[<span class="number">256</span>];</span><br><span class="line"><span class="built_in">sprintf</span>(effect_id, <span class="string">"eff%u"</span>, i);</span><br><span class="line"><span class="keyword">bool</span> inserted = phase-&gt;effect_ids.insert(make_pair(make_pair(node, IN_SAME_PHASE), effect_id)).second;</span><br><span class="line">assert(inserted);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为每个节点添加一个方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; phase-&gt;effects.size(); ++i) &#123;</span><br><span class="line">Node *node = phase-&gt;effects[i];</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> effect_id = phase-&gt;effect_ids[make_pair(node, IN_SAME_PHASE)];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> j = <span class="number">0</span>; j &lt; node-&gt;incoming_links.size(); ++j) &#123;</span><br><span class="line"><span class="keyword">if</span> (node-&gt;incoming_links.size() == <span class="number">1</span>) &#123;</span><br><span class="line">frag_shader += <span class="string">"#define INPUT"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">256</span>];</span><br><span class="line"><span class="built_in">sprintf</span>(buf, <span class="string">"#define INPUT%d"</span>, j + <span class="number">1</span>);</span><br><span class="line">frag_shader += buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node *input = node-&gt;incoming_links[j];</span><br><span class="line">NodeLinkType link_type = node-&gt;incoming_link_type[j];</span><br><span class="line"><span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp;</span><br><span class="line">    input-&gt;effect-&gt;is_compute_shader() &amp;&amp;</span><br><span class="line">    node-&gt;incoming_link_type[j] == IN_SAME_PHASE) &#123;</span><br><span class="line"><span class="comment">// First effect after the compute shader reads the value</span></span><br><span class="line"><span class="comment">// that cs_output() wrote to a global variable,</span></span><br><span class="line"><span class="comment">// ignoring the tc (since all such effects have to be</span></span><br><span class="line"><span class="comment">// strong one-to-one).</span></span><br><span class="line">frag_shader += <span class="string">"(tc) CS_OUTPUT_VAL\n"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">assert(phase-&gt;effect_ids.count(make_pair(input, link_type)));</span><br><span class="line">frag_shader += <span class="built_in">string</span>(<span class="string">" "</span>) + phase-&gt;effect_ids[make_pair(input, link_type)] + <span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">frag_shader += <span class="string">"\n"</span>;</span><br><span class="line">frag_shader += <span class="built_in">string</span>(<span class="string">"#define FUNCNAME "</span>) + effect_id + <span class="string">"\n"</span>;</span><br><span class="line"><span class="keyword">if</span> (node-&gt;effect-&gt;is_compute_shader()) &#123;</span><br><span class="line">frag_shader += <span class="built_in">string</span>(<span class="string">"#define NORMALIZE_TEXTURE_COORDS(tc) ((tc) * "</span>) + effect_id + <span class="string">"_inv_output_size + "</span> + effect_id + <span class="string">"_output_texcoord_adjust)\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line">frag_shader += replace_prefix(node-&gt;effect-&gt;output_fragment_shader(), effect_id);</span><br><span class="line">frag_shader += <span class="string">"#undef FUNCNAME\n"</span>;</span><br><span class="line"><span class="keyword">if</span> (node-&gt;incoming_links.size() == <span class="number">1</span>) &#123;</span><br><span class="line">frag_shader += <span class="string">"#undef INPUT\n"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> j = <span class="number">0</span>; j &lt; node-&gt;incoming_links.size(); ++j) &#123;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">256</span>];</span><br><span class="line"><span class="built_in">sprintf</span>(buf, <span class="string">"#undef INPUT%d\n"</span>, j + <span class="number">1</span>);</span><br><span class="line">frag_shader += buf;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">frag_shader += <span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后面还有参数设置方法，组装后片段着色器代码后会编译glsl程序，然后获取参数位置，留待使用，不一一介绍了。</p><p>组合成的glsl片段着色器实例：<br><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">precision</span> <span class="keyword">highp</span> <span class="type">float</span>;</span><br><span class="line"><span class="keyword">varying</span> <span class="type">vec2</span> tc;</span><br><span class="line"></span><br><span class="line"><span class="meta">#define FUNCNAME eff0</span></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> eff0_tex;</span><br><span class="line"><span class="type">vec4</span> FUNCNAME(<span class="type">vec2</span> tc) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">texture2D</span>(eff0_tex, <span class="type">vec2</span>(tc.x,<span class="number">1.0</span>-tc.y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#undef PREFIX</span></span><br><span class="line"><span class="meta">#undef FUNCNAME</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#define INPUT eff0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#define FUNCNAME eff1</span></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> eff1_strength;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> eff1_lut;</span><br><span class="line"><span class="type">vec4</span> FUNCNAME(<span class="type">vec2</span> tc) &#123; <span class="type">float</span> strength = eff1_strength; <span class="keyword">lowp</span> <span class="type">vec4</span> textureColor = INPUT(tc); <span class="keyword">mediump</span> <span class="type">float</span> blueColor = textureColor.b * <span class="number">63.0</span>; <span class="keyword">mediump</span> <span class="type">vec2</span> quad1; quad1.y = <span class="built_in">floor</span>(<span class="built_in">floor</span>(blueColor) / <span class="number">8.0</span>); quad1.x = <span class="built_in">floor</span>(blueColor) - (quad1.y * <span class="number">8.0</span>); <span class="keyword">mediump</span> <span class="type">vec2</span> quad2; quad2.y = <span class="built_in">floor</span>(<span class="built_in">ceil</span>(blueColor) / <span class="number">8.0</span>); quad2.x = <span class="built_in">ceil</span>(blueColor) - (quad2.y * <span class="number">8.0</span>); <span class="keyword">highp</span> <span class="type">vec2</span> texPos1; texPos1.x = (quad1.x * <span class="number">0.125</span>) + <span class="number">0.5</span>/<span class="number">512.0</span> + ((<span class="number">0.125</span> - <span class="number">1.0</span>/<span class="number">512.0</span>) * textureColor.r); texPos1.y = (quad1.y * <span class="number">0.125</span>) + <span class="number">0.5</span>/<span class="number">512.0</span> + ((<span class="number">0.125</span> - <span class="number">1.0</span>/<span class="number">512.0</span>) * textureColor.g); <span class="keyword">highp</span> <span class="type">vec2</span> texPos2; texPos2.x = (quad2.x * <span class="number">0.125</span>) + <span class="number">0.5</span>/<span class="number">512.0</span> + ((<span class="number">0.125</span> - <span class="number">1.0</span>/<span class="number">512.0</span>) * textureColor.r); texPos2.y = (quad2.y * <span class="number">0.125</span>) + <span class="number">0.5</span>/<span class="number">512.0</span> + ((<span class="number">0.125</span> - <span class="number">1.0</span>/<span class="number">512.0</span>) * textureColor.g); <span class="keyword">lowp</span> <span class="type">vec4</span> newColor1 = <span class="built_in">texture2D</span>(eff1_lut, texPos1); <span class="keyword">lowp</span> <span class="type">vec4</span> newColor2 = <span class="built_in">texture2D</span>(eff1_lut, texPos2); <span class="keyword">lowp</span> <span class="type">vec4</span> newColor = <span class="built_in">mix</span>(newColor1, newColor2, <span class="built_in">fract</span>(blueColor)); <span class="keyword">return</span> <span class="built_in">mix</span>(textureColor, <span class="type">vec4</span>(newColor.rgb, textureColor.w), strength); &#125; </span><br><span class="line"><span class="meta">#undef PREFIX</span></span><br><span class="line"><span class="meta">#undef FUNCNAME</span></span><br><span class="line"><span class="meta">#undef INPUT</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#define INPUT eff1</span></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_FragColor</span> = INPUT(tc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="render"><a href="#render" class="headerlink" title="render"></a>render</h3><p>opengl渲软流程都一样，但这里都多个phase，前面的phase需要先绘制在纹理上，最后一个phase绘制在目标fbo上，纹理采用resource_pool获取创建的纹理，可以缓存复用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (last_phase) &#123;</span><br><span class="line">    <span class="comment">// Last phase goes to the output the user specified.</span></span><br><span class="line">    <span class="keyword">if</span> (!phase-&gt;is_compute_shader) &#123;</span><br><span class="line">        assert(dest_fbo != (GLuint)<span class="number">-1</span>);</span><br><span class="line">        glBindFramebuffer(GL_FRAMEBUFFER, dest_fbo);</span><br><span class="line">        check_error();</span><br><span class="line">        GLenum status = glCheckFramebufferStatusEXT(GL_FRAMEBUFFER_EXT);</span><br><span class="line">        assert(status == GL_FRAMEBUFFER_COMPLETE);</span><br><span class="line">        glViewport(x, y, width, height);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dither_effect != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        CHECK(dither_effect-&gt;set_int(<span class="string">"output_width"</span>, width));</span><br><span class="line">        CHECK(dither_effect-&gt;set_int(<span class="string">"output_height"</span>, height));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!last_phase) &#123;</span><br><span class="line">    GLuint tex_num = resource_pool-&gt;create_2d_texture(intermediate_format, phase-&gt;output_width, phase-&gt;output_height);</span><br><span class="line">    output_textures.insert(make_pair(phase, tex_num));</span><br><span class="line">    phase_destinations.push_back(DestinationTexture&#123; tex_num, intermediate_format &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The output texture needs to have valid state to be written to by a compute shader.</span></span><br><span class="line">    glActiveTexture(GL_TEXTURE0);</span><br><span class="line">    check_error();</span><br><span class="line">    glBindTexture(GL_TEXTURE_2D, tex_num);</span><br><span class="line">    check_error();</span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line">    check_error();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (phase-&gt;is_compute_shader) &#123;</span><br><span class="line">    assert(!destinations.empty());</span><br><span class="line">    phase_destinations = destinations;</span><br><span class="line">&#125;</span><br><span class="line">execute_phase(phase, output_textures, phase_destinations, &amp;generated_mipmaps);</span><br></pre></td></tr></table></figure><p>execute_phase包含一些输入输出大小，参数，资源缓存等逻辑，最后调用真正的绘制代码glDrawArrays。</p>]]></content>
    
    <summary type="html">
    
      高性能的OpenGL特效框架的内部原理
    
    </summary>
    
    
      <category term="音视频" scheme="http://anddymao.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="C" scheme="http://anddymao.com/tags/C/"/>
    
      <category term="OpenGl" scheme="http://anddymao.com/tags/OpenGl/"/>
    
  </entry>
  
  <entry>
    <title>mlt框架介绍和结构分析</title>
    <link href="http://anddymao.com/2019/10/27/2019-10-27-mlt/"/>
    <id>http://anddymao.com/2019/10/27/2019-10-27-mlt/</id>
    <published>2019-10-27T04:00:00.000Z</published>
    <updated>2020-01-19T02:36:48.918Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础介绍"><a href="#基础介绍" class="headerlink" title="基础介绍"></a>基础介绍</h2><h3 id="基础信息"><a href="#基础信息" class="headerlink" title="基础信息"></a>基础信息</h3><p>官方介绍：The engine of a non-linear video editor that can be used in all sorts of apps,</p><p>视频编辑引擎。由C编写，它遵循基本的面向对象设计范式，主要采用的是生产者（producer）和消费者（consumer）模型，模块功能扩展可以有producer,consumer,filter,transition，animation。MLT的功能模块扩展可以使用FFmpeg，JACK，Movit，作为插件。</p><h3 id="结构和流"><a href="#结构和流" class="headerlink" title="结构和流"></a>结构和流</h3><p>MLT“网络”的一般结构只是一个<br>从“生产者”到“消费者”:</p><pre><code>+--------+   +--------+|Producer|--&gt;|Consumer|+--------+   +--------+</code></pre><p>一个典型的消费者向生产者请求MLT frame对象，执行一些操作，一帧的操作结束后，将其关闭。</p><p>生产者生产MLT Frame对象，而消费者消耗MLT框架对象。</p><p>过滤器也可以放在生产者和消费者之间：</p><pre><code>+--------+   +------+   +--------+|Producer|--&gt;|Filter|--&gt;|Consumer|+--------+   +------+   +--------+</code></pre><p>生产者，过滤器，转换器都是服务。</p><p>连接的消费者与生产者或服务之间的通信是分三个阶段进行：</p><p><em>获取帧数据</em>获取图像<br>*获取音频</p><p>消费者从它相连的服务去拉取数据，所以线程通常属于消费者，mlt_consumer提供一些基础功能确保实时吞吐。</p><h2 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h2><h3 id="hello-world实例"><a href="#hello-world实例" class="headerlink" title="hello world实例"></a>hello world实例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;framework/mlt.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[] )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Initialise the factory</span></span><br><span class="line">    <span class="keyword">if</span> ( mlt_factory_init( <span class="literal">NULL</span> ) == <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Create the default consumer</span></span><br><span class="line">        mlt_consumer hello = mlt_factory_consumer( <span class="literal">NULL</span>, <span class="literal">NULL</span> );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create via the default producer</span></span><br><span class="line">        mlt_producer world = mlt_factory_producer( <span class="literal">NULL</span>, argv[ <span class="number">1</span> ] );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Connect the producer to the consumer</span></span><br><span class="line">        mlt_consumer_connect( hello, mlt_producer_service( world ) );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Start the consumer</span></span><br><span class="line">        mlt_consumer_start( hello );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Wait for the consumer to terminate</span></span><br><span class="line">        <span class="keyword">while</span>( !mlt_consumer_is_stopped( hello ) )</span><br><span class="line">            sleep( <span class="number">1</span> );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Close the consumer</span></span><br><span class="line">        mlt_consumer_close( hello );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Close the producer</span></span><br><span class="line">        mlt_producer_close( world );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Close the factory</span></span><br><span class="line">        mlt_factory_close( );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Report an error during initialisation</span></span><br><span class="line">        <span class="built_in">fprintf</span>( <span class="built_in">stderr</span>, <span class="string">"Unable to locate factory modules\n"</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// End of program</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建生产者和消费者，然后连接，再启动消费者，最后关闭，就完成一次标准调用。<br>所有服务都通过工厂实例化，如<br>上面的mlt_factory_consumer和mlt_factory_producer调用。</p><h3 id="服务属性"><a href="#服务属性" class="headerlink" title="服务属性"></a>服务属性</h3><p>所有的服务都有属性,通过mlt_properties_set和mlt_properties_get获取对应的键值对。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mlt_properties properties = mlt_producer_properties( producer );</span><br><span class="line"></span><br><span class="line">mlt_properties_set( properties, <span class="string">"name"</span>, <span class="string">"value"</span> );</span><br><span class="line"></span><br><span class="line">data = mlt_properties_get( properties, <span class="string">"name"</span> );</span><br></pre></td></tr></table></figure><h3 id="播放列表"><a href="#播放列表" class="headerlink" title="播放列表"></a>播放列表</h3><p>可以创建一个播放列表mlt_playlist，然后通过mlt_factory_producer创建生产者添加到播放列表中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">mlt_producer <span class="title">create_playlist</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> **argv )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// We're creating a playlist here</span></span><br><span class="line">    mlt_playlist playlist = mlt_playlist_init( );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We need the playlist properties to ensure clean up</span></span><br><span class="line">    mlt_properties properties = mlt_playlist_properties( playlist );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Loop through each of the arguments</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">1</span>; i &lt; argc; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Create the producer</span></span><br><span class="line">        mlt_producer producer = mlt_factory_producer( <span class="literal">NULL</span>, argv[ i ] );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add it to the playlist</span></span><br><span class="line">        mlt_playlist_append( playlist, producer );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Close the producer (see below)</span></span><br><span class="line">        mlt_producer_close( producer );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return the playlist as a producer</span></span><br><span class="line">    <span class="keyword">return</span> mlt_playlist_producer( playlist );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><p>与生产者和消费者一样，可以通过过滤器来操作过滤器<br>properties对象-可以调用mlt_filter_properties方法，并且<br>属性可以根据需要设置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a producer from something</span></span><br><span class="line">mlt_producer producer = mlt_factory_producer( ... );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a consumer from something</span></span><br><span class="line">mlt_consumer consumer = mlt_factory_consumer( ... );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a greyscale filter</span></span><br><span class="line">mlt_filter filter = mlt_factory_filter( <span class="string">"greyscale"</span>, <span class="literal">NULL</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Connect the filter to the producer</span></span><br><span class="line">mlt_filter_connect( filter, mlt_producer_service( producer ), <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Connect the consumer to filter</span></span><br><span class="line">mlt_consumer_connect( consumer, mlt_filter_service( filter ) );</span><br></pre></td></tr></table></figure><h3 id="混合转场"><a href="#混合转场" class="headerlink" title="混合转场"></a>混合转场</h3><p>混合是在播放列表上的相邻段之间引入过渡的最简单方法。</p><p>mlt_playlist_mix( playlist, i, 50, transition );<br>会在第i段和i+1短间加上50帧的转场，每段的时间不变，所以总长度会减少50帧。</p><p>注意添上转场只能倒序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get the number of clips on the playlist</span></span><br><span class="line"><span class="keyword">int</span> i = mlt_playlist_count( );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Iterate through them in reverse order</span></span><br><span class="line"><span class="keyword">while</span> ( i -- )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Create a transition</span></span><br><span class="line">    mlt_transition transition = mlt_factory_transition( <span class="string">"luma"</span>, <span class="literal">NULL</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Mix the first and second clips for 50 </span></span><br><span class="line">    mlt_playlist_mix( playlist, i, <span class="number">50</span>, transition );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Close the transition</span></span><br><span class="line">    mlt_transition_close( transition );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实用性和优化"><a href="#实用性和优化" class="headerlink" title="实用性和优化"></a>实用性和优化</h3><p>当需要使用两个相同段融合转场时，为了实时渲软的效果，可以进行优化。<br>遍历整个播放列表，确定重叠实例的最大数量，然后创建克隆并将克隆索引分配给对应段。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Optimise the playlist</span></span><br><span class="line">mlt_producer_optimise( mlt_playlist_producer( playlist ) );</span><br></pre></td></tr></table></figure><h3 id="多轨道"><a href="#多轨道" class="headerlink" title="多轨道"></a>多轨道</h3><p>多轨道结构图：</p><p><img src="/img/mlt_1.png" alt="多轨道结构"></p><p>调用源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">mlt_producer <span class="title">create_tracks</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> **argv )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Create the tractor</span></span><br><span class="line">    mlt_tractor tractor = mlt_tractor_new( );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Obtain the field</span></span><br><span class="line">    mlt_field field = mlt_tractor_field( tractor );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Obtain the multitrack</span></span><br><span class="line">    mlt_multitrack multitrack = mlt_tractor_multitrack( tractor );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a composite transition</span></span><br><span class="line">    mlt_transition transition = mlt_factory_transition( <span class="string">"composite"</span>, <span class="string">"10%/10%:15%x15%"</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create track 0</span></span><br><span class="line">    mlt_producer track0 = create_playlist( argc, argv );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create the watermark track - note we NEED loader for scaling here</span></span><br><span class="line">    mlt_producer track1 = mlt_factory_producer( <span class="string">"loader"</span>, <span class="string">"pango"</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the length of track0</span></span><br><span class="line">    mlt_position length = mlt_producer_get_playtime( track0 );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the properties of track1</span></span><br><span class="line">    mlt_properties properties = mlt_producer_properties( track1 );</span><br><span class="line">    mlt_properties_set( properties, <span class="string">"text"</span>, <span class="string">"Hello\nWorld"</span> );</span><br><span class="line">    mlt_properties_set_position( properties, <span class="string">"in"</span>, <span class="number">0</span> );</span><br><span class="line">    mlt_properties_set_position( properties, <span class="string">"out"</span>, length - <span class="number">1</span> );</span><br><span class="line">    mlt_properties_set_position( properties, <span class="string">"length"</span>, length );</span><br><span class="line">    mlt_properties_set_int( properties, <span class="string">"a_track"</span>, <span class="number">0</span> );</span><br><span class="line">    mlt_properties_set_int( properties, <span class="string">"b_track"</span>, <span class="number">1</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now set the properties on the transition</span></span><br><span class="line">    properties = mlt_transition_properties( transition );</span><br><span class="line">    mlt_properties_set_position( properties, <span class="string">"in"</span>, <span class="number">0</span> );</span><br><span class="line">    mlt_properties_set_position( properties, <span class="string">"out"</span>, length - <span class="number">1</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add our tracks to the multitrack</span></span><br><span class="line">    mlt_multitrack_connect( multitrack, track0, <span class="number">0</span> );</span><br><span class="line">    mlt_multitrack_connect( multitrack, track1, <span class="number">1</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now plant the transition</span></span><br><span class="line">    mlt_field_plant_transition( field, transition, <span class="number">0</span>, <span class="number">1</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Close our references</span></span><br><span class="line">    mlt_producer_close( track0 );</span><br><span class="line">    mlt_producer_close( track1 );</span><br><span class="line">    mlt_transition_close( transition );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return the tractor</span></span><br><span class="line">    <span class="keyword">return</span> mlt_tractor_producer( tractor );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结构设计"><a href="#结构设计" class="headerlink" title="结构设计"></a>结构设计</h2><h3 id="类结构"><a href="#类结构" class="headerlink" title="类结构"></a>类结构</h3><p>mlt框架包含一个OO类层次结构，该层次结构包含以下内容</p><p>公共类和抽象：</p><pre><code>mlt_properties  mlt_frame  mlt_service    mlt_producer      mlt_playlist      mlt_tractor    mlt_filter    mlt_transition    mlt_consumermlt_dequemlt_poolmlt_factory</code></pre><p>可以将上面定义的每个类理解为将上面的类扩展到<br>左边。</p><h3 id="mlt-properties"><a href="#mlt-properties" class="headerlink" title="mlt_properties"></a>mlt_properties</h3><p>属性类是框架和服务类的基类。</p><p>它旨在为各种类型的计算机提供有效的查找表<br>信息，例如字符串，整数，浮点值和指针<br>数据和数据结构。</p><p>所有属性均由唯一的字符串索引。</p><p>除非属性对象关闭，否则分配的内存将保留，除非<br>您指定一个析构函数。在上述情况下，可以使用以下方法完成此操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mlt_properties_set_data（properties，“ image”，image，size，<span class="built_in">free</span>，<span class="literal">NULL</span>）;</span><br></pre></td></tr></table></figure><h3 id="mlt-deque"><a href="#mlt-deque" class="headerlink" title="mlt_deque"></a>mlt_deque</h3><p>堆栈和队列是MLT框架中的基本组件。 为了方便，选择实施“双端队列”（双端队列）- mlt_deque这封装了两者的功能。</p><h3 id="mlt-pool"><a href="#mlt-pool" class="headerlink" title="mlt_pool"></a>mlt_pool</h3><p>MLT框架通过mlt_pool提供内存池功能<br>API。一旦初始化，这些可以看作是直接替换malloc / realloc / free功能。</p><p>为了大内存分配的性能，内部有一个堆栈缓存，提升了性能。</p><p>API和传统的malloc/realloc/free 调用相同:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mlt_pool_alloc</span><span class="params">( <span class="keyword">int</span> size )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mlt_pool_realloc</span><span class="params">( <span class="keyword">void</span> *ptr, <span class="keyword">int</span> size )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mlt_pool_release</span><span class="params">( <span class="keyword">void</span> *release )</span></span>;</span><br></pre></td></tr></table></figure><h3 id="mlt-frame"><a href="#mlt-frame" class="headerlink" title="mlt_frame"></a>mlt_frame</h3><p>结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+------------+</span><br><span class="line">|frame       |</span><br><span class="line">+------------+</span><br><span class="line">| properties |</span><br><span class="line">| image stack|</span><br><span class="line">| audio stack|</span><br><span class="line">+------------+</span><br></pre></td></tr></table></figure><p>请求流程：</p><p><img src="/img/mlt_2.png" alt="请求流程"></p><h3 id="mlt-service"><a href="#mlt-service" class="headerlink" title="mlt_service"></a>mlt_service</h3><p>服务基类，包含扩展属性，允许多个输入和一个输出。 mlt_produce，mlt_filter，mlt_transition，mlt_consumer都继承mlt_service_s。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mlt_service_s</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mlt_properties_s</span> <span class="title">parent</span>;</span> <span class="comment">/**&lt; \private A service extends properties. */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Get a frame of data (virtual function).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \param mlt_producer a producer</span></span><br><span class="line"><span class="comment"> * \param mlt_frame_ptr a frame pointer by reference</span></span><br><span class="line"><span class="comment"> * \param int an index</span></span><br><span class="line"><span class="comment"> * \return true if there was an error</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> ( *get_frame )( mlt_service self, mlt_frame_ptr frame, <span class="keyword">int</span> index );</span><br><span class="line"></span><br><span class="line"><span class="comment">/** the destructor virtual function */</span></span><br><span class="line">mlt_destructor close;</span><br><span class="line"><span class="keyword">void</span> *close_object; <span class="comment">/**&lt; the object supplied to the close virtual function */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *local; <span class="comment">/**&lt; \private instance object */</span></span><br><span class="line"><span class="keyword">void</span> *child; <span class="comment">/**&lt; \private the object of a subclass */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>local是mlt_service_base类型，定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">int size;</span><br><span class="line">int count;</span><br><span class="line">mlt_service *in;</span><br><span class="line">mlt_service out;</span><br><span class="line">int filter_count;</span><br><span class="line">int filter_size;</span><br><span class="line">mlt_filter *filters;</span><br><span class="line">pthread_mutex_t mutex;</span><br><span class="line">&#125;</span><br><span class="line">mlt_service_base;</span><br></pre></td></tr></table></figure><h3 id="mlt-producer"><a href="#mlt-producer" class="headerlink" title="mlt_producer"></a>mlt_producer</h3><p>一个生产者拥有0个输入和1个输出。</p><p>生产者提供了文件读取，管道，流或者图片及音频输入。</p><p>生产者，过滤器，混合器，消费者需要自己定制创建（或者使用插件提供的模板），提供了丰富的扩展性，下面介绍下自定义使用的主要流程方法，主要是get_frame和getImage：</p><p>一个生产者一般对应一个frame，frame可以设置position，对应长度：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">producer_get_frame</span><span class="params">(mlt_producer producer, mlt_frame_ptr frame, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Generate a frame</span></span><br><span class="line">    *frame = mlt_frame_init(MLT_PRODUCER_SERVICE(producer));</span><br><span class="line">    <span class="keyword">if</span> (*frame != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// Obtain properties of frame and producer</span></span><br><span class="line">        mlt_frame_set_position(*frame, mlt_producer_position(producer));</span><br><span class="line">        </span><br><span class="line">        mlt_frame_push_service(*frame, producer);</span><br><span class="line">        mlt_frame_push_get_image(*frame, producer_get_image);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Calculate the next timecode</span></span><br><span class="line">    mlt_producer_prepare_next(producer);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>每一次图像处理都需要走get_image,根据进度可以进行不同的处理：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">producer_get_image(mlt_frame frame, <span class="keyword">uint8_t</span> **buffer, mlt_image_format *format, <span class="keyword">int</span> *width,</span><br><span class="line">                   <span class="keyword">int</span> *height, <span class="keyword">int</span> writable) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Obtain properties of frame</span></span><br><span class="line">    <span class="comment">//mlt_properties frame_props = MLT_FRAME_PROPERTIES(frame);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Obtain the producer for this frame</span></span><br><span class="line">    <span class="comment">//mlt_producer mlt_producer = mlt_properties_get_data(frame_props, "producer_android_jpeg", NULL);</span></span><br><span class="line"></span><br><span class="line">    mlt_producer producer = (mlt_producer) mlt_frame_pop_service(frame);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//do something here</span></span><br><span class="line">    </span><br><span class="line">    mlt_frame_set_image(frame, *buffer, size, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="mlt-filter"><a href="#mlt-filter" class="headerlink" title="mlt_filter"></a>mlt_filter</h3><p>过滤器主要处理流程：</p><p>处理frame：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> mlt_frame <span class="title">process</span><span class="params">(mlt_filter filter, mlt_frame frame)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// do something here</span></span><br><span class="line"></span><br><span class="line">    mlt_frame_push_service(frame, filter);</span><br><span class="line">    mlt_frame_push_get_image(frame, get_image);</span><br><span class="line">    <span class="keyword">return</span> frame;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理image：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">get_image(mlt_frame frame, <span class="keyword">uint8_t</span> **image, mlt_image_format *format, <span class="keyword">int</span> *width, <span class="keyword">int</span> *height,</span><br><span class="line">          <span class="keyword">int</span> writable) &#123;</span><br><span class="line">    mlt_filter filter = (mlt_filter) mlt_frame_pop_service(frame);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// do something here</span></span><br><span class="line">    </span><br><span class="line">    *format = mlt_image_glsl;</span><br><span class="line">    <span class="keyword">return</span> mlt_frame_get_image(frame, image, format, width, height, writable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="mlt-transition"><a href="#mlt-transition" class="headerlink" title="mlt_transition"></a>mlt_transition</h3><p>混合器需要对应两个frame，处理当前a_frame时，把b_frame传给a_frame，处理frame：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> mlt_frame <span class="title">process</span><span class="params">(mlt_transition transition, mlt_frame a_frame, mlt_frame b_frame)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// do something here</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Push the transition on to the frame</span></span><br><span class="line">    mlt_frame_push_service(a_frame, transition);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Push the b_frame on to the stack</span></span><br><span class="line">    mlt_frame_push_frame(a_frame, b_frame);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Push the transition method</span></span><br><span class="line">    mlt_frame_push_get_image(a_frame, get_image);</span><br><span class="line">    <span class="keyword">return</span> a_frame;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理image时获取a_frame和b_frame,锁住混合器防止同时处理的异常，然后可以进行混合处理：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">get_image(mlt_frame a_frame, <span class="keyword">uint8_t</span> **image, mlt_image_format *format, <span class="keyword">int</span> *width, <span class="keyword">int</span> *height,</span><br><span class="line">          <span class="keyword">int</span> writable) &#123;</span><br><span class="line">    <span class="keyword">int</span> error = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Get the b frame from the stack</span></span><br><span class="line">    mlt_frame b_frame = (mlt_frame) mlt_frame_pop_frame(a_frame);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the transition object</span></span><br><span class="line">    mlt_transition transition = (mlt_transition) mlt_frame_pop_service(a_frame);</span><br><span class="line">    mlt_service service = MLT_TRANSITION_SERVICE(transition);</span><br><span class="line">    mlt_service_lock(service);</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// do something here</span></span><br><span class="line">    </span><br><span class="line">    mlt_service_unlock(service);</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mlt-consumer"><a href="#mlt-consumer" class="headerlink" title="mlt_consumer"></a>mlt_consumer</h3><p>消费者是整个框架的发动机，主要公共方法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mlt_consumer_init</span><span class="params">( mlt_consumer <span class="keyword">this</span>, <span class="keyword">void</span> *child )</span></span>;</span><br><span class="line"><span class="function">mlt_service <span class="title">mlt_consumer_service</span><span class="params">( mlt_consumer <span class="keyword">this</span> )</span></span>;</span><br><span class="line"><span class="function">mlt_properties <span class="title">mlt_consumer_properties</span><span class="params">( mlt_consumer <span class="keyword">this</span> )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mlt_consumer_connect</span><span class="params">( mlt_consumer <span class="keyword">this</span>, mlt_service producer )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mlt_consumer_start</span><span class="params">( mlt_consumer <span class="keyword">this</span> )</span></span>;</span><br><span class="line"><span class="function">mlt_frame <span class="title">mlt_consumer_get_frame</span><span class="params">( mlt_consumer <span class="keyword">this</span> )</span></span>;</span><br><span class="line"><span class="function">mlt_frame <span class="title">mlt_consumer_rt_frame</span><span class="params">( mlt_consumer <span class="keyword">this</span> )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mlt_consumer_stop</span><span class="params">( mlt_consumer <span class="keyword">this</span> )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mlt_consumer_is_stopped</span><span class="params">( mlt_consumer <span class="keyword">this</span> )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mlt_consumer_close</span><span class="params">( mlt_consumer )</span></span>;</span><br></pre></td></tr></table></figure><p>包含一些状态控制，属性等方法，自己使用需要创建线程，在线程中获取frame，线程中的基本流程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">consumer_thread</span><span class="params">( <span class="keyword">void</span> *arg )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// Map the argument to the object</span></span><br><span class="line">mlt_consumer <span class="keyword">this</span> = arg;</span><br><span class="line"><span class="comment">// Get the properties</span></span><br><span class="line">mlt_properties properties = MLT_CONSUMER_PROPERTIES( <span class="keyword">this</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Convenience functionality</span></span><br><span class="line"><span class="keyword">int</span> terminate_on_pause = mlt_properties_get_int( properties, <span class="string">"terminate_on_pause"</span> );</span><br><span class="line"><span class="keyword">int</span> terminated = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Frame and size</span></span><br><span class="line">mlt_frame frame = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Loop while running</span></span><br><span class="line"><span class="keyword">while</span>( !terminated &amp;&amp; mlt_properties_get_int( properties, <span class="string">"running"</span> ) )</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Get the frame</span></span><br><span class="line">frame = mlt_consumer_rt_frame( <span class="keyword">this</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check for termination</span></span><br><span class="line"><span class="keyword">if</span> ( terminate_on_pause &amp;&amp; frame != <span class="literal">NULL</span> )</span><br><span class="line">terminated = mlt_properties_get_double( MLT_FRAME_PROPERTIES( frame ), <span class="string">"_speed"</span> ) == <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check that we have a frame to work with</span></span><br><span class="line"><span class="keyword">if</span> ( frame != <span class="literal">NULL</span> )</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Close the frame</span></span><br><span class="line">mlt_events_fire( properties, <span class="string">"consumer-frame-show"</span>, frame, <span class="literal">NULL</span> );</span><br><span class="line">mlt_frame_close( frame );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Indicate that the consumer is stopped</span></span><br><span class="line">mlt_properties_set_int( properties, <span class="string">"running"</span>, <span class="number">0</span> );</span><br><span class="line">mlt_consumer_stopped( <span class="keyword">this</span> );</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在while循环中用mlt_consumer_rt_frame获取frame，就发动起了整个框架。</p><h3 id="mlt-playlist"><a href="#mlt-playlist" class="headerlink" title="mlt_playlist"></a>mlt_playlist</h3><p>mlt_playlist实际也是个mlt_producer,结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mlt_playlist_s</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mlt_producer_s</span> <span class="title">parent</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mlt_producer_s</span> <span class="title">blank</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> size;</span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line">playlist_entry **<span class="built_in">list</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>playlist_entry是个mlt_playlist_clip_info的list，结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> clip;                 <span class="comment">/**&lt; the index of the clip within the playlist */</span></span><br><span class="line">mlt_producer producer;    <span class="comment">/**&lt; the clip's producer (or parent producer of a cut) */</span></span><br><span class="line">mlt_producer cut;         <span class="comment">/**&lt; the clips' cut producer */</span></span><br><span class="line">mlt_position start;       <span class="comment">/**&lt; the time this begins relative to the beginning of the playlist */</span></span><br><span class="line"><span class="keyword">char</span> *resource;           <span class="comment">/**&lt; the file name or address of the clip */</span></span><br><span class="line">mlt_position frame_in;    <span class="comment">/**&lt; the clip's in point */</span></span><br><span class="line">mlt_position frame_out;   <span class="comment">/**&lt; the clip's out point */</span></span><br><span class="line">mlt_position frame_count; <span class="comment">/**&lt; the duration of the clip */</span></span><br><span class="line">mlt_position length;      <span class="comment">/**&lt; the unedited duration of the clip */</span></span><br><span class="line"><span class="keyword">float</span> fps;                <span class="comment">/**&lt; the frame rate of the clip */</span></span><br><span class="line"><span class="keyword">int</span> repeat;               <span class="comment">/**&lt; the number of times the clip is repeated */</span></span><br><span class="line">&#125;</span><br><span class="line">mlt_playlist_clip_info;</span><br></pre></td></tr></table></figure><p>clip一段也是一个生产者，符合前面讲的多个生产者组合成一个播放列表.</p><h3 id="mlt-tractor"><a href="#mlt-tractor" class="headerlink" title="mlt_tractor"></a>mlt_tractor</h3><p>轨道也是生产者的组合，但是组合方式不一样，多个轨道是并行，比如音频和图像轨。</p><p>结构如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mlt_tractor_s</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mlt_producer_s</span> <span class="title">parent</span>;</span></span><br><span class="line">mlt_service producer;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>结构非常简单，多个轨进行叠加要使用mlt_field,mlt_field专门是为track添加过滤和混合的，添加方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mlt_field_plant_filter(field, filter, <span class="number">0</span>);</span><br><span class="line">mlt_field_plant_transition(field, transition, <span class="number">0</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p> 基础内容来自:<br><a href="https://github.com/mltframework/mlt/blob/master/docs/framework.txt" target="_blank" rel="noopener">https://github.com/mltframework/mlt/blob/master/docs/framework.txt</a></p>]]></content>
    
    <summary type="html">
    
      关于mlt框架你所必须掌握的知识点
    
    </summary>
    
    
      <category term="音视频" scheme="http://anddymao.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="C" scheme="http://anddymao.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu下载安装OpenCV并在Clion中使用</title>
    <link href="http://anddymao.com/2019/10/26/2019-10-26-opencv-%E5%AE%89%E8%A3%85/"/>
    <id>http://anddymao.com/2019/10/26/2019-10-26-opencv-安装/</id>
    <published>2019-10-26T04:00:00.000Z</published>
    <updated>2020-01-18T02:16:08.249Z</updated>
    
    <content type="html"><![CDATA[<h2 id="cmake下载安装"><a href="#cmake下载安装" class="headerlink" title="cmake下载安装"></a>cmake下载安装</h2><p><a href="https://cmake.org/download/" target="_blank" rel="noopener">https://cmake.org/download/</a></p><p>通过apt-get获取的不是最新版本，就去官网下载最新版本3.16.0-rc2。</p><p>解压后直接到bash.rc 配置环境变量就可以了</p><p>PATH=/home/cmake-3.16.0-rc2-Linux-x86_64/bin:$PATH</p><p>到命令行输入cmake版本会显示3.16.0-rc2</p><h2 id="下载-OpenCV"><a href="#下载-OpenCV" class="headerlink" title="下载 OpenCV"></a>下载 OpenCV</h2><p>直接官网转github下载release版本，最新版本4.1.2</p><p><a href="https://github.com/opencv/opencv/releases" target="_blank" rel="noopener">https://github.com/opencv/opencv/releases</a></p><p><a href="https://github.com/opencv/opencv_contrib/releases" target="_blank" rel="noopener">https://github.com/opencv/opencv_contrib/releases</a></p><p>opencv_contrib是一些额外的模块，也需要使用，就也下载了。</p><h2 id="安装-OpenCV"><a href="#安装-OpenCV" class="headerlink" title="安装 OpenCV"></a>安装 OpenCV</h2><p>进入OpenCV根目录，走一下流程即可。</p><p>mrdir build<br>cd build<br>cmake ..<br>make<br>make install</p><p>make install可能需要root权限，前面加sudo 。</p><h2 id="安装-opencv-contrib"><a href="#安装-opencv-contrib" class="headerlink" title="安装 opencv_contrib"></a>安装 opencv_contrib</h2><p>$ cd &lt;opencv_build_directory&gt;<br>$ cmake -DOPENCV_EXTRA_MODULES_PATH=&lt;opencv_contrib&gt;/modules &lt;opencv_source_directory&gt;<br>$ make -j5</p><p>github上提示的安装步骤如上。</p><p>到opencv_contrib目录，其实也是这几个步骤。</p><p>mrdir build<br>cd build<br>cmake ..<br>make<br>make install</p><p>但cmake这一步要用opencv_source_directory（即opencv的源码路径）编译opencv_contrib的module下的模块。</p><h2 id="创建Clion工程"><a href="#创建Clion工程" class="headerlink" title="创建Clion工程"></a>创建Clion工程</h2><p>创建一个工程，比如opencvtest</p><p>然后配置cmakelist：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.13)</span><br><span class="line">project(opencvtest)</span><br><span class="line"></span><br><span class="line">find_package(OpenCV REQUIRED)</span><br><span class="line">include_directories($&#123;OpenCV_INCLUDE_DIRS&#125;)</span><br><span class="line"></span><br><span class="line">set(CMAKE_CXX_STANDARD 14)</span><br><span class="line"></span><br><span class="line">add_executable(opencvtest main.cpp)</span><br><span class="line"></span><br><span class="line">target_link_libraries(opencvtest $&#123;OpenCV_LIBS&#125;)</span><br></pre></td></tr></table></figure><p>随便找了下实例代码，在main.cpp添加：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opencv2/core/core.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opencv2/opencv.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opencv2/highgui/highgui.hpp"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Mat img = imread(<span class="string">"../test.jpg"</span>);</span><br><span class="line">    namedWindow(<span class="string">"DisplayImage"</span>);</span><br><span class="line">    imshow(<span class="string">"Cat"</span>, img);</span><br><span class="line">    waitKey();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就可以run起来。</p><p>Mat是opencv的数据类型，namedWindow创建显示创建，imshow显示图片，然后等待操作，返回。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ubuntu上配置软件比较方便，一般几招，apt-get，官网下载，release版本配置path直接使用，源码版本自己make使用。</p>]]></content>
    
    <summary type="html">
    
      ubuntu软件安装基本流程和问题解决
    
    </summary>
    
    
      <category term="音视频" scheme="http://anddymao.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="OpenCV" scheme="http://anddymao.com/tags/OpenCV/"/>
    
      <category term="C" scheme="http://anddymao.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>NDK中使用MediaCodec编解码视频</title>
    <link href="http://anddymao.com/2019/10/16/2019-10-16-ndk-MediaCodec/"/>
    <id>http://anddymao.com/2019/10/16/2019-10-16-ndk-MediaCodec/</id>
    <published>2019-10-16T04:00:00.000Z</published>
    <updated>2020-01-18T02:16:08.249Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>MediaCodec 作为Android自带的视频编解码工具，可以直接利用底层硬件编解码能力，现在已经逐渐成为主流了。API21已经支持NDK方法了，MediaCodec api设计得非常精妙,另一个方面也是很多人觉得不好懂。</p><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><h3 id="MediaCodec的两个Buffer和三板斧"><a href="#MediaCodec的两个Buffer和三板斧" class="headerlink" title="MediaCodec的两个Buffer和三板斧"></a>MediaCodec的两个Buffer和三板斧</h3><p>MediaCodec内部包含InputBuffer和OutputBuffer，内部有一个自启线程，不断去查询两个Buffer，是一个生产者消费者模型。</p><p>进行数据处理时主要靠三板斧</p><p>第一步：取buffer地址<br>AMediaCodec_dequeueInputBuffer</p><p>第二步：获取buffer数据<br>AMediaCodec_getInputBuffer</p><p>第三步：buffer入队<br>AMediaCodec_queueInputBuffer</p><p>InputBuffer和OutputBuffer基本是对称的：</p><p>第一步：取buffer地址<br>AMediaCodec_dequeueOutputBuffer</p><p>第二步：获取buffer数据<br>AMediaCodec_getOutputBuffer</p><p>第三步：buffer释放<br>AMediaCodec_releaseOutputBuffer</p><p>只有第三步不同，AMediaCodec_queueInputBuffer是数据入队等待消费，AMediaCodec_releaseOutputBuffer是释放数据。<br>编码和解码过程，InputBuffer和OutputBuffer就互相置换下。<br>解码： 原始数据（视频流）-&gt; 提取器AMediaExtractor-&gt;InputBuffer-&gt;OutputBuffer-&gt;帧数据(YUV420sp，PCM)<br>编码： 帧数据（视频流）-&gt;InputBuffer-&gt;OutputBuffer-&gt;合成器AMediaMuxer</p><h3 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h3><h4 id="解码配置"><a href="#解码配置" class="headerlink" title="解码配置"></a>解码配置</h4><p>解码开始需要配置AMediaCodec和AMediaExtractor,MediaCodec start后就可以开始解码，</p><p>AMediaExtractor需要设置文件描述符，通过AAssetManager_open或者fopen就可以得到。起始点和长度也同样。然后设置进提取器。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AMediaExtractor_setDataSourceFd(mExtractor, virtualFile.fd,</span><br><span class="line">                                                         virtualFile.start,</span><br><span class="line">                                                         virtualFile.length);</span><br></pre></td></tr></table></figure><p>AMediaCodec创建需要设置数据格式，通过AMediaExtractor获取到的AMediaFormat可以得到mime和format。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mCodec = AMediaCodec_createDecoderByType(mime);</span><br><span class="line">AMediaCodec_configure(mCodec, format, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">AMediaCodec_start(mCodec);</span><br></pre></td></tr></table></figure><p>解码配置第三个参数为NativeWindow，加了后解码后可以直接吐到surface上，GPU数据直接渲软，效率高但不够灵活。不加的话解码数据就需要输出拷贝。</p><h4 id="解码流程"><a href="#解码流程" class="headerlink" title="解码流程"></a>解码流程</h4><p>解码也就是操作两个Buffer的过程，执行玩三板斧就可以，然后有一些状态需要处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!mInputEof) &#123;</span><br><span class="line">    <span class="keyword">ssize_t</span> bufidx = AMediaCodec_dequeueInputBuffer(mCodec, <span class="number">1</span>);</span><br><span class="line">    log_info(<span class="literal">NULL</span>, <span class="string">"input buffer %zd"</span>, bufidx);</span><br><span class="line">    <span class="keyword">if</span> (bufidx &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">size_t</span> bufsize;</span><br><span class="line">        <span class="keyword">uint8_t</span> *buf = AMediaCodec_getInputBuffer(mCodec, bufidx, &amp;bufsize);</span><br><span class="line">        <span class="keyword">int</span> sampleSize = AMediaExtractor_readSampleData(mExtractor, buf, bufsize);</span><br><span class="line">        <span class="keyword">if</span> (sampleSize &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            sampleSize = <span class="number">0</span>;</span><br><span class="line">            mInputEof = <span class="literal">true</span>;</span><br><span class="line">            log_info(<span class="literal">NULL</span>, <span class="string">"video producer input EOS"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int64_t</span> presentationTimeUs = AMediaExtractor_getSampleTime(mExtractor);</span><br><span class="line"></span><br><span class="line">        AMediaCodec_queueInputBuffer(mCodec, bufidx, <span class="number">0</span>, sampleSize, presentationTimeUs,</span><br><span class="line">                                     mInputEof ? AMEDIACODEC_BUFFER_FLAG_END_OF_STREAM</span><br><span class="line">                                               : <span class="number">0</span>);</span><br><span class="line">        AMediaExtractor_advance(mExtractor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!mOutputEof) &#123;</span><br><span class="line">    AMediaCodecBufferInfo info;</span><br><span class="line">    <span class="keyword">ssize_t</span> status = AMediaCodec_dequeueOutputBuffer(mCodec, &amp;info, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (status &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (info.flags &amp; AMEDIACODEC_BUFFER_FLAG_END_OF_STREAM) &#123;</span><br><span class="line">            log_info(<span class="literal">NULL</span>, <span class="string">"video producer output EOS"</span>);</span><br><span class="line"></span><br><span class="line">            eof = <span class="literal">true</span>;</span><br><span class="line">            mOutputEof = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">uint8_t</span> *outputBuf = AMediaCodec_getOutputBuffer(mCodec, status, <span class="literal">NULL</span><span class="comment">/* out_size */</span>);</span><br><span class="line">        <span class="keyword">size_t</span> dataSize = info.size;</span><br><span class="line">        <span class="keyword">if</span> (outputBuf != <span class="literal">nullptr</span> &amp;&amp; dataSize != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> pts = info.presentationTimeUs;</span><br><span class="line">            <span class="keyword">int32_t</span> pts32 = (<span class="keyword">int32_t</span>) pts;</span><br><span class="line"></span><br><span class="line">            *buffer = (<span class="keyword">uint8_t</span> *) mlt_pool_alloc(dataSize);</span><br><span class="line">            <span class="built_in">memcpy</span>(*buffer, outputBuf + info.offset, dataSize);</span><br><span class="line">            *buffersize = dataSize;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int64_t</span> presentationNano = info.presentationTimeUs * <span class="number">1000</span>;</span><br><span class="line">        log_info(<span class="literal">NULL</span>, <span class="string">"video pts %lld outsize %d"</span>, info.presentationTimeUs, dataSize);</span><br><span class="line">        <span class="comment">/*if (delay &gt; 0) &#123;</span></span><br><span class="line"><span class="comment">            usleep(delay / 1000);</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        AMediaCodec_releaseOutputBuffer(mCodec, status, info.size != <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status == AMEDIACODEC_INFO_OUTPUT_BUFFERS_CHANGED) &#123;</span><br><span class="line">        log_info(<span class="literal">NULL</span>, <span class="string">"output buffers changed"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status == AMEDIACODEC_INFO_OUTPUT_FORMAT_CHANGED) &#123;</span><br><span class="line">        AMediaFormat_delete(format);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status == AMEDIACODEC_INFO_TRY_AGAIN_LATER) &#123;</span><br><span class="line">        log_info(<span class="literal">NULL</span>, <span class="string">"video no output buffer right now"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log_info(<span class="literal">NULL</span>, <span class="string">"unexpected info code: %zd"</span>, status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AMediaCodec和AMediaExtractor是没有直接交流的，AMediaCodec取到InputBuffer后实际数据为空，需要从AMediaExtractor_readSampleData获取到buffer数据。<br>AMediaCodec数据入队后，AMediaExtractor调用AMediaExtractor_advance前进到下一个数据位置。</p><p>OutputBuffer操作时有些不一样，AMediaCodec_dequeueOutputBuffer获取的是解码好的帧，AMediaCodec_getOutputBuffer取到的就已经是解码好的数据了，可以直接拷贝使用。<br>AMediaCodec_releaseOutputBuffer是释放buffer，如果配置了surface，就会渲软到surface上。</p><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><h4 id="编码配置"><a href="#编码配置" class="headerlink" title="编码配置"></a>编码配置</h4><p>编码是解码的逆过程，首先设置格式,然后根据格式创建编码器MediaCodec，再根据文件创建合成器MediaMuxer。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> NativeEncoder::prepareEncoder(<span class="keyword">int</span> width, <span class="keyword">int</span> height, <span class="keyword">int</span> fps, <span class="built_in">std</span>::<span class="built_in">string</span> strPath) &#123;</span><br><span class="line"></span><br><span class="line">    mWidth = width;</span><br><span class="line">    mHeight = height;</span><br><span class="line">    mFps = fps;</span><br><span class="line"></span><br><span class="line">    AMediaFormat *format = AMediaFormat_new();</span><br><span class="line">    AMediaFormat_setString(format, AMEDIAFORMAT_KEY_MIME, mStrMime.c_str());</span><br><span class="line">    AMediaFormat_setInt32(format, AMEDIAFORMAT_KEY_WIDTH, mWidth);</span><br><span class="line">    AMediaFormat_setInt32(format, AMEDIAFORMAT_KEY_HEIGHT, mHeight);</span><br><span class="line"></span><br><span class="line">    AMediaFormat_setInt32(format,AMEDIAFORMAT_KEY_COLOR_FORMAT, COLOR_FORMAT_SURFACE);</span><br><span class="line">    AMediaFormat_setInt32(format, AMEDIAFORMAT_KEY_BIT_RATE, mBitRate);</span><br><span class="line">    AMediaFormat_setInt32(format, AMEDIAFORMAT_KEY_FRAME_RATE, mFps);</span><br><span class="line">    AMediaFormat_setInt32(format, AMEDIAFORMAT_KEY_I_FRAME_INTERVAL, mIFrameInternal);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *s = AMediaFormat_toString(format);</span><br><span class="line">    log_info(<span class="literal">NULL</span>, <span class="string">"encoder video format: %s"</span>, s);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    mCodec = AMediaCodec_createEncoderByType(mStrMime);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">media_status_t</span> status = AMediaCodec_configure(mCodec, format, <span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">                                                  AMEDIACODEC_CONFIGURE_FLAG_ENCODE);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>) &#123;</span><br><span class="line">        log_error(<span class="literal">NULL</span>, <span class="string">"AMediaCodec_configure() failed with error %i for format %u"</span>,</span><br><span class="line">                      (<span class="keyword">int</span>) status, <span class="number">21</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    AMediaFormat_delete(format);</span><br><span class="line"></span><br><span class="line">    FILE *fp = fopen(strPath.c_str(), <span class="string">"wb"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mFd = fileno(fp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mFd = <span class="number">-1</span>;</span><br><span class="line">        log_error(<span class="literal">NULL</span>, <span class="string">"create file %s fail"</span>, strPath.c_str());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(mMuxer == <span class="literal">NULL</span>)</span><br><span class="line">        mMuxer = AMediaMuxer_new(mFd, AMEDIAMUXER_OUTPUT_FORMAT_MPEG_4);</span><br><span class="line"></span><br><span class="line">    mMuxerStarted = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    fclose(fp);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里注意下配置类型是 “video/avc”，基本视频都是这个格式，可以看官网格式支持信息，比特率mBitRate是6000000，这个要根据需求对应配置，I帧间隔mIFrameInternal是1秒，间隔长获取关键帧信息会有问题。</p><h4 id="编码准备"><a href="#编码准备" class="headerlink" title="编码准备"></a>编码准备</h4><p>编码视频流需要创建一个surface，再把这个surface绑定到共享的EGLContext上。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> NativeEncoder::prepareEncoderWithShareCtx(<span class="keyword">int</span> width, <span class="keyword">int</span> height, <span class="keyword">int</span> fps, <span class="built_in">std</span>::<span class="built_in">string</span> strPath,</span><br><span class="line">                                   EGLContext shareCtx) &#123;</span><br><span class="line"></span><br><span class="line">    prepareEncoder(width,height,fps,strPath);</span><br><span class="line">    ANativeWindow *surface;</span><br><span class="line">    AMediaCodec_createInputSurface(mCodec, &amp;surface);</span><br><span class="line">    <span class="keyword">media_status_t</span> status;</span><br><span class="line">    <span class="keyword">if</span> ((status = AMediaCodec_start(mCodec)) != AMEDIA_OK) &#123;</span><br><span class="line">        log_error(<span class="literal">NULL</span>, <span class="string">"AMediaCodec_start: Could not start encoder."</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log_info(<span class="literal">NULL</span>, <span class="string">"AMediaCodec_start: encoder successfully started"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mCodecInputSurface = <span class="keyword">new</span> CodecInputSurface(surface);</span><br><span class="line">    mCodecInputSurface-&gt;setupEGL(shareCtx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编码流程"><a href="#编码流程" class="headerlink" title="编码流程"></a>编码流程</h4><p>编码需要先进行渲染，从外部共享的EGLContext传入一个纹理，渲软到编码器对应的surface上，再进行编码。</p><p>传入纹理并渲染：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> NativeEncoder::feedFrame(<span class="keyword">uint64_t</span> pts, <span class="keyword">int</span> tex) &#123;</span><br><span class="line">    drainEncoder(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    mCodecInputSurface-&gt;makeCurrent();</span><br><span class="line">    glViewport(<span class="number">0</span>,<span class="number">0</span>,mWidth,mHeight);</span><br><span class="line">    mCodecInputSurface-&gt;renderOnSurface(tex);</span><br><span class="line">    mCodecInputSurface-&gt;setPresentationTime(pts);</span><br><span class="line">    mCodecInputSurface-&gt;swapBuffers();</span><br><span class="line">    mCodecInputSurface-&gt;makeNothingCurrent();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> NativeEncoder::drainEncoder(<span class="keyword">bool</span> eof) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (eof) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">ssize_t</span> ret = AMediaCodec_signalEndOfInputStream(mCodec);</span><br><span class="line">        log_info(<span class="literal">NULL</span>, <span class="string">"drainEncoder eof = %d"</span>,ret);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">        AMediaCodecBufferInfo info;</span><br><span class="line">        <span class="comment">//time out usec 1</span></span><br><span class="line">        <span class="keyword">ssize_t</span> status = AMediaCodec_dequeueOutputBuffer(mCodec, &amp;info, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (status == AMEDIACODEC_INFO_TRY_AGAIN_LATER) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!eof) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                log_info(<span class="literal">NULL</span>, <span class="string">"video no output available, spinning to await EOS"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status == AMEDIACODEC_INFO_OUTPUT_BUFFERS_CHANGED) &#123;</span><br><span class="line">            <span class="comment">// not expected for an encoder</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status == AMEDIACODEC_INFO_OUTPUT_FORMAT_CHANGED) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mMuxerStarted) &#123;</span><br><span class="line">                log_warning(<span class="literal">NULL</span>, <span class="string">"format changed twice"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            AMediaFormat *fmt = AMediaCodec_getOutputFormat(mCodec);</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *s = AMediaFormat_toString(fmt);</span><br><span class="line">            log_info(<span class="literal">NULL</span>, <span class="string">"video output format %s"</span>, s);</span><br><span class="line"></span><br><span class="line">            mTrackIndex = AMediaMuxer_addTrack(mMuxer, fmt);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(mAudioTrackIndex != <span class="number">-1</span> &amp;&amp; mTrackIndex != <span class="number">-1</span>) &#123;</span><br><span class="line"></span><br><span class="line">                log_info(<span class="literal">NULL</span>,<span class="string">"AMediaMuxer_start"</span>);</span><br><span class="line">                AMediaMuxer_start(mMuxer);</span><br><span class="line">                mMuxerStarted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">uint8_t</span> *encodeData = AMediaCodec_getOutputBuffer(mCodec, status, <span class="literal">NULL</span><span class="comment">/* out_size */</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (encodeData == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                log_error(<span class="literal">NULL</span>, <span class="string">"encoder output buffer was null"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((info.flags &amp; AMEDIACODEC_BUFFER_FLAG_CODEC_CONFIG) != <span class="number">0</span>) &#123;</span><br><span class="line">                log_info(<span class="literal">NULL</span>, <span class="string">"ignoring AMEDIACODEC_BUFFER_FLAG_CODEC_CONFIG"</span>);</span><br><span class="line">                info.size = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">size_t</span> dataSize = info.size;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (dataSize != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!mMuxerStarted) &#123;</span><br><span class="line">                    log_error(<span class="literal">NULL</span>, <span class="string">"muxer has't started"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                log_info(<span class="literal">NULL</span>,<span class="string">"AMediaMuxer_writeSampleData video size %d"</span>,dataSize);</span><br><span class="line">                AMediaMuxer_writeSampleData(mMuxer, mTrackIndex, encodeData, &amp;info);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            AMediaCodec_releaseOutputBuffer(mCodec, status, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((info.flags &amp; AMEDIACODEC_BUFFER_FLAG_END_OF_STREAM) != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!eof) &#123;</span><br><span class="line">                    log_warning(<span class="literal">NULL</span>, <span class="string">"reached end of stream unexpectly"</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    log_info(<span class="literal">NULL</span>, <span class="string">"video end of stream reached"</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了结尾标记，编码时没有操作InputBuffer，因为InputBuffer对应的就是surface的源，所以编码第一步实际是渲软，通过opengl render到surface上再交换缓冲区到surface上；<br>第二步获取到OutputBuffer数据，调用AMediaCodec_getOutputBuffer；<br>第三步合成器写数据，调用AMediaMuxer_writeSampleData然后释放outputBuffer，调用AMediaCodec_releaseOutputBuffer。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结了下MediaCodec在ndk中的使用，MediaCodec是一个非常灵活的api，编解码音视频都是同一个，掌握双缓冲和三板斧就对流程有了非常清楚的了解，对编解码代码也可以不再畏惧了。</p>]]></content>
    
    <summary type="html">
    
      MediaCodec使用详解
    
    </summary>
    
    
      <category term="Android" scheme="http://anddymao.com/tags/Android/"/>
    
      <category term="音视频" scheme="http://anddymao.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="C" scheme="http://anddymao.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>如何对一个大型Android项目进行模块化重构</title>
    <link href="http://anddymao.com/2019/02/02/2019-2-2-%E5%A6%82%E4%BD%95%E5%AF%B9%E4%B8%80%E4%B8%AA%E5%A4%A7%E5%9E%8BAndroid%E9%A1%B9%E7%9B%AE%E8%BF%9B%E8%A1%8C%E6%A8%A1%E5%9D%97%E5%8C%96%E9%87%8D%E6%9E%84/"/>
    <id>http://anddymao.com/2019/02/02/2019-2-2-如何对一个大型Android项目进行模块化重构/</id>
    <published>2019-02-02T04:00:00.000Z</published>
    <updated>2020-01-18T02:16:08.251Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>相册作为一个系统应用，17年才转到gradle编译，带着很多沉重的包袱，基本只有一个app模块，编译速度慢。<br>同时相册上又有许多新的功能，整体代码量层线性增长，一些相对独立的新功能会把代码资源都放在一个单独文件夹中，但编译时还是编译在同一个app模块里，各部分之前耦合度高。<br>这些单独的模块是不是应该抽离成单独Module？<br>第一问之后又会延伸出下面几个问题：<br>基础组件是不是应该独立出来？<br>各部分代码耦合是不是应该抽离？<br>工具类依赖业务类是否需要重构？</p><h2 id="为什么要模块化"><a href="#为什么要模块化" class="headerlink" title="为什么要模块化"></a>为什么要模块化</h2><p>做一件事得思考利益，讲投入产出。模块化主要有这些好处：<br>1.使各模块解耦，提高代码的可维护性，减小bug产生<br>2.增加模块独立运行和测试能力<br>3.提升编译速度</p><p>对于2各个功能目前都没有单独运行的需求，单独测试有一定需求；对于3提升速度有限必要性不大。<br>1是我们最重要的需求，是长期的好处。模块化后各个组件结构清晰，对于项目维护，新增功能，减少bug，都会有很大的好处。<br>所以这是一件值得做的是，优先级是是重要不紧急。</p><h2 id="如何着手做"><a href="#如何着手做" class="headerlink" title="如何着手做"></a>如何着手做</h2><p>实际模块化也就是代码重构的事，我们日常功能需求比较多，这上面只能用少部分时间。所以我定了一个小步慢走的方案，每周用一天左右的时间进行代码重构。</p><h2 id="思路选择"><a href="#思路选择" class="headerlink" title="思路选择"></a>思路选择</h2><p>思路一：直接外移方案<br>当前app module不动，逐渐外移单独module，让单独module依赖app module，最后app module会全部被外移。<br>这种方案开始影响最小，但不适合我们的项目，因为我们的主工程是非常大的，分支小，app module没法也没必要全部外移拆分，这样外移的小模块依赖大模块，没有意义。</p><p>思路二：先整理后外移方案<br>单独module依赖的东西有统计，网络，preference，imageLoader，基础utils等，那先整理这些基础组件，进行下移，然后再进行独立module的重构，独立module和app module之间要互相不依赖，互相调用使用模块化接口。<br>这种方案对代码的整理较多，这也是我们最终需要做的，最终决定使用这种方案。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="基础组件下移"><a href="#基础组件下移" class="headerlink" title="基础组件下移"></a>基础组件下移</h3><p>提前调研需要独立的模块，分析依赖的基础模块，进行基础组件的下移。<br>下移时尽量轻量进行，命名无非必要不进行更改，需要重构可以后续再进行，确保下移的影响最小。<br>这部分工作是实际最耗时间精力的，因为很多工具类和业务类耦合很严重，需要针对性梳理和划分。</p><h3 id="模块化通信"><a href="#模块化通信" class="headerlink" title="模块化通信"></a>模块化通信</h3><p>独立模块之间如何通信，因为互相有接口调用，所以采用接口化方案，接口定义在公共模块，实现在独立功能模块，然后就需要注册和获取。<br>新建了一个iModule的模块，模块化的类需要依赖此模块，此模块里面有模块化接口的定义，各个模块中做对应实现。app启动时进行模块注册。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModuleManagerImpl</span> <span class="keyword">implements</span> <span class="title">IModuleManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"ModuleManagerImpl"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> IModuleManager mModuleManager = <span class="keyword">new</span> ModuleManagerImpl();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;Class&lt;? extends IModule&gt;, IModuleImpl&gt; mBuiltinModules = <span class="keyword">new</span> LinkedHashMap();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IModuleManager <span class="title">getModuleManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mModuleManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ModuleManagerImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IModule <span class="title">getModule</span><span class="params">(Class&lt;? extends IModule&gt; cls)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mBuiltinModules.get(cls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addModule</span><span class="params">(Class&lt;? extends IModule&gt; cls, IModuleImpl moduleImpl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mBuiltinModules.put(cls, moduleImpl);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ModuleManageImpl保存了一个map，key为IModule接口类，value为IModuleImpl类，这样通过接口就可以获取到对应的实现，进行模块间通信。</p><h3 id="代码隔离"><a href="#代码隔离" class="headerlink" title="代码隔离"></a>代码隔离</h3><p>上面说到app启动时需要进行模块注册，如果在app模块注册的话，app模块就依赖了独立module。<br>我们可以使用gradle的implement进行隔离，implement的作用是依赖的模块的代码不对外暴露给依赖我的模块，如果需要暴露就使用api进行模块引入。<br>新增一个moduleservice，moduleservice依赖所有的独立模块，在moduleservice进行模块注册，没有其它功能仅仅是为了做隔离，app依赖moduleservice，app启动时调用moduleservice的模块注册方法。</p><h3 id="层次结构"><a href="#层次结构" class="headerlink" title="层次结构"></a>层次结构</h3><p>这样我们的应用就分成了这样的结构：</p><p>1.主功能层：app模块，包括主体业务功能<br>2.模块注册层：moduleservice， 用于隔离直接依赖<br>3.独立模块层：包括照片电影，拼图等独立功能模块，以library存在，可单独添加application的测试模块<br>4.基础组件层：包括网络，图片库，统计，基础工具等</p><h3 id="进一步自动化"><a href="#进一步自动化" class="headerlink" title="进一步自动化"></a>进一步自动化</h3><p>这个地方再进一步自动化的话，可以使用gradle插件，在集成时添加依赖，在编译期修改代码，自动添加模块注册方法；<br>自动识别运行的application,对模块留一份单独运行的代码,做到即可做library又可独立测试运行。</p><p>这部分参照一些组件化框架进行了尝试，当前还没有在工程上使用，这些是锦上添花的工作，主要的还是把前面几步完成好，循序渐进。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了相册模块化中的思路，对于一个庞杂的系统应用该如何梳理，实现模块化改造。<br>现在大家经常说的是组件化，和模块化相比更强调组件的复用性。这次梳理没有进行业务的组件梳理，只独立出一些基础功能组件，所以主要基于的还是模块化。<br>组件化，模块化方案思路很多，一定要根据业务需求进行选择，先业务后技术，而不是先技术后业务。<br>当前模块化完成后只是提供基本的框架结构，后续还需一步步优化改进，代码重构是一项持续的工作。</p>]]></content>
    
    <summary type="html">
    
      相册模块化方案及心得
    
    </summary>
    
    
      <category term="Android" scheme="http://anddymao.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>做了一个好玩的ShaderToy相机</title>
    <link href="http://anddymao.com/2019/02/01/2019-2-1-%E5%81%9A%E4%BA%86%E4%B8%80%E4%B8%AA%E5%A5%BD%E7%8E%A9%E7%9A%84ShaderToy%E7%9B%B8%E6%9C%BA/"/>
    <id>http://anddymao.com/2019/02/01/2019-2-1-做了一个好玩的ShaderToy相机/</id>
    <published>2019-02-01T04:00:00.000Z</published>
    <updated>2020-01-18T02:16:08.251Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>&lt;<a href="http://www.shadertoy.com&gt;是一个构建着色器的网站，可以创建着色器做出很多漂亮的效果。感觉很有意思，就想放到相机上会好玩，就做出了这个demo，给大家分享下。" target="_blank" rel="noopener">www.shadertoy.com&gt;是一个构建着色器的网站，可以创建着色器做出很多漂亮的效果。感觉很有意思，就想放到相机上会好玩，就做出了这个demo，给大家分享下。</a></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>ShaderToy上每一个效果都有对应的代码，就是片段着色器代码，有一些自定义的参数，比如时间，位置，输入源纹理等。<br>把第一个输入源改成相机输入，就是相机滤镜了。采用GpuImage的框架，搭起一个支持滤镜的相机app，再把ShaderToy上的着色器代码转换过来，就可以实现ShaderToy相机。</p><h3 id="着色器解析"><a href="#着色器解析" class="headerlink" title="着色器解析"></a>着色器解析</h3><p>先找了一个最简单的着色器分析，<a href="https://www.shadertoy.com/view/MddBWn" target="_blank" rel="noopener">https://www.shadertoy.com/view/MddBWn</a>,代码如下：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> mainImage( <span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec2</span> uv = fragCoord/iResolution.xy<span class="number">-0.5</span>;</span><br><span class="line">    uv *= <span class="number">0.7</span> - <span class="built_in">mod</span>(uv.x+uv.y,uv.x*<span class="number">0.5</span>)*<span class="number">1.5</span>;</span><br><span class="line">    fragColor = <span class="built_in">texture</span>(iChannel0,uv+<span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fragColor是输出颜色，fragCoord是坐标，iChannel0是输入原纹理，iResolution是点击的位置。知道这些就可以改成OpenGLEs上着色器代码了：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">precision</span> <span class="keyword">highp</span> <span class="type">float</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span>               iTime;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span>           inputImageTexture;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span>           inputImageTexture2;</span><br><span class="line"><span class="keyword">varying</span> <span class="type">vec2</span>                textureCoordinate;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span>                iResolution;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec2</span> uv = textureCoordinate/iResolution.xy<span class="number">-0.5</span>;</span><br><span class="line">    uv *= <span class="number">0.7</span> - <span class="built_in">mod</span>(uv.x+uv.y,uv.x*<span class="number">0.5</span>)*<span class="number">1.5</span>;</span><br><span class="line">    <span class="built_in">gl_FragColor</span> = <span class="built_in">texture2D</span>(inputImageTexture,uv+<span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个效果叫fokkkus，有点像破碎的镜子向外发射，另外非常喜欢的一个着色器：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">precision</span> <span class="keyword">highp</span> <span class="type">float</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span>               iTime;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span>           inputImageTexture;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span>           inputImageTexture2;</span><br><span class="line"><span class="keyword">varying</span> <span class="type">vec2</span>                textureCoordinate;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec2</span> uv = textureCoordinate.xy;</span><br><span class="line">        <span class="type">vec4</span> c = <span class="built_in">texture2D</span>(inputImageTexture, uv);</span><br><span class="line">        <span class="type">vec4</span> c2 = <span class="built_in">texture2D</span>(inputImageTexture, uv + <span class="type">vec2</span>(<span class="number">0.005</span>, <span class="number">0.005</span>));</span><br><span class="line">        c = c - <span class="built_in">distance</span>(c, c2);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>(c.rgb, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个效果叫distance，着色器原理很简单，就是计算当前点和右上点的颜色的差值，再用当前颜色去减这个值，使图片边沿变深或者糊化，非常简单的代码但效果特别好。</p><h3 id="制作ShaderToy滤镜"><a href="#制作ShaderToy滤镜" class="headerlink" title="制作ShaderToy滤镜"></a>制作ShaderToy滤镜</h3><p>有了片段着色器，再加上顶点着色器再加上控制就可以做出滤镜了，用GpuImage的框架来实现。</p><p>顶点着色器就是传递一下坐标，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NO_FILTER_VERTEX_SHADER = <span class="string">""</span> +</span><br><span class="line">        <span class="string">"attribute vec4 position;\n"</span> +</span><br><span class="line">        <span class="string">"attribute vec4 inputTextureCoordinate;\n"</span> +</span><br><span class="line">        <span class="string">" \n"</span> +</span><br><span class="line">        <span class="string">"varying vec2 textureCoordinate;\n"</span> +</span><br><span class="line">        <span class="string">" \n"</span> +</span><br><span class="line">        <span class="string">"void main()\n"</span> +</span><br><span class="line">        <span class="string">"&#123;\n"</span> +</span><br><span class="line">        <span class="string">"    gl_Position = position;\n"</span> +</span><br><span class="line">        <span class="string">"    textureCoordinate = inputTextureCoordinate.xy;\n"</span> +</span><br><span class="line">        <span class="string">"&#125;"</span>;</span><br></pre></td></tr></table></figure><p>ShaderToyFilter代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShaderToyFilter</span> <span class="keyword">extends</span> <span class="title">BaseOriginalFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] inputTextureHandles = &#123;-<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] inputTextureUniformLocations = &#123;-<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> START_TIME = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ShaderToyFilter</span><span class="params">(<span class="keyword">int</span> shade)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(NO_FILTER_VERTEX_SHADER, OpenGlUtils.readShaderFromRawResource(FilterSDK.sContext, shade));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onInitialized</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onInitialized();</span><br><span class="line"></span><br><span class="line">        inputTextureUniformLocations[<span class="number">0</span>] = GLES20.glGetUniformLocation(mGLProgId, <span class="string">"inputImageTexture2"</span>);</span><br><span class="line">        runOnDraw(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> iResolutionLocation = GLES20.glGetUniformLocation(mGLProgId, <span class="string">"iResolution"</span>);</span><br><span class="line">                GLES20.glUniform3fv(iResolutionLocation, <span class="number">1</span>,</span><br><span class="line">                        FloatBuffer.wrap(<span class="keyword">new</span> <span class="keyword">float</span>[]&#123;(<span class="keyword">float</span>) <span class="number">1.0</span>, (<span class="keyword">float</span>) <span class="number">1</span>, <span class="number">1.0f</span>&#125;));</span><br><span class="line">                inputTextureHandles[<span class="number">0</span>] = OpenGlUtils.loadTexture(FilterSDK.sContext, R.raw.edge_png, <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDrawArraysPre</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDrawArraysPre();</span><br><span class="line">        <span class="keyword">float</span> time = ((<span class="keyword">float</span>) (System.currentTimeMillis() - START_TIME)) / <span class="number">1000.0f</span>;</span><br><span class="line">        <span class="keyword">int</span> iTimeLocation = GLES20.glGetUniformLocation(mGLProgId, <span class="string">"iTime"</span>);</span><br><span class="line">        GLES20.glUniform1f(iTimeLocation, time);</span><br><span class="line"></span><br><span class="line">        GLES20.glActiveTexture(GLES20.GL_TEXTURE0 + (<span class="number">3</span>));</span><br><span class="line">        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, inputTextureHandles[<span class="number">0</span>]);</span><br><span class="line">        GLES20.glUniform1i(inputTextureUniformLocations[<span class="number">0</span>], <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最上继承的是GpuImageFilter,弄了一张纹理图作为inputImageTexture2，少数着色器会用到，位置iResolution传的默认，iTime是时间相对值。滤镜层就这些内容了。</p><h3 id="相机控制"><a href="#相机控制" class="headerlink" title="相机控制"></a>相机控制</h3><p>相机部分使用api2，最新的总是更好的。</p><p>CameraFragment中的打开相机预览代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createCameraPreviewSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          SurfaceTexture texture = mCameraSurfaceView.getSurfaceTexture();</span><br><span class="line">          <span class="keyword">assert</span> texture != <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// We configure the size of default buffer to be the size of camera preview we want.</span></span><br><span class="line">          texture.setDefaultBufferSize(mPreviewSize.getWidth(), mPreviewSize.getHeight());</span><br><span class="line"></span><br><span class="line">          <span class="comment">// This is the output Surface we need to start preview.</span></span><br><span class="line">          Surface surface = <span class="keyword">new</span> Surface(texture);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// We set up a CaptureRequest.Builder with the output Surface.</span></span><br><span class="line">          mPreviewRequestBuilder</span><br><span class="line">                  = mCameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);</span><br><span class="line">          mPreviewRequestBuilder.addTarget(surface);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Here, we create a CameraCaptureSession for camera preview.</span></span><br><span class="line">          mCameraDevice.createCaptureSession(Arrays.asList(surface, mImageReader.getSurface()),</span><br><span class="line">                  <span class="keyword">new</span> CameraCaptureSession.StateCallback() &#123;</span><br><span class="line"></span><br><span class="line">                      <span class="meta">@Override</span></span><br><span class="line">                      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onConfigured</span><span class="params">(@NonNull CameraCaptureSession cameraCaptureSession)</span> </span>&#123;</span><br><span class="line">                          <span class="comment">// The camera is already closed</span></span><br><span class="line">                          <span class="keyword">if</span> (<span class="keyword">null</span> == mCameraDevice) &#123;</span><br><span class="line">                              <span class="keyword">return</span>;</span><br><span class="line">                          &#125;</span><br><span class="line"></span><br><span class="line">                          <span class="comment">// When the session is ready, we start displaying the preview.</span></span><br><span class="line">                          mCaptureSession = cameraCaptureSession;</span><br><span class="line">                          <span class="keyword">try</span> &#123;</span><br><span class="line">                              <span class="comment">// Auto focus should be continuous for camera preview.</span></span><br><span class="line">                              mPreviewRequestBuilder.set(CaptureRequest.CONTROL_AF_MODE,</span><br><span class="line">                                      CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE);</span><br><span class="line">                              <span class="comment">// Flash is automatically enabled when necessary.</span></span><br><span class="line">                              setAutoFlash(mPreviewRequestBuilder);</span><br><span class="line"></span><br><span class="line">                              <span class="comment">// Finally, we start displaying the camera preview.</span></span><br><span class="line">                              mPreviewRequest = mPreviewRequestBuilder.build();</span><br><span class="line">                              mCaptureSession.setRepeatingRequest(mPreviewRequest,</span><br><span class="line">                                      mCaptureCallback, mBackgroundHandler);</span><br><span class="line">                          &#125; <span class="keyword">catch</span> (CameraAccessException e) &#123;</span><br><span class="line">                              e.printStackTrace();</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125;</span><br><span class="line"></span><br><span class="line">                      <span class="meta">@Override</span></span><br><span class="line">                      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onConfigureFailed</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                              @NonNull CameraCaptureSession cameraCaptureSession)</span> </span>&#123;</span><br><span class="line">                          showToast(<span class="string">"Failed"</span>);</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;, <span class="keyword">null</span></span><br><span class="line">          );</span><br><span class="line">      &#125; <span class="keyword">catch</span> (CameraAccessException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>一个是通过CameraSurfaceView拿到SurfaceTexture再生成Surface，再把Surface传给CameraDevice。实际数据的流向是Camera的数据传给SurfaceTexture中，CameraSurfaceView那到纹理做处理再显示出来。<br>打开相机通过CameraDevice创建会话createCaptureSession方法。</p><h3 id="相机显示"><a href="#相机显示" class="headerlink" title="相机显示"></a>相机显示</h3><p>真正显示的地方是CameraSurfaceView，看这部分代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CameraSurfaceView</span> <span class="keyword">extends</span> <span class="title">BaseSurfaceView</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> OesTextureFilter mOesTextureFilter;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SurfaceTexture <span class="title">getSurfaceTexture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mSurfaceTexture;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SurfaceTexture mSurfaceTexture;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mRatioWidth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mRatioHeight = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CameraSurfaceView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CameraSurfaceView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">        <span class="keyword">this</span>.getHolder().addCallback(<span class="keyword">this</span>);</span><br><span class="line">        scaleType = ScaleType.CENTER_CROP;</span><br><span class="line">        gLTextureBuffer.put(TextureRotationUtil.getRotation(Rotation.NORMAL, <span class="keyword">false</span>, <span class="keyword">true</span>))</span><br><span class="line">                .position(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSurfaceCreated</span><span class="params">(GL10 gl, EGLConfig config)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onSurfaceCreated(gl, config);</span><br><span class="line">        <span class="keyword">if</span> (mOesTextureFilter == <span class="keyword">null</span>)</span><br><span class="line">            mOesTextureFilter = <span class="keyword">new</span> OesTextureFilter();</span><br><span class="line">        mOesTextureFilter.init();</span><br><span class="line">        textureId = OpenGlUtils.getExternalOESTextureID();</span><br><span class="line">        <span class="keyword">if</span> (textureId != OpenGlUtils.NO_TEXTURE) &#123;</span><br><span class="line">            mSurfaceTexture = <span class="keyword">new</span> SurfaceTexture(textureId);</span><br><span class="line">            <span class="keyword">if</span> (mSurfaceTextureListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mSurfaceTextureListener.onAvailable();</span><br><span class="line">            &#125;</span><br><span class="line">            mSurfaceTexture.setOnFrameAvailableListener(onFrameAvailableListener);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSurfaceTextureListener</span><span class="params">(SurfaceTextureListener surfaceTextureListener)</span> </span>&#123;</span><br><span class="line">        mSurfaceTextureListener = surfaceTextureListener;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SurfaceTextureListener mSurfaceTextureListener;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setViewPortSize</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">        imageWidth = width;</span><br><span class="line">        imageHeight = height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SurfaceTextureListener</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onAvailable</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSurfaceChanged</span><span class="params">(GL10 gl, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onSurfaceChanged(gl, width, height);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onFilterChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onFilterChanged();</span><br><span class="line">        mOesTextureFilter.onInputSizeChanged(imageWidth, imageHeight);</span><br><span class="line">        mOesTextureFilter.onDisplaySizeChanged(surfaceWidth, surfaceHeight);</span><br><span class="line">        mOesTextureFilter.initFrameBuffers(imageWidth, imageHeight);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDrawFrame</span><span class="params">(GL10 gl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDrawFrame(gl);</span><br><span class="line">        <span class="keyword">if</span> (mSurfaceTexture == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        mSurfaceTexture.updateTexImage();</span><br><span class="line">        <span class="keyword">float</span>[] mtx = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">16</span>];</span><br><span class="line">        mSurfaceTexture.getTransformMatrix(mtx);</span><br><span class="line">        mOesTextureFilter.setTextureTransformMatrix(mtx);</span><br><span class="line">        <span class="keyword">int</span> id;</span><br><span class="line">        <span class="keyword">if</span> (mFilter == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mOesTextureFilter.onDrawFrame(textureId, gLCubeBuffer, gLTextureBuffer);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            id = mOesTextureFilter.onDrawToTexture(textureId);</span><br><span class="line">            mFilter.onDrawFrame(id, gLCubeBuffer, gLTextureBuffer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SurfaceTexture.OnFrameAvailableListener onFrameAvailableListener = <span class="keyword">new</span> SurfaceTexture.OnFrameAvailableListener() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFrameAvailable</span><span class="params">(SurfaceTexture surfaceTexture)</span> </span>&#123;</span><br><span class="line">            requestRender();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">        <span class="keyword">int</span> width = MeasureSpec.getSize(widthMeasureSpec);</span><br><span class="line">        <span class="keyword">int</span> height = MeasureSpec.getSize(heightMeasureSpec);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == mRatioWidth || <span class="number">0</span> == mRatioHeight) &#123;</span><br><span class="line">            setMeasuredDimension(width, height);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (width &lt; height * mRatioWidth / mRatioHeight) &#123;</span><br><span class="line">                setMeasuredDimension(width, width * mRatioHeight / mRatioWidth);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                setMeasuredDimension(height * mRatioWidth / mRatioHeight, height);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OesTextureFilter是一个简单的接受外部纹理的Filter，其片段着色器如下：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#extension GL_OES_EGL_image_external : require</span></span><br><span class="line"><span class="keyword">precision</span> <span class="keyword">mediump</span> <span class="type">float</span>;</span><br><span class="line"><span class="keyword">uniform</span> samplerExternalOES sTexture;</span><br><span class="line"><span class="keyword">varying</span> <span class="type">vec2</span> textureCoordinate;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main () &#123;</span><br><span class="line">    <span class="built_in">gl_FragColor</span> = <span class="built_in">texture2D</span>(sTexture, textureCoordinate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>samplerExternalOES定义扩展的纹理取样器，用于接受相机传入的纹理。</p><p>CameraSurfaceView最上继承自GLSurfaceView,先看关键onSurfaceCreated方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">textureId = OpenGlUtils.getExternalOESTextureID();</span><br><span class="line"><span class="keyword">if</span> (textureId != OpenGlUtils.NO_TEXTURE) &#123;</span><br><span class="line">    mSurfaceTexture = <span class="keyword">new</span> SurfaceTexture(textureId);</span><br><span class="line">    <span class="keyword">if</span> (mSurfaceTextureListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mSurfaceTextureListener.onAvailable();</span><br><span class="line">    &#125;</span><br><span class="line">    mSurfaceTexture.setOnFrameAvailableListener(onFrameAvailableListener);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在onSurfaceCreated时，创建一个OESTextureId,用于创建SurfaceTexture,mSurfaceTexture在刷新时使GLSurfaceView刷新，从而调用onDrawFrame方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDrawFrame</span><span class="params">(GL10 gl)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onDrawFrame(gl);</span><br><span class="line">    <span class="keyword">if</span> (mSurfaceTexture == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    mSurfaceTexture.updateTexImage();</span><br><span class="line">    <span class="keyword">float</span>[] mtx = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">16</span>];</span><br><span class="line">    mSurfaceTexture.getTransformMatrix(mtx);</span><br><span class="line">    mOesTextureFilter.setTextureTransformMatrix(mtx);</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">if</span> (mFilter == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mOesTextureFilter.onDrawFrame(textureId, gLCubeBuffer, gLTextureBuffer);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        id = mOesTextureFilter.onDrawToTexture(textureId);</span><br><span class="line">        mFilter.onDrawFrame(id, gLCubeBuffer, gLTextureBuffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>onDrawFrame时mOesTextureFilter获取到SurfaceTexture的位置转换，保持和相机显示的一直，如果没有滤镜直接使用OesTextureFilter绘制textureId，如果有滤镜则用OesTextureFilter绘制textureId到一个新的纹理上，再使用滤镜mFilter绘制这个新的id。<br>BaseSurfaceView中主要是基础控制，位置坐标方向渲染模式等。</p><h3 id="相机拍照"><a href="#相机拍照" class="headerlink" title="相机拍照"></a>相机拍照</h3><p>相机拍照有两种方式：<br>1.录屏：  使用OpenGL的readPixel方法，所见即所得，图片最大是屏幕大小，画质较差<br>2.调用底层拍照： 像素高，有滤镜等修改的话需要加后处理</p><p>我这里用的是方法2，主要是为了尝试新的东西，如果具体产品的要根据需求来，一般三方相机各种贴纸滤镜美颜处理用录屏的多，能所见即所得，也更快捷。</p><p>CameraFragment中请求拍照代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">lockFocus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// This is how to tell the camera to lock focus.</span></span><br><span class="line">        mPreviewRequestBuilder.set(CaptureRequest.CONTROL_AF_TRIGGER,</span><br><span class="line">                CameraMetadata.CONTROL_AF_TRIGGER_START);</span><br><span class="line">        <span class="comment">// Tell #mCaptureCallback to wait for the lock.</span></span><br><span class="line">        mState = STATE_WAITING_LOCK;</span><br><span class="line">        mCaptureSession.capture(mPreviewRequestBuilder.build(), mCaptureCallback,</span><br><span class="line">                mBackgroundHandler);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CameraAccessException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相机api2增加了状态，可以锁住预览然后进行拍照，api1预览，拍照，录像各是一种模式，需要切换。<br>拍照完成后在监听里回调：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ImageReader.OnImageAvailableListener mOnImageAvailableListener</span><br><span class="line">        = <span class="keyword">new</span> ImageReader.OnImageAvailableListener() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onImageAvailable</span><span class="params">(ImageReader reader)</span> </span>&#123;</span><br><span class="line">        mFile = <span class="keyword">new</span> File(getActivity().getExternalFilesDir(<span class="keyword">null</span>), <span class="string">"pic-"</span> + System.currentTimeMillis() / <span class="number">1000</span> + <span class="string">".jpg"</span>);</span><br><span class="line">        mBackgroundHandler.post(<span class="keyword">new</span> ImageSaver(reader.acquireNextImage(), mFile, mCameraSurfaceView.getFilter()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里生成了一个新的File，通过reader.acquireNextImage()拿到了一个image对象，里面有我们要的原始图片，然后发一个任务去保存照片：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageSaver</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * The JPEG image</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">final</span> Image mImage;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * The file we save the image into.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">final</span> File mFile;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">final</span> GPUImageFilter mFilter;</span><br><span class="line"></span><br><span class="line">       ImageSaver(Image image, File file, GPUImageFilter filter) &#123;</span><br><span class="line">           mImage = image;</span><br><span class="line">           mFile = file;</span><br><span class="line">           mFilter = filter;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           ByteBuffer buffer = mImage.getPlanes()[<span class="number">0</span>].getBuffer();</span><br><span class="line">           <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[buffer.remaining()];</span><br><span class="line">           buffer.get(bytes);</span><br><span class="line">           <span class="keyword">if</span> (mFilter != <span class="keyword">null</span>) &#123;</span><br><span class="line">               Bitmap bitmap = BitmapFactory.decodeByteArray(bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">               mImage.close();</span><br><span class="line">               SaveUtils.saveBitmap(FilterSDK.sContext, bitmap, mFilter, mFile);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               FileOutputStream output = <span class="keyword">null</span>;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   output = <span class="keyword">new</span> FileOutputStream(mFile);</span><br><span class="line">                   output.write(bytes);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                   mImage.close();</span><br><span class="line">                   <span class="keyword">if</span> (<span class="keyword">null</span> != output) &#123;</span><br><span class="line">                       <span class="keyword">try</span> &#123;</span><br><span class="line">                           output.close();</span><br><span class="line">                       &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                           e.printStackTrace();</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>解析出原图后，如果没有滤镜直接保存了，有滤镜则需要做滤镜处理再保存：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">saveBitmap</span><span class="params">(Context context, Bitmap bitmap, GPUImageFilter filter, File file)</span> </span>&#123;</span><br><span class="line">    GPUImage gpuImage = <span class="keyword">new</span> GPUImage(context);</span><br><span class="line">    gpuImage.setFilter(filter);</span><br><span class="line">    bitmap = Bitmaps.ensureBitmapSize(bitmap);</span><br><span class="line">    gpuImage.setImage(bitmap);</span><br><span class="line">    bitmap = gpuImage.getBitmapWithFilterApplied(<span class="keyword">true</span>);</span><br><span class="line">    FileOutputStream output = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        output = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">        bitmap.compress(Bitmap.CompressFormat.JPEG, <span class="number">100</span>, output);</span><br><span class="line">        output.flush();</span><br><span class="line">        bitmap.recycle();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != output) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                output.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用GPUImage做滤镜处理，使用getBitmapWithFilterApplied获取到新的Bitmap。GPUImage内部用的是离屏渲染，做了一次OpenGL绘制然后ReadPixel，<br>OpenGL处理有大小限制，做了一次ensureBitmapSize,以前的手机经常不能超过4096，现在发现都到16384，自用的小米Note3试的。</p><h3 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h3><p>demo里有二十多种Shader的效果，还实现了图片加滤镜的效果，图片保存等。更多细节可以在github看源码，还录了一个gif图展示效果在github上，欢迎star。<br><a href="https://github.com/myandy/shadertoyCamera" target="_blank" rel="noopener">https://github.com/myandy/shadertoyCamera</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个demo各方面挺完整了，相机API2的使用，滤镜GPUImage架构，还翻译了二十多个ShaderToy的着色器，半年前写的，这次总结梳理下，温故而知新，也希望大家看了能有所收获。<br>以后博客会更新频繁些，会写更多方面的东西。</p>]]></content>
    
    <summary type="html">
    
      基于Camera API2
    
    </summary>
    
    
      <category term="Android" scheme="http://anddymao.com/tags/Android/"/>
    
      <category term="OpenGL" scheme="http://anddymao.com/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>python爬虫抓取instagram信息</title>
    <link href="http://anddymao.com/2019/01/29/2019-1-29-python%E7%88%AC%E8%99%AB%E6%8A%93%E5%8F%96instagram%E4%BF%A1%E6%81%AF/"/>
    <id>http://anddymao.com/2019/01/29/2019-1-29-python爬虫抓取instagram信息/</id>
    <published>2019-01-29T04:00:00.000Z</published>
    <updated>2020-01-18T02:16:08.249Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>这是帮朋友弄的一个小东西，之前用python只有模拟网络请求的经验，但觉得这种需求应该不难，就答应做了。</p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>获取ins的很多信息需要先登录，google相关的东西基本都是抓取图片的，可用性不大。<br>想了两种方案，一种抓请求获取cookie再模拟获取评论的请求，直接获取到数据；另一种是抓取网页的方法，全模拟网页操作，抓取网页信息。<br>第一种很熟悉，所以我选择第二种入手。</p><h2 id="模拟网页操作获取信息"><a href="#模拟网页操作获取信息" class="headerlink" title="模拟网页操作获取信息"></a>模拟网页操作获取信息</h2><h3 id="模拟登录"><a href="#模拟登录" class="headerlink" title="模拟登录"></a>模拟登录</h3><p>网页上模拟点击我用的selenium，通过find_element_by_xpath等类方法获取到需要的元素，然后模拟操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> Firefox</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.keys <span class="keyword">import</span> Keys</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.firefox.options <span class="keyword">import</span> Options</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> expected</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.wait <span class="keyword">import</span> WebDriverWait</span><br><span class="line"></span><br><span class="line">login_url = <span class="string">"https://www.instagram.com/accounts/login/?source=auth_switcher"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">(user)</span>:</span></span><br><span class="line">    options = Options()</span><br><span class="line">    options.add_argument(<span class="string">'-headless'</span>)  <span class="comment"># 无头参数</span></span><br><span class="line">    driver = Firefox(firefox_options=options)  <span class="comment"># 配了环境变量第一个参数就可以省了，不然传绝对路径</span></span><br><span class="line">    wait = WebDriverWait(driver, timeout=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    driver.get(login_url)</span><br><span class="line">    driver.implicitly_wait(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">2</span>)</span><br><span class="line">    print(driver)</span><br><span class="line"></span><br><span class="line">    account = driver.find_element_by_xpath(<span class="string">"//input[@name='username']"</span>)</span><br><span class="line">    account.clear()</span><br><span class="line">    account.send_keys(user.get_account())</span><br><span class="line">    print(<span class="string">"账号输入完成!"</span>+user.get_account())</span><br><span class="line"></span><br><span class="line">    passwd = driver.find_element_by_xpath(<span class="string">"//input[@name='password']"</span>)</span><br><span class="line">    passwd.clear()</span><br><span class="line">    passwd.send_keys(user.get_password())</span><br><span class="line">    print(<span class="string">"密码输入完成!"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> (driver.title)</span><br><span class="line">    <span class="keyword">print</span> driver.current_url</span><br><span class="line"></span><br><span class="line">    button = driver.find_element_by_xpath(<span class="string">"//button[@type='submit']"</span>)</span><br><span class="line">    button.click()</span><br><span class="line">    print(<span class="string">"开始登陆!"</span>)</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> (driver.title)</span><br><span class="line">    <span class="keyword">print</span> driver.current_url</span><br></pre></td></tr></table></figure><p>登录成功后driver的title会发生变化，执行操作后需要等待几秒，模拟网页操作比较慢，这个就类似有一个真的网页给你操作，只是没有显示界面而已。</p><h3 id="获取关注用户"><a href="#获取关注用户" class="headerlink" title="获取关注用户"></a>获取关注用户</h3><p>在上一步之后继续操作，进去周杰伦的主页，然后再点击关注者，find_element_by_xpath可以通过标签属性来找到元素。<br>根据网页上的信息找出规则，然后就可以拿到想要的数据了。代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">driver.get(<span class="string">"https://www.instagram.com/jaychou/"</span>)</span><br><span class="line">sleep(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">print</span> (driver.title)</span><br><span class="line"><span class="keyword">print</span> driver.current_url</span><br><span class="line"></span><br><span class="line">button = driver.find_element_by_xpath(<span class="string">"//a[@href='/jaychou/followers/']"</span>)</span><br><span class="line">button.click()</span><br><span class="line">sleep(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">print</span> (driver.title)</span><br><span class="line"><span class="keyword">print</span> driver.current_url</span><br><span class="line"></span><br><span class="line">li = driver.find_elements_by_tag_name(<span class="string">"li"</span>)</span><br><span class="line"></span><br><span class="line">f = open(<span class="string">'f.txt'</span>,<span class="string">'a'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> li:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        a = i.find_element_by_tag_name(<span class="string">"a"</span>)</span><br><span class="line">        herf =  a.get_attribute(<span class="string">"href"</span>)</span><br><span class="line">        <span class="keyword">print</span> herf</span><br><span class="line"></span><br><span class="line">        datepat = re.compile(<span class="string">'^https://www.instagram.com/[^/]+/$'</span>)</span><br><span class="line">        <span class="keyword">if</span> datepat.match(herf):</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"add"</span></span><br><span class="line">            f.write(herf)</span><br><span class="line">            f.write(<span class="string">'\n'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"filter"</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"exception"</span></span><br><span class="line">        <span class="keyword">print</span> i</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><p>这里拿到list后，然后遍历节点，过滤出我们要的用户名后，写到文件里。</p><h2 id="模拟请求获取数据"><a href="#模拟请求获取数据" class="headerlink" title="模拟请求获取数据"></a>模拟请求获取数据</h2><p>尝试获取评论里的用户，获取评论信息在一个小的弹窗里，一页只显示几十条条数据，再获取更多需要模拟弹窗的滑动，没有找到对应的方法。想想这里还是用模拟请求来获取数据。</p><h3 id="获取cookie"><a href="#获取cookie" class="headerlink" title="获取cookie"></a>获取cookie</h3><p>在前面的模拟网页登录后后可以获取cookie信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cookie = [item[<span class="string">"name"</span>] + <span class="string">"="</span> + item[<span class="string">"value"</span>] <span class="keyword">for</span> item <span class="keyword">in</span> driver.get_cookies()]</span><br><span class="line">cookiestr = <span class="string">';'</span>.join(item <span class="keyword">for</span> item <span class="keyword">in</span> cookie)</span><br><span class="line"><span class="keyword">print</span> cookiestr</span><br></pre></td></tr></table></figure><p>另外也可以通过抓包获取cookie</p><h3 id="分析评论请求"><a href="#分析评论请求" class="headerlink" title="分析评论请求"></a>分析评论请求</h3><p>F12网页开发模式下，进行操作请求后可以在network里看到相关请求，找到获取评论列表的请求，url如下：<br><a href="https://www.instagram.com/graphql/query/?query_hash=2cc8bfb89429345060d1212147913582&amp;variables=%7B%22shortcode%22%3A%22BrCsJRUH2kV%22%2C%22child_comment_count%22%3A3%2C%22fetch_comment_count%22%3A40%2C%22parent_comment_count%22%3A24%2C%22has_threaded_comments%22%3Afalse%7D" target="_blank" rel="noopener">https://www.instagram.com/graphql/query/?query_hash=2cc8bfb89429345060d1212147913582&amp;variables=%7B%22shortcode%22%3A%22BrCsJRUH2kV%22%2C%22child_comment_count%22%3A3%2C%22fetch_comment_count%22%3A40%2C%22parent_comment_count%22%3A24%2C%22has_threaded_comments%22%3Afalse%7D</a><br>解析出来就是：<br><a href="https://www.instagram.com/graphql/query/?query_hash=2cc8bfb89429345060d1212147913582&amp;variables={&quot;shortcode&quot;:&quot;{BrCsJRUH2kV}&quot;,&quot;child_comment_count&quot;:3,&quot;fetch_comment_count&quot;:40,&quot;parent_comment_count&quot;:24,&quot;has_threaded_comments&quot;:false}" target="_blank" rel="noopener">https://www.instagram.com/graphql/query/?query_hash=2cc8bfb89429345060d1212147913582&amp;variables={&quot;shortcode&quot;:&quot;{BrCsJRUH2kV}&quot;,&quot;child_comment_count&quot;:3,&quot;fetch_comment_count&quot;:40,&quot;parent_comment_count&quot;:24,&quot;has_threaded_comments&quot;:false}</a></p><p>在对比获取其它帖子的评论知道变化的信息只有shortcode，知道了根据shortcode就可以获取到帖子的评论详情，fetch_comment_count可以改变获取评论的数量。</p><p>shortcode很容易在网页信息里找到，这样我们就能批量快速获取评论信息了。</p><h3 id="模拟获取评论请求"><a href="#模拟获取评论请求" class="headerlink" title="模拟获取评论请求"></a>模拟获取评论请求</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib2</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">cookiestr = <span class="string">"rur=FTW;mid=XD3cGQAEAAGlLkr5xZhGKXK6kdRC;mcd=3;sessionid=9961092202%3ATHPRPTOYnzHmKp%3A11;ds_user_id=9961092202;csrftoken=mx3RYvRa54z842Br8qtWwMkv40sJ7Gvn;urlgen=\"&#123;\"43.224.245.181\": 63855&#125;:1gjOVb:CxD9xU20ZPDIJm6pEBP8db7WXnU\""</span></span><br><span class="line">url = <span class="string">"https://www.instagram.com/graphql/query/?query_hash=2cc8bfb89429345060d1212147913582&amp;variables=%7B%22shortcode%22%3A%22&#123;shortcode&#125;%22%2C%22child_comment_count%22%3A3%2C%22fetch_comment_count%22%3A40%2C%22parent_comment_count%22%3A24%2C%22has_threaded_comments%22%3Afalse%7D"</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getComments</span><span class="params">(shortcode)</span>:</span></span><br><span class="line">    commetUrl = url.format(shortcode=shortcode)</span><br><span class="line">    headers = &#123;<span class="string">'cookie'</span>:cookiestr&#125;</span><br><span class="line">    req = urllib2.Request(commetUrl, headers = headers)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = urllib2.urlopen(req)</span><br><span class="line">        text = response.read()</span><br><span class="line">        jsonobj = json.loads(text)</span><br><span class="line">        <span class="keyword">print</span> text</span><br><span class="line">        <span class="comment">#getData(jsonobj)</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"except"</span></span><br><span class="line">getComments(<span class="string">"BrCsJRUH2kV"</span>)</span><br></pre></td></tr></table></figure><p>把前面获取到的cookiestr保存复制过来，请求的url的shortcode用{}包进占位符，然后就可以根据shortcode获取到评论数据了。</p><h3 id="解析并保存数据"><a href="#解析并保存数据" class="headerlink" title="解析并保存数据"></a>解析并保存数据</h3><p>把前面的getData方法注释打开，getData方法如下:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getData</span><span class="params">(jsonobj)</span>:</span></span><br><span class="line">    comments = jsonobj[<span class="string">"data"</span>][<span class="string">"shortcode_media"</span>][<span class="string">"edge_media_to_comment"</span>][<span class="string">"edges"</span>]</span><br><span class="line"></span><br><span class="line">    f = open(<span class="string">'commentsUser.txt'</span>,<span class="string">'a'</span>)</span><br><span class="line">    <span class="keyword">for</span> comm <span class="keyword">in</span> comments:</span><br><span class="line">        user = comm[<span class="string">"node"</span>][<span class="string">"owner"</span>]</span><br><span class="line">        name = user[<span class="string">"username"</span>]</span><br><span class="line">        id = user[<span class="string">"id"</span>]</span><br><span class="line">        f.write(name+<span class="string">":"</span>+id)</span><br><span class="line">        f.write(<span class="string">'\n'</span>)</span><br><span class="line">        <span class="keyword">print</span> name</span><br><span class="line">    f.close()</span><br></pre></td></tr></table></figure></p><p>根据数据去解析json，然后把用户名和id保存在文件里</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>做爬虫在于分析网页信息，模拟网页操作理论上是万能的，模拟请求就会被各种限制，但模拟请求更高效快捷，如果能破解还是用模拟请求方便。</p>]]></content>
    
    <summary type="html">
    
      python模拟网页操作和模拟网络请求实践
    
    </summary>
    
    
      <category term="python" scheme="http://anddymao.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>基于FFmpeg的Android简易视频播放器</title>
    <link href="http://anddymao.com/2019/01/08/2019-1-8-%E5%9F%BA%E4%BA%8EFFmpeg%E7%9A%84Android%E7%AE%80%E6%98%93%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E5%99%A8/"/>
    <id>http://anddymao.com/2019/01/08/2019-1-8-基于FFmpeg的Android简易视频播放器/</id>
    <published>2019-01-08T04:00:00.000Z</published>
    <updated>2019-10-25T03:38:48.890Z</updated>
    
    <content type="html"><![CDATA[<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>一个视频文件到播放在屏幕上，主要有这几个步骤，<br>1.解封装，得到视频流和音频流；<br>2.解码 得到视频原始帧，一般是yuv格式数据；<br>3.渲染 把图像帧数据绘制到屏幕上</p><p>前两步使用FFmpeg解析，渲软使用native window操纵界面显示,下面来自己动手试试。</p><h2 id="视频解码"><a href="#视频解码" class="headerlink" title="视频解码"></a>视频解码</h2><p>FFmpeg解码视频步骤：<br>1.av_register_all 注册初始化<br>2.avformat_open_input 打开文件<br>3.av_find_stream_info 查找流信息<br>4.avcode_find_decoder 获取解码器<br>5.avcode_open 打开解码器<br>6.av_read_frame 读取帧</p><p>FFmpeg的方法名都带av即audio and video，都是同时支持音视频的。</p><p>视频解码代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line">JNIEXPORT jint JNICALL Java_com_anddymao_ffmpegdemo_MainActivity_decode</span><br><span class="line">  (JNIEnv *env, jobject obj, jstring input_jstr, jstring output_jstr)</span><br><span class="line">&#123;</span><br><span class="line">AVFormatContext*pFormatCtx;</span><br><span class="line">inti, videoindex;</span><br><span class="line">AVCodecContext*pCodecCtx;</span><br><span class="line">AVCodec*pCodec;</span><br><span class="line">AVFrame*pFrame,*pFrameYUV;</span><br><span class="line">uint8_t *out_buffer;</span><br><span class="line">AVPacket *packet;</span><br><span class="line">int y_size;</span><br><span class="line">int ret, got_picture;</span><br><span class="line">struct SwsContext *img_convert_ctx;</span><br><span class="line">FILE *fp_yuv;</span><br><span class="line">int frame_cnt;</span><br><span class="line">clock_t time_start, time_finish;</span><br><span class="line">double  time_duration = 0.0;</span><br><span class="line"></span><br><span class="line">char input_str[500]=&#123;0&#125;;</span><br><span class="line">char output_str[500]=&#123;0&#125;;</span><br><span class="line">char info[1000]=&#123;0&#125;;</span><br><span class="line">sprintf(input_str,&quot;%s&quot;,(*env)-&gt;GetStringUTFChars(env,input_jstr, NULL));</span><br><span class="line">sprintf(output_str,&quot;%s&quot;,(*env)-&gt;GetStringUTFChars(env,output_jstr, NULL));</span><br><span class="line"></span><br><span class="line">//FFmpeg av_log() callback</span><br><span class="line">  av_log_set_callback(custom_log);</span><br><span class="line"></span><br><span class="line">av_register_all();</span><br><span class="line">avformat_network_init();</span><br><span class="line">pFormatCtx = avformat_alloc_context();</span><br><span class="line"></span><br><span class="line">if(avformat_open_input(&amp;pFormatCtx,input_str,NULL,NULL)!=0)&#123;</span><br><span class="line">LOGE(&quot;Couldn&apos;t open input stream.\n&quot;);</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">if(avformat_find_stream_info(pFormatCtx,NULL)&lt;0)&#123;</span><br><span class="line">LOGE(&quot;Couldn&apos;t find stream information.\n&quot;);</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">videoindex=-1;</span><br><span class="line">for(i=0; i&lt;pFormatCtx-&gt;nb_streams; i++)</span><br><span class="line">if(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==AVMEDIA_TYPE_VIDEO)&#123;</span><br><span class="line">videoindex=i;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">if(videoindex==-1)&#123;</span><br><span class="line">LOGE(&quot;Couldn&apos;t find a video stream.\n&quot;);</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">pCodecCtx=pFormatCtx-&gt;streams[videoindex]-&gt;codec;</span><br><span class="line">pCodec=avcodec_find_decoder(pCodecCtx-&gt;codec_id);</span><br><span class="line">if(pCodec==NULL)&#123;</span><br><span class="line">LOGE(&quot;Couldn&apos;t find Codec.\n&quot;);</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">if(avcodec_open2(pCodecCtx, pCodec,NULL)&lt;0)&#123;</span><br><span class="line">LOGE(&quot;Couldn&apos;t open codec.\n&quot;);</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pFrame=av_frame_alloc();</span><br><span class="line">pFrameYUV=av_frame_alloc();</span><br><span class="line">out_buffer=(unsigned char *)av_malloc(av_image_get_buffer_size(AV_PIX_FMT_YUV420P,  pCodecCtx-&gt;width, pCodecCtx-&gt;height,1));</span><br><span class="line">av_image_fill_arrays(pFrameYUV-&gt;data, pFrameYUV-&gt;linesize,out_buffer,</span><br><span class="line">AV_PIX_FMT_YUV420P,pCodecCtx-&gt;width, pCodecCtx-&gt;height,1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">packet=(AVPacket *)av_malloc(sizeof(AVPacket));</span><br><span class="line"></span><br><span class="line">img_convert_ctx = sws_getContext(pCodecCtx-&gt;width, pCodecCtx-&gt;height, pCodecCtx-&gt;pix_fmt,</span><br><span class="line">pCodecCtx-&gt;width, pCodecCtx-&gt;height, AV_PIX_FMT_YUV420P, SWS_BICUBIC, NULL, NULL, NULL);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  sprintf(info,   &quot;[Input     ]%s\n&quot;, input_str);</span><br><span class="line">  sprintf(info, &quot;%s[Output    ]%s\n&quot;,info,output_str);</span><br><span class="line">  sprintf(info, &quot;%s[Format    ]%s\n&quot;,info, pFormatCtx-&gt;iformat-&gt;name);</span><br><span class="line">  sprintf(info, &quot;%s[Codec     ]%s\n&quot;,info, pCodecCtx-&gt;codec-&gt;name);</span><br><span class="line">  sprintf(info, &quot;%s[Resolution]%dx%d\n&quot;,info, pCodecCtx-&gt;width,pCodecCtx-&gt;height);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  fp_yuv=fopen(output_str,&quot;wb+&quot;);</span><br><span class="line">  if(fp_yuv==NULL)&#123;</span><br><span class="line">printf(&quot;Cannot open output file.\n&quot;);</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">frame_cnt=0;</span><br><span class="line">time_start = clock();</span><br><span class="line"></span><br><span class="line">while(av_read_frame(pFormatCtx, packet)&gt;=0)&#123;</span><br><span class="line">if(packet-&gt;stream_index==videoindex)&#123;</span><br><span class="line">ret = avcodec_decode_video2(pCodecCtx, pFrame, &amp;got_picture, packet);</span><br><span class="line">if(ret &lt; 0)&#123;</span><br><span class="line">LOGE(&quot;Decode Error.\n&quot;);</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">if(got_picture)&#123;</span><br><span class="line">sws_scale(img_convert_ctx, (const uint8_t* const*)pFrame-&gt;data, pFrame-&gt;linesize, 0, pCodecCtx-&gt;height,</span><br><span class="line">pFrameYUV-&gt;data, pFrameYUV-&gt;linesize);</span><br><span class="line"></span><br><span class="line">y_size=pCodecCtx-&gt;width*pCodecCtx-&gt;height;</span><br><span class="line">fwrite(pFrameYUV-&gt;data[0],1,y_size,fp_yuv);    //Y</span><br><span class="line">fwrite(pFrameYUV-&gt;data[1],1,y_size/4,fp_yuv);  //U</span><br><span class="line">fwrite(pFrameYUV-&gt;data[2],1,y_size/4,fp_yuv);  //V</span><br><span class="line">//Output info</span><br><span class="line">char pictype_str[10]=&#123;0&#125;;</span><br><span class="line">switch(pFrame-&gt;pict_type)&#123;</span><br><span class="line">case AV_PICTURE_TYPE_I:sprintf(pictype_str,&quot;I&quot;);break;</span><br><span class="line">  case AV_PICTURE_TYPE_P:sprintf(pictype_str,&quot;P&quot;);break;</span><br><span class="line">case AV_PICTURE_TYPE_B:sprintf(pictype_str,&quot;B&quot;);break;</span><br><span class="line">default:sprintf(pictype_str,&quot;Other&quot;);break;</span><br><span class="line">&#125;</span><br><span class="line">LOGI(&quot;Frame Index: %5d. Type:%s&quot;,frame_cnt,pictype_str);</span><br><span class="line">frame_cnt++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">av_free_packet(packet);</span><br><span class="line">&#125;</span><br><span class="line">//flush decoder</span><br><span class="line">//FIX: Flush Frames remained in Codec</span><br><span class="line">while (1) &#123;</span><br><span class="line">ret = avcodec_decode_video2(pCodecCtx, pFrame, &amp;got_picture, packet);</span><br><span class="line">if (ret &lt; 0)</span><br><span class="line">break;</span><br><span class="line">if (!got_picture)</span><br><span class="line">break;</span><br><span class="line">sws_scale(img_convert_ctx, (const uint8_t* const*)pFrame-&gt;data, pFrame-&gt;linesize, 0, pCodecCtx-&gt;height,</span><br><span class="line">pFrameYUV-&gt;data, pFrameYUV-&gt;linesize);</span><br><span class="line">int y_size=pCodecCtx-&gt;width*pCodecCtx-&gt;height;</span><br><span class="line">fwrite(pFrameYUV-&gt;data[0],1,y_size,fp_yuv);    //Y</span><br><span class="line">fwrite(pFrameYUV-&gt;data[1],1,y_size/4,fp_yuv);  //U</span><br><span class="line">fwrite(pFrameYUV-&gt;data[2],1,y_size/4,fp_yuv);  //V</span><br><span class="line">//Output info</span><br><span class="line">char pictype_str[10]=&#123;0&#125;;</span><br><span class="line">switch(pFrame-&gt;pict_type)&#123;</span><br><span class="line">case AV_PICTURE_TYPE_I:sprintf(pictype_str,&quot;I&quot;);break;</span><br><span class="line">  case AV_PICTURE_TYPE_P:sprintf(pictype_str,&quot;P&quot;);break;</span><br><span class="line">case AV_PICTURE_TYPE_B:sprintf(pictype_str,&quot;B&quot;);break;</span><br><span class="line">default:sprintf(pictype_str,&quot;Other&quot;);break;</span><br><span class="line">&#125;</span><br><span class="line">LOGI(&quot;Frame Index: %5d. Type:%s&quot;,frame_cnt,pictype_str);</span><br><span class="line">frame_cnt++;</span><br><span class="line">&#125;</span><br><span class="line">time_finish = clock();</span><br><span class="line">time_duration=(double)(time_finish - time_start);</span><br><span class="line"></span><br><span class="line">sprintf(info, &quot;%s[Time      ]%fms\n&quot;,info,time_duration);</span><br><span class="line">sprintf(info, &quot;%s[Count     ]%d\n&quot;,info,frame_cnt);</span><br><span class="line"></span><br><span class="line">sws_freeContext(img_convert_ctx);</span><br><span class="line"></span><br><span class="line">  fclose(fp_yuv);</span><br><span class="line"></span><br><span class="line">av_frame_free(&amp;pFrameYUV);</span><br><span class="line">av_frame_free(&amp;pFrame);</span><br><span class="line">avcodec_close(pCodecCtx);</span><br><span class="line">avformat_close_input(&amp;pFormatCtx);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是复制雷神的源码，解码成流后保存到文件中，改到自己工程试了没有问题，注意下读写权限就可以了。</p><p>这里解析出视频帧后打印了视频帧的类型（I，P，B帧）<br>源码在<a href="https://github.com/leixiaohua1020/simplest_ffmpeg_mobile" target="_blank" rel="noopener">https://github.com/leixiaohua1020/simplest_ffmpeg_mobile</a></p><h2 id="视频播放"><a href="#视频播放" class="headerlink" title="视频播放"></a>视频播放</h2><h3 id="底层代码"><a href="#底层代码" class="headerlink" title="底层代码"></a>底层代码</h3><p>视频播放在解码之后需要增加渲软的工作，在c里面用native window就可以对应到java的surface。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">ANativeWindow *nativeWindow;</span><br><span class="line">ANativeWindow_Buffer windowBuffer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">JNIEXPORT jint JNICALL Java_com_anddymao_ffmpegdemo_MainActivity_play</span><br><span class="line">        (JNIEnv *env, jobject obj, jstring input_jstr, jobject surface) &#123;</span><br><span class="line">    AVFormatContext *pFormatCtx;</span><br><span class="line">    int i, videoindex;</span><br><span class="line">    AVCodecContext *pCodecCtx;</span><br><span class="line">    AVCodec *pCodec;</span><br><span class="line">    struct SwsContext *img_convert_ctx;</span><br><span class="line"></span><br><span class="line">    char input_str[500] = &#123;0&#125;;</span><br><span class="line">    sprintf(input_str, &quot;%s&quot;, (*env)-&gt;GetStringUTFChars(env, input_jstr, NULL));</span><br><span class="line"></span><br><span class="line">    av_register_all();</span><br><span class="line">    avformat_network_init();</span><br><span class="line">    pFormatCtx = avformat_alloc_context();</span><br><span class="line"></span><br><span class="line">    if (avformat_open_input(&amp;pFormatCtx, input_str, NULL, NULL) != 0) &#123;</span><br><span class="line">        LOGE(&quot;Couldn&apos;t open input stream.\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    if (avformat_find_stream_info(pFormatCtx, NULL) &lt; 0) &#123;</span><br><span class="line">        LOGE(&quot;Couldn&apos;t find stream information.\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    videoindex = -1;</span><br><span class="line">    for (i = 0; i &lt; pFormatCtx-&gt;nb_streams; i++)</span><br><span class="line">        if (pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type == AVMEDIA_TYPE_VIDEO) &#123;</span><br><span class="line">            videoindex = i;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    if (videoindex == -1) &#123;</span><br><span class="line">        LOGE(&quot;Couldn&apos;t find a video stream.\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    pCodecCtx = pFormatCtx-&gt;streams[videoindex]-&gt;codec;</span><br><span class="line">    pCodec = avcodec_find_decoder(pCodecCtx-&gt;codec_id);</span><br><span class="line">    if (pCodec == NULL) &#123;</span><br><span class="line">        LOGE(&quot;Couldn&apos;t find Codec.\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    if (avcodec_open2(pCodecCtx, pCodec, NULL) &lt; 0) &#123;</span><br><span class="line">        LOGE(&quot;Couldn&apos;t open codec.\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取界面传下来的surface</span><br><span class="line">    nativeWindow = ANativeWindow_fromSurface(env, surface);</span><br><span class="line">    if (0 == nativeWindow) &#123;</span><br><span class="line">        LOGE(&quot;Couldn&apos;t get native window from surface.\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    int width = pCodecCtx-&gt;width;</span><br><span class="line">    int height = pCodecCtx-&gt;height;</span><br><span class="line">    //分配一个帧指针，指向解码后的原始帧</span><br><span class="line">    AVFrame *vFrame = av_frame_alloc();</span><br><span class="line">    AVPacket *vPacket = (AVPacket *) av_malloc(sizeof(AVPacket));</span><br><span class="line">    AVFrame *pFrameRGBA = av_frame_alloc();</span><br><span class="line"></span><br><span class="line">    img_convert_ctx = sws_getContext(width, height, pCodecCtx-&gt;pix_fmt,</span><br><span class="line">                                     width, height, AV_PIX_FMT_RGBA, SWS_BICUBIC, NULL, NULL, NULL);</span><br><span class="line">    if (0 &gt;</span><br><span class="line">        ANativeWindow_setBuffersGeometry(nativeWindow, width, height, WINDOW_FORMAT_RGBA_8888)) &#123;</span><br><span class="line">        LOGE(&quot;Couldn&apos;t set buffers geometry.\n&quot;);</span><br><span class="line">        ANativeWindow_release(nativeWindow);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //读取帧</span><br><span class="line">    while (av_read_frame(pFormatCtx, vPacket) &gt;= 0) &#123;</span><br><span class="line">        if (vPacket-&gt;stream_index == videoindex) &#123;</span><br><span class="line">            //视频解码</span><br><span class="line">            int ret = avcodec_send_packet(pCodecCtx, vPacket);</span><br><span class="line">            if (ret &lt; 0 &amp;&amp; ret != AVERROR(EAGAIN) &amp;&amp; ret != AVERROR_EOF) &#123;</span><br><span class="line">                LOGE(&quot;video avcodec_send_packet error %d&quot;, ret);</span><br><span class="line">                return -1;</span><br><span class="line">            &#125;</span><br><span class="line">            ret = avcodec_receive_frame(pCodecCtx, vFrame);</span><br><span class="line">            if (ret &lt; 0 &amp;&amp; ret != AVERROR_EOF) &#123;</span><br><span class="line">                LOGE(&quot;video avcodec_receive_frame error %d&quot;, ret);</span><br><span class="line">                av_packet_unref(vPacket);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            //转化格式</span><br><span class="line">            sws_scale(img_convert_ctx, (const uint8_t *const *) vFrame-&gt;data, vFrame-&gt;linesize, 0,</span><br><span class="line">                      pCodecCtx-&gt;height,</span><br><span class="line">                      pFrameRGBA-&gt;data, pFrameRGBA-&gt;linesize);</span><br><span class="line">            if (ANativeWindow_lock(nativeWindow, &amp;windowBuffer, NULL) &lt; 0) &#123;</span><br><span class="line">                LOGE(&quot;cannot lock window&quot;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                av_image_fill_arrays(pFrameRGBA-&gt;data, pFrameRGBA-&gt;linesize,</span><br><span class="line">                                     (const uint8_t *) windowBuffer.bits, AV_PIX_FMT_RGBA,</span><br><span class="line">                                     width, height, 1);</span><br><span class="line">                ANativeWindow_unlockAndPost(nativeWindow);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        av_packet_unref(vPacket);</span><br><span class="line">    &#125;</span><br><span class="line">    //释放内存</span><br><span class="line">    sws_freeContext(img_convert_ctx);</span><br><span class="line">    av_free(vPacket);</span><br><span class="line">    av_free(pFrameRGBA);</span><br><span class="line">    avcodec_close(pCodecCtx);</span><br><span class="line">    avformat_close_input(&amp;pFormatCtx);</span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开始在avcodec_receive_frame这边返回了错误，改成continue就可以了，使用cmake可以很方便的调试native代码。</p><h3 id="Java层调用"><a href="#Java层调用" class="headerlink" title="Java层调用"></a>Java层调用</h3><p>java代码就非常简单，添加一个surfaceView，调用play方法就可以了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">        SurfaceView surfaceView = findViewById(R.id.surface_view);</span><br><span class="line">        surfaceView.getHolder().addCallback(new SurfaceHolder.Callback() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void surfaceCreated(final SurfaceHolder holder) &#123;</span><br><span class="line">                new Thread(new Runnable() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void run() &#123;</span><br><span class="line">                        play(inputurl, holder.getSurface());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).start();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void surfaceDestroyed(SurfaceHolder holder) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">public native int play(String inputurl, Surface surface);</span><br></pre></td></tr></table></figure><p>添加好文件权限，这个就可以播放了，只有图像的播放，没有控制播放速度，基本的流程就走通了。</p>]]></content>
    
    <summary type="html">
    
      自己动手写个视频播放器
    
    </summary>
    
    
      <category term="音视频" scheme="http://anddymao.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="FFmpeg" scheme="http://anddymao.com/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu下编译FFmpeg到Android使用</title>
    <link href="http://anddymao.com/2019/01/07/2019-1-7-Ubuntu%E4%B8%8B%E7%BC%96%E8%AF%91FFmpeg%E5%88%B0Android%E4%BD%BF%E7%94%A8/"/>
    <id>http://anddymao.com/2019/01/07/2019-1-7-Ubuntu下编译FFmpeg到Android使用/</id>
    <published>2019-01-07T04:00:00.000Z</published>
    <updated>2019-10-25T03:38:48.889Z</updated>
    
    <content type="html"><![CDATA[<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>最近学习音视频在底层的使用，那就必须研究FFmpeg,再次动手编译试试，用linux系统，可以事半功倍.<br>FFmpeg官网介绍是完全跨平台的音视频编解码解决方案。</p><h2 id="FFmpeg编译"><a href="#FFmpeg编译" class="headerlink" title="FFmpeg编译"></a>FFmpeg编译</h2><h3 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h3><p>Ubuntu 14.04<br>FFmpeg源码（3.2.1）<br>ndk(android-ndk-r14b)<br>AndroidStudio3.0</p><h3 id="下载FFmpeg源码"><a href="#下载FFmpeg源码" class="headerlink" title="下载FFmpeg源码"></a>下载FFmpeg源码</h3><p>在官网 <a href="https://ffmpeg.org/download.html#releases" target="_blank" rel="noopener">https://ffmpeg.org/download.html#releases</a> 下载源码解压到本地，先试了4.1版，编译时发现问题过多，按推荐使用了3.2.1版。3.X版应该都没有问题。</p><h3 id="修改configure文件"><a href="#修改configure文件" class="headerlink" title="修改configure文件"></a>修改configure文件</h3><p>这个是因为编译so的名称修改，android识别必须后缀为so。不改的话生成的so需要手动重命名。</p><pre><code>SLIBNAME_WITH_MAJOR=&apos;$(SLIBNAME).$(LIBMAJOR)&apos;LIB_INSTALL_EXTRA_CMD=&apos;$$(RANLIB)&quot;$(LIBDIR)/$(LIBNAME)&quot;&apos;SLIB_INSTALL_NAME=&apos;$(SLIBNAME_WITH_VERSION)&apos;SLIB_INSTALL_LINKS=&apos;$(SLIBNAME_WITH_MAJOR)$(SLIBNAME)&apos;</code></pre><p>替换成</p><pre><code>SLIBNAME_WITH_MAJOR=&apos;$(SLIBPREF)$(FULLNAME)-$(LIBMAJOR)$(SLIBSUF)&apos;LIB_INSTALL_EXTRA_CMD=&apos;$$(RANLIB)&quot;$(LIBDIR)/$(LIBNAME)&quot;&apos;SLIB_INSTALL_NAME=&apos;$(SLIBNAME_WITH_MAJOR)&apos;SLIB_INSTALL_LINKS=&apos;$(SLIBNAME)&apos;</code></pre><h3 id="编写脚本生成类库"><a href="#编写脚本生成类库" class="headerlink" title="编写脚本生成类库"></a>编写脚本生成类库</h3><p>在ffmpeg中创建一个build_android.sh的脚本，并赋予可执行的权限（chmod +x）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">make clean</span><br><span class="line">#填写你具体的ndk解压目录</span><br><span class="line">export NDK=/home/mi/Android/android-ndk-r14b</span><br><span class="line">export SYSROOT=$NDK/platforms/android-9/arch-arm/</span><br><span class="line">export TOOLCHAIN=$NDK/toolchains/arm-linux-androideabi-4.9/prebuilt/linux-x86_64</span><br><span class="line">export CPU=arm</span><br><span class="line">#编译后的文件会放置在 当前路径下的android/arm／下</span><br><span class="line">export PREFIX=$(pwd)/android/$CPU</span><br><span class="line">export ADDI_CFLAGS=&quot;-marm&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#./configure 即为ffmpeg 根目录下的可执行文件configure</span><br><span class="line">#你可以在ffmpeg根目录下使用./configure --hellp 查看 ./configure后可填入的参数。</span><br><span class="line"></span><br><span class="line">./configure --target-os=linux \</span><br><span class="line">        --prefix=$PREFIX --arch=arm \</span><br><span class="line">        --disable-doc \</span><br><span class="line">        --enable-shared \</span><br><span class="line">        --disable-static \</span><br><span class="line">        --disable-yasm \</span><br><span class="line">        --disable-symver \</span><br><span class="line">        --enable-gpl \</span><br><span class="line">        --disable-ffmpeg \</span><br><span class="line">        --disable-ffplay \</span><br><span class="line">        --disable-ffprobe \</span><br><span class="line">        --disable-ffserver \</span><br><span class="line">        --disable-doc \</span><br><span class="line">        --disable-symver \</span><br><span class="line">        --cross-prefix=$TOOLCHAIN/bin/arm-linux-androideabi- \</span><br><span class="line">        --enable-cross-compile \</span><br><span class="line">        --sysroot=$SYSROOT \</span><br><span class="line">        --extra-cflags=&quot;-Os -fpic $ADDI_CFLAGS&quot; \</span><br><span class="line">        --extra-ldflags=&quot;$ADDI_CFLAGS&quot; \</span><br><span class="line">        $ADDITIONAL_CONFIGURE_FLAG</span><br><span class="line">make clean</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>在当前目录./build_android.sh运行脚本，即可等待生成。最后成功的话可以在android/arm下看到include和lib，分别是ffmpeg的头文件和lib库。</p><h2 id="在android工程中使用"><a href="#在android工程中使用" class="headerlink" title="在android工程中使用"></a>在android工程中使用</h2><h3 id="创建Android工程"><a href="#创建Android工程" class="headerlink" title="创建Android工程"></a>创建Android工程</h3><p>创建一个支持C++的ffmpegdemo工程</p><h3 id="修改native-lib-cpp"><a href="#修改native-lib-cpp" class="headerlink" title="修改native-lib.cpp"></a>修改native-lib.cpp</h3><p>这里就添加一个FFmpeg的注册方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;jni.h&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot;</span><br><span class="line">&#123;</span><br><span class="line">#include &quot;libavformat/avformat.h&quot;</span><br><span class="line">&#125;</span><br><span class="line">extern &quot;C&quot;</span><br><span class="line">JNIEXPORT jstring</span><br><span class="line"></span><br><span class="line">JNICALL</span><br><span class="line">Java_com_anddymao_ffmpegdemo_MainActivity_stringFromJNI(</span><br><span class="line">        JNIEnv *env,</span><br><span class="line">        jobject /* this */) &#123;</span><br><span class="line"></span><br><span class="line">    av_register_all();</span><br><span class="line">    std::string hello = &quot;Hello,FFmpeg!&quot;;</span><br><span class="line">    return env-&gt;NewStringUTF(hello.c_str());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="添加lib"><a href="#添加lib" class="headerlink" title="添加lib"></a>添加lib</h3><p>在app/src/main下创建jniLibs目录，再创建include和armeabi文件夹，把头文件拷贝到include，把lib/arm下的so拷贝到armeabi。<br>一共是8个so文件，下面会在CMake中配置编译，都是一一对应。</p><h3 id="修改CMakeList"><a href="#修改CMakeList" class="headerlink" title="修改CMakeList"></a>修改CMakeList</h3><p>修改CMake中的编译信息，把ffmpeg添加的lib都添加为share library并链接进来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.4.1)</span><br><span class="line"></span><br><span class="line">add_library( # Sets the name of the library.</span><br><span class="line">             native-lib</span><br><span class="line"></span><br><span class="line">             # Sets the library as a shared library.</span><br><span class="line">             SHARED</span><br><span class="line"></span><br><span class="line">             # Provides a relative path to your source file(s).</span><br><span class="line">             src/main/cpp/native-lib.cpp</span><br><span class="line">           )</span><br><span class="line"></span><br><span class="line">find_library( # Sets the name of the path variable.</span><br><span class="line">              log-lib</span><br><span class="line">              log )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#声明导入文件更目录变量ARM_DIR</span><br><span class="line">set(ARM_DIR /home/mi/mediapro/FFmpegForAndroidDemo/app/src/main/jniLibs)</span><br><span class="line"></span><br><span class="line">#导入头文件</span><br><span class="line">include_directories(src/main/jniLibs/include)</span><br><span class="line"></span><br><span class="line">#添加动态库</span><br><span class="line">add_library(avcodec-57</span><br><span class="line">             SHARED</span><br><span class="line">             IMPORTED)</span><br><span class="line">#设置动态库路径</span><br><span class="line">set_target_properties(avcodec-57</span><br><span class="line">                      PROPERTIES IMPORTED_LOCATION</span><br><span class="line">                      $&#123;ARM_DIR&#125;/armeabi/libavcodec-57.so</span><br><span class="line">                        )</span><br><span class="line"></span><br><span class="line">add_library(avdevice-57</span><br><span class="line">            SHARED</span><br><span class="line">            IMPORTED)</span><br><span class="line">set_target_properties(avdevice-57</span><br><span class="line">                      PROPERTIES IMPORTED_LOCATION</span><br><span class="line">                      $&#123;ARM_DIR&#125;/armeabi/libavdevice-57.so)</span><br><span class="line">add_library(avformat-57</span><br><span class="line">            SHARED</span><br><span class="line">            IMPORTED)</span><br><span class="line">set_target_properties(avformat-57</span><br><span class="line">                      PROPERTIES IMPORTED_LOCATION</span><br><span class="line">                      $&#123;ARM_DIR&#125;/armeabi/libavformat-57.so)</span><br><span class="line">add_library(avutil-55</span><br><span class="line">            SHARED</span><br><span class="line">            IMPORTED)</span><br><span class="line">set_target_properties(avutil-55</span><br><span class="line">                      PROPERTIES IMPORTED_LOCATION</span><br><span class="line">                      $&#123;ARM_DIR&#125;/armeabi/libavutil-55.so)</span><br><span class="line">add_library(postproc-54</span><br><span class="line">            SHARED</span><br><span class="line">            IMPORTED)</span><br><span class="line">set_target_properties(postproc-54</span><br><span class="line">                      PROPERTIES IMPORTED_LOCATION</span><br><span class="line">                      $&#123;ARM_DIR&#125;/armeabi/libpostproc-54.so)</span><br><span class="line">add_library(swresample-2</span><br><span class="line">             SHARED</span><br><span class="line">             IMPORTED)</span><br><span class="line">set_target_properties(swresample-2</span><br><span class="line">                       PROPERTIES IMPORTED_LOCATION</span><br><span class="line">                       $&#123;ARM_DIR&#125;/armeabi/libswresample-2.so)</span><br><span class="line">add_library(swscale-4</span><br><span class="line">              SHARED</span><br><span class="line">              IMPORTED)</span><br><span class="line">set_target_properties(swscale-4</span><br><span class="line">                        PROPERTIES IMPORTED_LOCATION</span><br><span class="line">                        $&#123;ARM_DIR&#125;/armeabi/libswscale-4.so)</span><br><span class="line">add_library(avfilter-6</span><br><span class="line">              SHARED</span><br><span class="line">              IMPORTED)</span><br><span class="line">set_target_properties(avfilter-6</span><br><span class="line">                        PROPERTIES IMPORTED_LOCATION</span><br><span class="line">                        $&#123;ARM_DIR&#125;/armeabi/libavfilter-6.so)</span><br><span class="line"></span><br><span class="line">#其他so库与上相同格式添加</span><br><span class="line">#链接库</span><br><span class="line"></span><br><span class="line">target_link_libraries(</span><br><span class="line">                       native-lib</span><br><span class="line">                       avcodec-57</span><br><span class="line">                       avdevice-57</span><br><span class="line">                       avformat-57</span><br><span class="line">                       avfilter-6</span><br><span class="line">                       avutil-55</span><br><span class="line">                       postproc-54</span><br><span class="line">                       swresample-2</span><br><span class="line">                       swscale-4</span><br><span class="line">                       $&#123;log-lib&#125; )</span><br></pre></td></tr></table></figure><p>这里要注意native-lib只能放在第一个。</p><h3 id="修改build-gradle"><a href="#修改build-gradle" class="headerlink" title="修改build.gradle"></a>修改build.gradle</h3><p>abiFilters设置armeabi平台<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">externalNativeBuild &#123;</span><br><span class="line">    cmake &#123;</span><br><span class="line">        cppFlags &quot;-frtti -fexceptions&quot;</span><br><span class="line">        abiFilters &apos;armeabi&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后可以编译运行了，在android上看到”Hello,FFmpeg！”,说明编译成功了。</p>]]></content>
    
    <summary type="html">
    
      自己动手编译并使用FFmpeg
    
    </summary>
    
    
      <category term="音视频" scheme="http://anddymao.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="FFmpeg" scheme="http://anddymao.com/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>Android8.0相机源码深入解析(五)</title>
    <link href="http://anddymao.com/2018/06/13/2018-6-13-%E7%9B%B8%E6%9C%BA%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90(%E4%BA%94)/"/>
    <id>http://anddymao.com/2018/06/13/2018-6-13-相机源码深入解析(五)/</id>
    <published>2018-06-13T04:00:00.000Z</published>
    <updated>2019-10-25T03:38:48.887Z</updated>
    
    <content type="html"><![CDATA[<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>之前四篇介绍了相机流程,但都是基于api1的,在api2下相机整个重写了,虽然还有一部分流程相同,我们从打开相机来分析相机流程</p><h2 id="app层"><a href="#app层" class="headerlink" title="app层"></a>app层</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CameraManager manager = (CameraManager) activity.getSystemService(Context.CAMERA_SERVICE);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mCameraOpenCloseLock.tryAcquire(<span class="number">2500</span>, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Time out waiting to lock camera opening."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    manager.openCamera(String.valueOf(mCameraId), mStateCallback, mBackgroundHandler);</span><br><span class="line">&#125; <span class="keyword">catch</span> (CameraAccessException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Interrupted while trying to lock camera opening."</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先获取相机服务,然后通过CameraManager打开相机,相机api1多了状态回调</p><h2 id="framework层"><a href="#framework层" class="headerlink" title="framework层"></a>framework层</h2><p>相机api2framework的java代码在framework/base/code/java/android/hardware/camera2中,api1基本只有Camera.java一个类,新api有好几十个类.</p><h3 id="Camera2模块"><a href="#Camera2模块" class="headerlink" title="Camera2模块"></a>Camera2模块</h3><p>CameraManager中openCamera调用openCameraForUid,再调用openCameraDeviceUserAsync,这里是实际实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> CameraDevice <span class="title">openCameraDeviceUserAsync</span><span class="params">(String cameraId,</span></span></span><br><span class="line"><span class="function"><span class="params">        CameraDevice.StateCallback callback, Handler handler, <span class="keyword">final</span> <span class="keyword">int</span> uid)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> CameraAccessException </span>&#123;</span><br><span class="line">    CameraCharacteristics characteristics = getCameraCharacteristics(cameraId);</span><br><span class="line">    CameraDevice device = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line"></span><br><span class="line">        ICameraDeviceUser cameraUser = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        android.hardware.camera2.impl.CameraDeviceImpl deviceImpl =</span><br><span class="line">                <span class="keyword">new</span> android.hardware.camera2.impl.CameraDeviceImpl(</span><br><span class="line">                    cameraId,</span><br><span class="line">                    callback,</span><br><span class="line">                    handler,</span><br><span class="line">                    characteristics,</span><br><span class="line">                    mContext.getApplicationInfo().targetSdkVersion);</span><br><span class="line"></span><br><span class="line">        ICameraDeviceCallbacks callbacks = deviceImpl.getCallbacks();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (supportsCamera2ApiLocked(cameraId)) &#123;</span><br><span class="line">                <span class="comment">// Use cameraservice's cameradeviceclient implementation for HAL3.2+ devices</span></span><br><span class="line">                ICameraService cameraService = CameraManagerGlobal.get().getCameraService();</span><br><span class="line">                <span class="keyword">if</span> (cameraService == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ServiceSpecificException(</span><br><span class="line">                        ICameraService.ERROR_DISCONNECTED,</span><br><span class="line">                        <span class="string">"Camera service is currently unavailable"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                cameraUser = cameraService.connectDevice(callbacks, cameraId,</span><br><span class="line">                        mContext.getOpPackageName(), uid);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Use legacy camera implementation for HAL1 devices</span></span><br><span class="line">                <span class="keyword">int</span> id;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    id = Integer.parseInt(cameraId);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Expected cameraId to be numeric, but it was: "</span></span><br><span class="line">                            + cameraId);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                Log.i(TAG, <span class="string">"Using legacy camera HAL."</span>);</span><br><span class="line">                cameraUser = CameraDeviceUserShim.connectBinderShim(callbacks, id);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ServiceSpecificException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.errorCode == ICameraService.ERROR_DEPRECATED_HAL) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"Should've gone down the shim path"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.errorCode == ICameraService.ERROR_CAMERA_IN_USE ||</span><br><span class="line">                    e.errorCode == ICameraService.ERROR_MAX_CAMERAS_IN_USE ||</span><br><span class="line">                    e.errorCode == ICameraService.ERROR_DISABLED ||</span><br><span class="line">                    e.errorCode == ICameraService.ERROR_DISCONNECTED ||</span><br><span class="line">                    e.errorCode == ICameraService.ERROR_INVALID_OPERATION) &#123;</span><br><span class="line">                <span class="comment">// Received one of the known connection errors</span></span><br><span class="line">                <span class="comment">// The remote camera device cannot be connected to, so</span></span><br><span class="line">                <span class="comment">// set the local camera to the startup error state</span></span><br><span class="line">                deviceImpl.setRemoteFailure(e);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (e.errorCode == ICameraService.ERROR_DISABLED ||</span><br><span class="line">                        e.errorCode == ICameraService.ERROR_DISCONNECTED ||</span><br><span class="line">                        e.errorCode == ICameraService.ERROR_CAMERA_IN_USE) &#123;</span><br><span class="line">                    <span class="comment">// Per API docs, these failures call onError and throw</span></span><br><span class="line">                    throwAsPublicException(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Unexpected failure - rethrow</span></span><br><span class="line">                throwAsPublicException(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            <span class="comment">// Camera service died - act as if it's a CAMERA_DISCONNECTED case</span></span><br><span class="line">            ServiceSpecificException sse = <span class="keyword">new</span> ServiceSpecificException(</span><br><span class="line">                ICameraService.ERROR_DISCONNECTED,</span><br><span class="line">                <span class="string">"Camera service is currently unavailable"</span>);</span><br><span class="line">            deviceImpl.setRemoteFailure(sse);</span><br><span class="line">            throwAsPublicException(sse);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> factor out callback to be non-nested, then move setter to constructor</span></span><br><span class="line">        <span class="comment">// For now, calling setRemoteDevice will fire initial</span></span><br><span class="line">        <span class="comment">// onOpened/onUnconfigured callbacks.</span></span><br><span class="line">        <span class="comment">// This function call may post onDisconnected and throw CAMERA_DISCONNECTED if</span></span><br><span class="line">        <span class="comment">// cameraUser dies during setup.</span></span><br><span class="line">        deviceImpl.setRemoteDevice(cameraUser);</span><br><span class="line">        device = deviceImpl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> device;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用CameraManagerGlobal获取到了一个cameraService,cameraService是一个binder代理,通过它调用到服务端的方法,然后connectDeices连接相机设备.</p><h3 id="cameraclient"><a href="#cameraclient" class="headerlink" title="cameraclient"></a>cameraclient</h3><p>connectDevice方法定义在ICameraService.aidl里:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ICameraDeviceUser <span class="title">connectDevice</span><span class="params">(ICameraDeviceCallbacks callbacks,</span></span></span><br><span class="line"><span class="function"><span class="params">        String cameraId,</span></span></span><br><span class="line"><span class="function"><span class="params">        String opPackageName,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> clientUid)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="cameraservice"><a href="#cameraservice" class="headerlink" title="cameraservice"></a>cameraservice</h3><p>CameraService.cpp实现了connectDevice方法,这样就调用到了相机服务的方法,<br>connectDevice调用connectHelper方法,connectHelper调用了makeClient方法.这些流程在上一篇都有介绍到,这部分api1和api2是一致的.但makeClient在api1和api2返回的client不一样:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">Status CameraService::makeClient(<span class="keyword">const</span> sp&lt;CameraService&gt;&amp; cameraService,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;IInterface&gt;&amp; cameraCb, <span class="keyword">const</span> String16&amp; packageName, <span class="keyword">const</span> String8&amp; cameraId,</span><br><span class="line">        <span class="keyword">int</span> facing, <span class="keyword">int</span> clientPid, <span class="keyword">uid_t</span> clientUid, <span class="keyword">int</span> servicePid, <span class="keyword">bool</span> legacyMode,</span><br><span class="line">        <span class="keyword">int</span> halVersion, <span class="keyword">int</span> deviceVersion, apiLevel effectiveApiLevel,</span><br><span class="line">        <span class="comment">/*out*/</span>sp&lt;BasicClient&gt;* client) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (halVersion &lt; <span class="number">0</span> || halVersion == deviceVersion) &#123;</span><br><span class="line">        <span class="comment">// Default path: HAL version is unspecified by caller, create CameraClient</span></span><br><span class="line">        <span class="comment">// based on device version reported by the HAL.</span></span><br><span class="line">        <span class="keyword">switch</span>(deviceVersion) &#123;</span><br><span class="line">          <span class="keyword">case</span> CAMERA_DEVICE_API_VERSION_1_0:</span><br><span class="line">            <span class="keyword">if</span> (effectiveApiLevel == API_1) &#123;  <span class="comment">// Camera1 API route</span></span><br><span class="line">                sp&lt;ICameraClient&gt; tmp = <span class="keyword">static_cast</span>&lt;ICameraClient*&gt;(cameraCb.get());</span><br><span class="line">                *client = <span class="keyword">new</span> CameraClient(cameraService, tmp, packageName, cameraIdToInt(cameraId),</span><br><span class="line">                        facing, clientPid, clientUid, getpid(), legacyMode);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// Camera2 API route</span></span><br><span class="line">                ALOGW(<span class="string">"Camera using old HAL version: %d"</span>, deviceVersion);</span><br><span class="line">                <span class="keyword">return</span> STATUS_ERROR_FMT(ERROR_DEPRECATED_HAL,</span><br><span class="line">                        <span class="string">"Camera device \"%s\" HAL version %d does not support camera2 API"</span>,</span><br><span class="line">                        cameraId.<span class="built_in">string</span>(), deviceVersion);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> CAMERA_DEVICE_API_VERSION_3_0:</span><br><span class="line">          <span class="keyword">case</span> CAMERA_DEVICE_API_VERSION_3_1:</span><br><span class="line">          <span class="keyword">case</span> CAMERA_DEVICE_API_VERSION_3_2:</span><br><span class="line">          <span class="keyword">case</span> CAMERA_DEVICE_API_VERSION_3_3:</span><br><span class="line">          <span class="keyword">case</span> CAMERA_DEVICE_API_VERSION_3_4:</span><br><span class="line">            <span class="keyword">if</span> (effectiveApiLevel == API_1) &#123; <span class="comment">// Camera1 API route</span></span><br><span class="line">                sp&lt;ICameraClient&gt; tmp = <span class="keyword">static_cast</span>&lt;ICameraClient*&gt;(cameraCb.get());</span><br><span class="line">                *client = <span class="keyword">new</span> Camera2Client(cameraService, tmp, packageName, cameraIdToInt(cameraId),</span><br><span class="line">                        facing, clientPid, clientUid, servicePid, legacyMode);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// Camera2 API route</span></span><br><span class="line">                sp&lt;hardware::camera2::ICameraDeviceCallbacks&gt; tmp =</span><br><span class="line">                        <span class="keyword">static_cast</span>&lt;hardware::camera2::ICameraDeviceCallbacks*&gt;(cameraCb.get());</span><br><span class="line">                *client = <span class="keyword">new</span> CameraDeviceClient(cameraService, tmp, packageName, cameraId,</span><br><span class="line">                        facing, clientPid, clientUid, servicePid);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">// Should not be reachable</span></span><br><span class="line">            ALOGE(<span class="string">"Unknown camera device HAL version: %d"</span>, deviceVersion);</span><br><span class="line">            <span class="keyword">return</span> STATUS_ERROR_FMT(ERROR_INVALID_OPERATION,</span><br><span class="line">                    <span class="string">"Camera device \"%s\" has unknown HAL version %d"</span>,</span><br><span class="line">                    cameraId.<span class="built_in">string</span>(), deviceVersion);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// A particular HAL version is requested by caller. Create CameraClient</span></span><br><span class="line">        <span class="comment">// based on the requested HAL version.</span></span><br><span class="line">        <span class="keyword">if</span> (deviceVersion &gt; CAMERA_DEVICE_API_VERSION_1_0 &amp;&amp;</span><br><span class="line">            halVersion == CAMERA_DEVICE_API_VERSION_1_0) &#123;</span><br><span class="line">            <span class="comment">// Only support higher HAL version device opened as HAL1.0 device.</span></span><br><span class="line">            sp&lt;ICameraClient&gt; tmp = <span class="keyword">static_cast</span>&lt;ICameraClient*&gt;(cameraCb.get());</span><br><span class="line">            *client = <span class="keyword">new</span> CameraClient(cameraService, tmp, packageName, cameraIdToInt(cameraId),</span><br><span class="line">                    facing, clientPid, clientUid, servicePid, legacyMode);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Other combinations (e.g. HAL3.x open as HAL2.x) are not supported yet.</span></span><br><span class="line">            ALOGE(<span class="string">"Invalid camera HAL version %x: HAL %x device can only be"</span></span><br><span class="line">                    <span class="string">" opened as HAL %x device"</span>, halVersion, deviceVersion,</span><br><span class="line">                    CAMERA_DEVICE_API_VERSION_1_0);</span><br><span class="line">            <span class="keyword">return</span> STATUS_ERROR_FMT(ERROR_ILLEGAL_ARGUMENT,</span><br><span class="line">                    <span class="string">"Camera device \"%s\" (HAL version %d) cannot be opened as HAL version %d"</span>,</span><br><span class="line">                    cameraId.<span class="built_in">string</span>(), deviceVersion, halVersion);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Status::ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>api2下调用的是CameraDeviceClient,继承了Camera2ClientBase:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TClientBase&gt;</span><br><span class="line">Camera2ClientBase&lt;TClientBase&gt;::Camera2ClientBase(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;CameraService&gt;&amp; cameraService,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;TCamCallbacks&gt;&amp; remoteCallback,</span><br><span class="line">        <span class="keyword">const</span> String16&amp; clientPackageName,</span><br><span class="line">        <span class="keyword">const</span> String8&amp; cameraId,</span><br><span class="line">        <span class="keyword">int</span> cameraFacing,</span><br><span class="line">        <span class="keyword">int</span> clientPid,</span><br><span class="line">        <span class="keyword">uid_t</span> clientUid,</span><br><span class="line">        <span class="keyword">int</span> servicePid):</span><br><span class="line">        TClientBase(cameraService, remoteCallback, clientPackageName,</span><br><span class="line">                cameraId, cameraFacing, clientPid, clientUid, servicePid),</span><br><span class="line">        mSharedCameraCallbacks(remoteCallback),</span><br><span class="line">        mDeviceVersion(cameraService-&gt;getDeviceVersion(TClientBase::mCameraIdStr)),</span><br><span class="line">        mDeviceActive(<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ALOGI(<span class="string">"Camera %s: Opened. Client: %s (PID %d, UID %d)"</span>, cameraId.<span class="built_in">string</span>(),</span><br><span class="line">            String8(clientPackageName).<span class="built_in">string</span>(), clientPid, clientUid);</span><br><span class="line"></span><br><span class="line">    mInitialClientPid = clientPid;</span><br><span class="line">    mDevice = <span class="keyword">new</span> Camera3Device(cameraId);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(mDevice == <span class="number">0</span>, <span class="string">"Device should never be NULL here."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Camera2ClientBase创建了一个Camera3Device,作为hal层代理,调用到hal方法.继续看到Camera2ClientBase的初始化方法:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TClientBase&gt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TProviderPtr&gt;</span><br><span class="line"><span class="keyword">status_t</span> Camera2ClientBase&lt;TClientBase&gt;::initializeImpl(TProviderPtr providerPtr) &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    ALOGV(<span class="string">"%s: Initializing client for camera %s"</span>, __FUNCTION__,</span><br><span class="line">          TClientBase::mCameraIdStr.<span class="built_in">string</span>());</span><br><span class="line">    <span class="keyword">status_t</span> res;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Verify ops permissions</span></span><br><span class="line">    res = TClientBase::startCameraOps();</span><br><span class="line">    <span class="keyword">if</span> (res != OK) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mDevice == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"%s: Camera %s: No device connected"</span>,</span><br><span class="line">                __FUNCTION__, TClientBase::mCameraIdStr.<span class="built_in">string</span>());</span><br><span class="line">        <span class="keyword">return</span> NO_INIT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res = mDevice-&gt;initialize(providerPtr);</span><br><span class="line">    <span class="keyword">if</span> (res != OK) &#123;</span><br><span class="line">        ALOGE(<span class="string">"%s: Camera %s: unable to initialize device: %s (%d)"</span>,</span><br><span class="line">                __FUNCTION__, TClientBase::mCameraIdStr.<span class="built_in">string</span>(), strerror(-res), res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wp&lt;CameraDeviceBase::NotificationListener&gt; weakThis(<span class="keyword">this</span>);</span><br><span class="line">    res = mDevice-&gt;setNotifyCallback(weakThis);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看Camera3Device的initialize方法:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> Camera3Device::initialize(sp&lt;CameraProviderManager&gt; manager) &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">il</span><span class="params">(mInterfaceLock)</span></span>;</span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">l</span><span class="params">(mLock)</span></span>;</span><br><span class="line"></span><br><span class="line">    ALOGV(<span class="string">"%s: Initializing HIDL device for camera %s"</span>, __FUNCTION__, mId.<span class="built_in">string</span>());</span><br><span class="line">    <span class="keyword">if</span> (mStatus != STATUS_UNINITIALIZED) &#123;</span><br><span class="line">        CLOGE(<span class="string">"Already initialized!"</span>);</span><br><span class="line">        <span class="keyword">return</span> INVALID_OPERATION;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (manager == <span class="literal">nullptr</span>) <span class="keyword">return</span> INVALID_OPERATION;</span><br><span class="line"></span><br><span class="line">    sp&lt;ICameraDeviceSession&gt; session;</span><br><span class="line">    ATRACE_BEGIN(<span class="string">"CameraHal::openSession"</span>);</span><br><span class="line">    <span class="keyword">status_t</span> res = manager-&gt;openSession(mId.<span class="built_in">string</span>(), <span class="keyword">this</span>,</span><br><span class="line">            <span class="comment">/*out*/</span> &amp;session);</span><br><span class="line">    ATRACE_END();</span><br><span class="line">    <span class="keyword">if</span> (res != OK) &#123;</span><br><span class="line">        SET_ERR_L(<span class="string">"Could not open camera session: %s (%d)"</span>, strerror(-res), res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res = manager-&gt;getCameraCharacteristics(mId.<span class="built_in">string</span>(), &amp;mDeviceInfo);</span><br><span class="line">    <span class="keyword">if</span> (res != OK) &#123;</span><br><span class="line">        SET_ERR_L(<span class="string">"Could not retrive camera characteristics: %s (%d)"</span>, strerror(-res), res);</span><br><span class="line">        session-&gt;close();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;RequestMetadataQueue&gt; <span class="built_in">queue</span>;</span><br><span class="line">    <span class="keyword">auto</span> requestQueueRet = session-&gt;getCaptureRequestMetadataQueue(</span><br><span class="line">        [&amp;<span class="built_in">queue</span>](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; descriptor) &#123;</span><br><span class="line">            <span class="built_in">queue</span> = <span class="built_in">std</span>::make_shared&lt;RequestMetadataQueue&gt;(descriptor);</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">queue</span>-&gt;isValid() || <span class="built_in">queue</span>-&gt;availableToWrite() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                ALOGE(<span class="string">"HAL returns empty request metadata fmq, not use it"</span>);</span><br><span class="line">                <span class="built_in">queue</span> = <span class="literal">nullptr</span>;</span><br><span class="line">                <span class="comment">// don't use the queue onwards.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="keyword">if</span> (!requestQueueRet.isOk()) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Transaction error when getting request metadata fmq: %s, not use it"</span>,</span><br><span class="line">                requestQueueRet.description().c_str());</span><br><span class="line">        <span class="keyword">return</span> DEAD_OBJECT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> resultQueueRet = session-&gt;getCaptureResultMetadataQueue(</span><br><span class="line">        [&amp;<span class="built_in">queue</span> = mResultMetadataQueue](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; descriptor) &#123;</span><br><span class="line">            <span class="built_in">queue</span> = <span class="built_in">std</span>::make_unique&lt;ResultMetadataQueue&gt;(descriptor);</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">queue</span>-&gt;isValid() ||  <span class="built_in">queue</span>-&gt;availableToWrite() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                ALOGE(<span class="string">"HAL returns empty result metadata fmq, not use it"</span>);</span><br><span class="line">                <span class="built_in">queue</span> = <span class="literal">nullptr</span>;</span><br><span class="line">                <span class="comment">// Don't use the queue onwards.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="keyword">if</span> (!resultQueueRet.isOk()) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Transaction error when getting result metadata queue from camera session: %s"</span>,</span><br><span class="line">                resultQueueRet.description().c_str());</span><br><span class="line">        <span class="keyword">return</span> DEAD_OBJECT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mInterface = <span class="built_in">std</span>::make_unique&lt;HalInterface&gt;(session, <span class="built_in">queue</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> providerType;</span><br><span class="line">    mVendorTagId = manager-&gt;getProviderTagIdLocked(mId.<span class="built_in">string</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> initializeCommonLocked();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里通过CameraProviderManager的openSession获得一个ICameraDeviceSession,看下openSession方法:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> CameraProviderManager::openSession(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;id,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;hardware::camera::device::V3_2::ICameraDeviceCallback&gt;&amp; callback,</span><br><span class="line">        <span class="comment">/*out*/</span></span><br><span class="line">        sp&lt;hardware::camera::device::V3_2::ICameraDeviceSession&gt; *session) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lock(mInterfaceMutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> deviceInfo = findDeviceInfoLocked(id,</span><br><span class="line">            <span class="comment">/*minVersion*/</span> &#123;<span class="number">3</span>,<span class="number">0</span>&#125;, <span class="comment">/*maxVersion*/</span> &#123;<span class="number">4</span>,<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">if</span> (deviceInfo == <span class="literal">nullptr</span>) <span class="keyword">return</span> NAME_NOT_FOUND;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> *deviceInfo3 = <span class="keyword">static_cast</span>&lt;ProviderInfo::DeviceInfo3*&gt;(deviceInfo);</span><br><span class="line"></span><br><span class="line">    Status status;</span><br><span class="line">    hardware::Return&lt;<span class="keyword">void</span>&gt; ret;</span><br><span class="line">    ret = deviceInfo3-&gt;mInterface-&gt;open(callback, [&amp;status, &amp;session]</span><br><span class="line">            (Status s, <span class="keyword">const</span> sp&lt;device::V3_2::ICameraDeviceSession&gt;&amp; cameraSession) &#123;</span><br><span class="line">                status = s;</span><br><span class="line">                <span class="keyword">if</span> (status == Status::OK) &#123;</span><br><span class="line">                    *session = cameraSession;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    <span class="keyword">if</span> (!ret.isOk()) &#123;</span><br><span class="line">        ALOGE(<span class="string">"%s: Transaction error opening a session for camera device %s: %s"</span>,</span><br><span class="line">                __FUNCTION__, id.c_str(), ret.description().c_str());</span><br><span class="line">        <span class="keyword">return</span> DEAD_OBJECT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mapToStatusT(status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是通过一个DeviceInfo获取HardwareInterface,再调用open方法获得一个ICameraDeviceSession,open方法在ICameraDevices.hal中定义,在在hal中实现,session是会话的意思,打开了一个会话,通过这个hidlSession可以直接获得hal的信息.</p><h2 id="hal层"><a href="#hal层" class="headerlink" title="hal层"></a>hal层</h2><p>getCaptureResultMetadataQueue定义在ICameraDeviceSession.hal里,实现在CameraDeviceSession.cpp里,看下实现:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Return&lt;<span class="keyword">void</span>&gt; CameraDeviceSession::getCaptureResultMetadataQueue(</span><br><span class="line">    getCaptureResultMetadataQueue_cb _hidl_cb) &#123;</span><br><span class="line">    _hidl_cb(*mResultMetadataQueue-&gt;getDesc());</span><br><span class="line">    <span class="keyword">return</span> Void();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hal层方法,通过mResultMetadataQueue获取到result结果.</p><h2 id="流程总结"><a href="#流程总结" class="headerlink" title="流程总结"></a>流程总结</h2><p>总结一下api2打开相机整体流程:</p><ol><li>app层获得相机服务,通过CameraManager打开相机</li><li>CameraManager获取相机服务(CameraService),调用其连接设备方法(connectDevice)</li><li>CameraService生成一个Camera2的相机代理(CameraDeviceClient,继承自Camera2ClientBase)</li><li>Camera2ClientBase创建一个相机设备(Camera3Device)</li><li>Camera3Device初始化时通过CameraProviderManager的open方法获得一个hidl代理会话(ICameraDeviceSession)</li><li>通过ICameraDeviceSession调用到hal层方法获取返回结果(getCaptureResultMetadataQueue)</li></ol>]]></content>
    
    <summary type="html">
    
      相机流程深入解析:API2打开相机
    
    </summary>
    
    
      <category term="Android" scheme="http://anddymao.com/tags/Android/"/>
    
      <category term="Camera" scheme="http://anddymao.com/tags/Camera/"/>
    
  </entry>
  
  <entry>
    <title>Android8.0相机源码深入解析(六)</title>
    <link href="http://anddymao.com/2018/06/13/2018-6-13-%E7%9B%B8%E6%9C%BA%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90(%E5%85%AD)/"/>
    <id>http://anddymao.com/2018/06/13/2018-6-13-相机源码深入解析(六)/</id>
    <published>2018-06-13T04:00:00.000Z</published>
    <updated>2019-10-25T03:38:48.889Z</updated>
    
    <content type="html"><![CDATA[<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>之前讲解的几篇相机解析文章虽然都有介绍到hal,但hal层都是点到为止.这一篇来详细讲一下hal的调用流程.基于android8.0的上的高通框架,代码可以在googlesource上下到.<br>本篇是基于API1分析.</p><p>本篇基于的源码链接:</p><p><a href="https://android.googlesource.com/platform/hardware/qcom/camera/+/android-8.1.0_r33" target="_blank" rel="noopener">https://android.googlesource.com/platform/hardware/qcom/camera/+/android-8.1.0_r33</a></p><h2 id="hal代码结构分析"><a href="#hal代码结构分析" class="headerlink" title="hal代码结构分析"></a>hal代码结构分析</h2><h3 id="接口部分"><a href="#接口部分" class="headerlink" title="接口部分"></a>接口部分</h3><p>hal接口方法定义在hardware/interface/camera里.hal接口以hal为后缀,写法类似java的接口.</p><p>ICameraDevice.hal,api1的接口方法,其它还包括ICameraDeviceCallback.hal和ICameraDevicePreviewCallback.hal,包含一些回调.<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> android.hardware.camera.device@<span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.hardware.camera.common@<span class="number">1.0</span>::types;</span><br><span class="line"><span class="keyword">import</span> ICameraDeviceCallback;</span><br><span class="line"><span class="keyword">import</span> ICameraDevicePreviewCallback;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ICameraDevice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    getResourceCost() generates (Status status, CameraResourceCost resourceCost);</span><br><span class="line"></span><br><span class="line">    getCameraInfo() generates (Status status, CameraInfo info);</span><br><span class="line"></span><br><span class="line">    setTorchMode(TorchMode mode) generates (Status status);</span><br><span class="line"></span><br><span class="line">    dumpState(handle fd) generates (Status status);</span><br><span class="line"></span><br><span class="line">    open(ICameraDeviceCallback callback) generates (Status status);</span><br><span class="line"></span><br><span class="line">    setPreviewWindow(ICameraDevicePreviewCallback window)</span><br><span class="line">            generates (Status status);</span><br><span class="line"></span><br><span class="line">    enableMsgType(FrameCallbackFlags msgType);</span><br><span class="line"></span><br><span class="line">    disableMsgType(FrameCallbackFlags msgType);</span><br><span class="line"></span><br><span class="line">    msgTypeEnabled(FrameCallbackFlags msgType) generates (bool enabled);</span><br><span class="line"></span><br><span class="line">    startPreview() generates (Status status);</span><br><span class="line"></span><br><span class="line">    stopPreview();</span><br><span class="line"></span><br><span class="line">    previewEnabled() generates (bool enabled);</span><br><span class="line"></span><br><span class="line">    storeMetaDataInBuffers(bool enable) generates (Status status);</span><br><span class="line"></span><br><span class="line">    startRecording() generates (Status status);</span><br><span class="line"></span><br><span class="line">    stopRecording();</span><br><span class="line"></span><br><span class="line">    recordingEnabled() generates (bool enabled);</span><br><span class="line"></span><br><span class="line">    releaseRecordingFrame(MemoryId memId, uint32_t bufferIndex);</span><br><span class="line"></span><br><span class="line">    releaseRecordingFrameHandle(MemoryId memId, uint32_t bufferIndex, handle frame);</span><br><span class="line"></span><br><span class="line">    releaseRecordingFrameHandleBatch(vec&lt;VideoFrameMessage&gt; batch);</span><br><span class="line"></span><br><span class="line">    autoFocus() generates (Status status);</span><br><span class="line"></span><br><span class="line">    cancelAutoFocus() generates (Status status);</span><br><span class="line"></span><br><span class="line">    takePicture() generates (Status status);</span><br><span class="line"></span><br><span class="line">    cancelPicture() generates (Status status);</span><br><span class="line"></span><br><span class="line">    setParameters(string params) generates (Status status);</span><br><span class="line"></span><br><span class="line">    getParameters() generates (string parms);</span><br><span class="line"></span><br><span class="line">    sendCommand(CommandType cmd, int32_t arg1, int32_t arg2)</span><br><span class="line">            generates (Status status);</span><br><span class="line"></span><br><span class="line">    close();</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>hardware接口方法写在libhardware/include/hardware/camera.h里,另外还有camera2.h,camera3.h和camera_common.h.</p><p>里面定义了一些hal层用到的struct,如camera_device,camera_device_ops_t等.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ANDROID_INCLUDE_CAMERA_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ANDROID_INCLUDE_CAMERA_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"camera_common.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">__BEGIN_DECLS</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">camera_memory</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*camera_release_memory)</span><span class="params">(struct camera_memory *mem)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">camera_memory</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *data;</span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line">    <span class="keyword">void</span> *handle;</span><br><span class="line">    camera_release_memory release;</span><br><span class="line">&#125; <span class="keyword">camera_memory_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">camera_memory_t</span>* (*camera_request_memory)(<span class="keyword">int</span> fd, <span class="keyword">size_t</span> buf_size, <span class="keyword">unsigned</span> <span class="keyword">int</span> num_bufs,</span><br><span class="line">                                                  <span class="keyword">void</span> *user);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*camera_notify_callback)</span><span class="params">(<span class="keyword">int32_t</span> msg_type,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int32_t</span> ext1,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int32_t</span> ext2,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">void</span> *user)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*camera_data_callback)</span><span class="params">(<span class="keyword">int32_t</span> msg_type,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="keyword">camera_memory_t</span> *data, <span class="keyword">unsigned</span> <span class="keyword">int</span> index,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">camera_frame_metadata_t</span> *metadata, <span class="keyword">void</span> *user)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*camera_data_timestamp_callback)</span><span class="params">(<span class="keyword">int64_t</span> timestamp,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int32_t</span> msg_type,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="keyword">camera_memory_t</span> *data, <span class="keyword">unsigned</span> <span class="keyword">int</span> index,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">void</span> *user)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAL_CAMERA_PREVIEW_WINDOW_TAG 0xcafed00d</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">preview_stream_ops</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> (*dequeue_buffer)(struct preview_stream_ops* w,</span><br><span class="line">                          <span class="keyword">buffer_handle_t</span>** buffer, <span class="keyword">int</span> *stride);</span><br><span class="line">    <span class="keyword">int</span> (*enqueue_buffer)(struct preview_stream_ops* w,</span><br><span class="line">                <span class="keyword">buffer_handle_t</span>* buffer);</span><br><span class="line">    <span class="keyword">int</span> (*cancel_buffer)(struct preview_stream_ops* w,</span><br><span class="line">                <span class="keyword">buffer_handle_t</span>* buffer);</span><br><span class="line">    <span class="keyword">int</span> (*set_buffer_count)(struct preview_stream_ops* w, <span class="keyword">int</span> count);</span><br><span class="line">    <span class="keyword">int</span> (*set_buffers_geometry)(struct preview_stream_ops* pw,</span><br><span class="line">                <span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> format);</span><br><span class="line">    <span class="keyword">int</span> (*set_crop)(struct preview_stream_ops *w,</span><br><span class="line">                <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom);</span><br><span class="line">    <span class="keyword">int</span> (*set_usage)(struct preview_stream_ops* w, <span class="keyword">int</span> usage);</span><br><span class="line">    <span class="keyword">int</span> (*set_swap_interval)(struct preview_stream_ops *w, <span class="keyword">int</span> interval);</span><br><span class="line">    <span class="keyword">int</span> (*get_min_undequeued_buffer_count)(<span class="keyword">const</span> struct preview_stream_ops *w,</span><br><span class="line">                <span class="keyword">int</span> *count);</span><br><span class="line">    <span class="keyword">int</span> (*lock_buffer)(struct preview_stream_ops* w,</span><br><span class="line">                <span class="keyword">buffer_handle_t</span>* buffer);</span><br><span class="line">    <span class="comment">// Timestamps are measured in nanoseconds, and must be comparable</span></span><br><span class="line">    <span class="comment">// and monotonically increasing between two frames in the same</span></span><br><span class="line">    <span class="comment">// preview stream. They do not need to be comparable between</span></span><br><span class="line">    <span class="comment">// consecutive or parallel preview streams, cameras, or app runs.</span></span><br><span class="line">    <span class="keyword">int</span> (*set_timestamp)(struct preview_stream_ops *w, <span class="keyword">int64_t</span> timestamp);</span><br><span class="line">&#125; <span class="keyword">preview_stream_ops_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">camera_device</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">camera_device_ops</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Start preview mode.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> (*start_preview)(struct camera_device *);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Stop a previously started preview.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> (*stop_preview)(struct camera_device *);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns true if preview is enabled.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> (*preview_enabled)(struct camera_device *);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*store_meta_data_in_buffers)(struct camera_device *, <span class="keyword">int</span> enable);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Start record mode. When a record image is available, a</span></span><br><span class="line"><span class="comment">     * CAMERA_MSG_VIDEO_FRAME message is sent with the corresponding</span></span><br><span class="line"><span class="comment">     * frame. Every record frame must be released by a camera HAL client via</span></span><br><span class="line"><span class="comment">     * releaseRecordingFrame() before the client calls</span></span><br><span class="line"><span class="comment">     * disableMsgType(CAMERA_MSG_VIDEO_FRAME). After the client calls</span></span><br><span class="line"><span class="comment">     * disableMsgType(CAMERA_MSG_VIDEO_FRAME), it is the camera HAL's</span></span><br><span class="line"><span class="comment">     * responsibility to manage the life-cycle of the video recording frames,</span></span><br><span class="line"><span class="comment">     * and the client must not modify/access any video recording frames.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> (*start_recording)(struct camera_device *);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Stop a previously started recording.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> (*stop_recording)(struct camera_device *);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns true if recording is enabled.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> (*recording_enabled)(struct camera_device *);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Release a record frame previously returned by CAMERA_MSG_VIDEO_FRAME.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * It is camera HAL client's responsibility to release video recording</span></span><br><span class="line"><span class="comment">     * frames sent out by the camera HAL before the camera HAL receives a call</span></span><br><span class="line"><span class="comment">     * to disableMsgType(CAMERA_MSG_VIDEO_FRAME). After it receives the call to</span></span><br><span class="line"><span class="comment">     * disableMsgType(CAMERA_MSG_VIDEO_FRAME), it is the camera HAL's</span></span><br><span class="line"><span class="comment">     * responsibility to manage the life-cycle of the video recording frames.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> (*release_recording_frame)(struct camera_device *,</span><br><span class="line">                    <span class="keyword">const</span> <span class="keyword">void</span> *opaque);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Start auto focus, the notification callback routine is called with</span></span><br><span class="line"><span class="comment">     * CAMERA_MSG_FOCUS once when focusing is complete. autoFocus() will be</span></span><br><span class="line"><span class="comment">     * called again if another auto focus is needed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> (*auto_focus)(struct camera_device *);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Cancels auto-focus function. If the auto-focus is still in progress,</span></span><br><span class="line"><span class="comment">     * this function will cancel it. Whether the auto-focus is in progress or</span></span><br><span class="line"><span class="comment">     * not, this function will return the focus position to the default.  If</span></span><br><span class="line"><span class="comment">     * the camera does not support auto-focus, this is a no-op.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> (*cancel_auto_focus)(struct camera_device *);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Take a picture.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> (*take_picture)(struct camera_device *);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Cancel a picture that was started with takePicture. Calling this method</span></span><br><span class="line"><span class="comment">     * when no picture is being taken is a no-op.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> (*cancel_picture)(struct camera_device *);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Set the camera parameters. This returns BAD_VALUE if any parameter is</span></span><br><span class="line"><span class="comment">     * invalid or not supported.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> (*set_parameters)(struct camera_device *, <span class="keyword">const</span> <span class="keyword">char</span> *parms);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Retrieve the camera parameters.  The buffer returned by the camera HAL</span></span><br><span class="line"><span class="comment">        must be returned back to it with put_parameters, if put_parameters</span></span><br><span class="line"><span class="comment">        is not NULL.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">char</span> *(*get_parameters)(struct camera_device *);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The camera HAL uses its own memory to pass us the parameters when we</span></span><br><span class="line"><span class="comment">        call get_parameters.  Use this function to return the memory back to</span></span><br><span class="line"><span class="comment">        the camera HAL, if put_parameters is not NULL.  If put_parameters</span></span><br><span class="line"><span class="comment">        is NULL, then you have to use free() to release the memory.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">void</span> (*put_parameters)(struct camera_device *, <span class="keyword">char</span> *);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">camera_device_ops_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">camera_device</span> &#123;</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * camera_device.common.version must be in the range</span></span><br><span class="line"><span class="comment">     * HARDWARE_DEVICE_API_VERSION(0,0)-(1,FF). CAMERA_DEVICE_API_VERSION_1_0 is</span></span><br><span class="line"><span class="comment">     * recommended.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">hw_device_t</span> common;</span><br><span class="line">    <span class="keyword">camera_device_ops_t</span> *ops;</span><br><span class="line">    <span class="keyword">void</span> *priv;</span><br><span class="line">&#125; <span class="keyword">camera_device_t</span>;</span><br></pre></td></tr></table></figure><h3 id="hal代码结构"><a href="#hal代码结构" class="headerlink" title="hal代码结构"></a>hal代码结构</h3><p>hal代码在QCamera2下,HAL,HAL3,stack,utils等包.从Android.mk找LOCAL_SRC_FILES,即用到的源码.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_SRC_FILES := \</span><br><span class="line">        util/QCameraBufferMaps.cpp \</span><br><span class="line">        util/QCameraCmdThread.cpp \</span><br><span class="line">        util/QCameraFlash.cpp \</span><br><span class="line">        util/QCameraPerf.cpp \</span><br><span class="line">        util/QCameraQueue.cpp \</span><br><span class="line">        util/QCameraCommon.cpp \</span><br><span class="line">        util/QCameraTrace.cpp \</span><br><span class="line">        util/camscope_packet_type.cpp \</span><br><span class="line">        QCamera2Hal.cpp \</span><br><span class="line">        QCamera2Factory.cpp</span><br><span class="line">ifeq ($(TARGET_SUPPORT_HAL1),<span class="literal">false</span>)</span><br><span class="line">LOCAL_CFLAGS += -DQCAMERA_HAL3_SUPPORT</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">LOCAL_CFLAGS += -DQCAMERA_HAL1_SUPPORT</span><br><span class="line">LOCAL_SRC_FILES += \</span><br><span class="line">        HAL/QCamera2HWI.cpp \</span><br><span class="line">        HAL/QCameraMuxer.cpp \</span><br><span class="line">        HAL/QCameraMem.cpp \</span><br><span class="line">        HAL/QCameraStateMachine.cpp \</span><br><span class="line">        HAL/QCameraChannel.cpp \</span><br><span class="line">        HAL/QCameraStream.cpp \</span><br><span class="line">        HAL/QCameraPostProc.cpp \</span><br><span class="line">        HAL/QCamera2HWICallbacks.cpp \</span><br><span class="line">        HAL/QCameraParameters.cpp \</span><br><span class="line">        HAL/QCameraParametersIntf.cpp \</span><br><span class="line">        HAL/QCameraThermalAdapter.cpp \</span><br><span class="line">        util/QCameraFOVControl.cpp \</span><br><span class="line">        util/QCameraHALPP.cpp \</span><br><span class="line">        util/QCameraDualFOVPP.cpp \</span><br><span class="line">        util/QCameraExtZoomTranslator.cpp</span><br><span class="line">endif</span><br></pre></td></tr></table></figure><p>第一部分是公共的,第二部分是hal1的.</p><h2 id="hal打开设备流程"><a href="#hal打开设备流程" class="headerlink" title="hal打开设备流程"></a>hal打开设备流程</h2><h3 id="模块注册"><a href="#模块注册" class="headerlink" title="模块注册"></a>模块注册</h3><p>先看公共部分的QCamera2Hal.cpp:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"QCamera2Factory.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"HAL3/QCamera3VendorTags.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">hw_module_t</span> camera_common = &#123;</span><br><span class="line">    .tag                    = HARDWARE_MODULE_TAG,</span><br><span class="line">    .module_api_version     = CAMERA_MODULE_API_VERSION_2_4,</span><br><span class="line">    .hal_api_version        = HARDWARE_HAL_API_VERSION,</span><br><span class="line">    .id                     = CAMERA_HARDWARE_MODULE_ID,</span><br><span class="line">    .name                   = <span class="string">"QCamera Module"</span>,</span><br><span class="line">    .author                 = <span class="string">"Qualcomm Innovation Center Inc"</span>,</span><br><span class="line">    .methods                = &amp;qcamera::QCamera2Factory::mModuleMethods,</span><br><span class="line">    .dso                    = <span class="literal">NULL</span>,</span><br><span class="line">    .reserved               = &#123;<span class="number">0</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">camera_module_t</span> HAL_MODULE_INFO_SYM = &#123;</span><br><span class="line">    .common                 = camera_common,</span><br><span class="line">    .get_number_of_cameras  = qcamera::QCamera2Factory::get_number_of_cameras,</span><br><span class="line">    .get_camera_info        = qcamera::QCamera2Factory::get_camera_info,</span><br><span class="line">    .set_callbacks          = qcamera::QCamera2Factory::set_callbacks,</span><br><span class="line">    .get_vendor_tag_ops     = qcamera::QCamera3VendorTags::get_vendor_tag_ops,</span><br><span class="line">    .open_legacy            = <span class="literal">NULL</span>,</span><br><span class="line">    .set_torch_mode         = qcamera::QCamera2Factory::set_torch_mode,</span><br><span class="line">    .init                   = <span class="literal">NULL</span>,</span><br><span class="line">    .reserved               = &#123;<span class="number">0</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里定义了一个hardware模块模板hw_module_t,有模块名,版本,方法等,每一个hal模块都需要定义一个hw_module_t.<br>camera_module_t定义在前面讲的camera_common.h中,包含一些获取相机模块基础信息的方法.</p><h3 id="QCamera2Factory"><a href="#QCamera2Factory" class="headerlink" title="QCamera2Factory"></a>QCamera2Factory</h3><p>获取信息的方法都非常简单,可以在QCamera2Factory看到,我们继续探究模块方法mModuleMethods:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*===========================================================================</span></span><br><span class="line"><span class="comment"> * FUNCTION   : cameraDeviceOpen</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * DESCRIPTION: open a camera device with its ID</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * PARAMETERS :</span></span><br><span class="line"><span class="comment"> *   @camera_id : camera ID</span></span><br><span class="line"><span class="comment"> *   @hw_device : ptr to struct storing camera hardware device info</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * RETURN     : int32_t type of status</span></span><br><span class="line"><span class="comment"> *              NO_ERROR  -- success</span></span><br><span class="line"><span class="comment"> *              none-zero failure code</span></span><br><span class="line"><span class="comment"> *==========================================================================*/</span></span><br><span class="line"><span class="keyword">int</span> QCamera2Factory::cameraDeviceOpen(<span class="keyword">int</span> camera_id,</span><br><span class="line">                    struct <span class="keyword">hw_device_t</span> **hw_device)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> rc = NO_ERROR;</span><br><span class="line">    <span class="keyword">if</span> (camera_id &lt; <span class="number">0</span> || camera_id &gt;= mNumOfCameras)</span><br><span class="line">        <span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( <span class="literal">NULL</span> == mHalDescriptors ) &#123;</span><br><span class="line">        LOGE(<span class="string">"Hal descriptor table is not initialized!"</span>);</span><br><span class="line">        <span class="keyword">return</span> NO_INIT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LOGI(<span class="string">"Open camera id %d API version %d"</span>,</span><br><span class="line">            camera_id, mHalDescriptors[camera_id].device_version);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( mHalDescriptors[camera_id].device_version == CAMERA_DEVICE_API_VERSION_3_0 ) &#123;</span><br><span class="line">        CAMSCOPE_INIT(CAMSCOPE_SECTION_HAL);</span><br><span class="line">        QCamera3HardwareInterface *hw = <span class="keyword">new</span> QCamera3HardwareInterface(mHalDescriptors[camera_id].cameraId,</span><br><span class="line">                mCallbacks);</span><br><span class="line">        <span class="keyword">if</span> (!hw) &#123;</span><br><span class="line">            LOGE(<span class="string">"Allocation of hardware interface failed"</span>);</span><br><span class="line">            <span class="keyword">return</span> NO_MEMORY;</span><br><span class="line">        &#125;</span><br><span class="line">        rc = hw-&gt;openCamera(hw_device);</span><br><span class="line">        <span class="keyword">if</span> (rc != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> hw;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> QCAMERA_HAL1_SUPPORT</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mHalDescriptors[camera_id].device_version == CAMERA_DEVICE_API_VERSION_1_0) &#123;</span><br><span class="line">        QCamera2HardwareInterface *hw = <span class="keyword">new</span> QCamera2HardwareInterface((<span class="keyword">uint32_t</span>)camera_id);</span><br><span class="line">        <span class="keyword">if</span> (!hw) &#123;</span><br><span class="line">            LOGE(<span class="string">"Allocation of hardware interface failed"</span>);</span><br><span class="line">            <span class="keyword">return</span> NO_MEMORY;</span><br><span class="line">        &#125;</span><br><span class="line">        rc = hw-&gt;openCamera(hw_device);</span><br><span class="line">        <span class="keyword">if</span> (rc != NO_ERROR) &#123;</span><br><span class="line">            <span class="keyword">delete</span> hw;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        LOGE(<span class="string">"Device version for camera id %d invalid %d"</span>,</span><br><span class="line">              camera_id,</span><br><span class="line">              mHalDescriptors[camera_id].device_version);</span><br><span class="line">        <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*===========================================================================</span></span><br><span class="line"><span class="comment"> * FUNCTION   : camera_device_open</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * DESCRIPTION: static function to open a camera device by its ID</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * PARAMETERS :</span></span><br><span class="line"><span class="comment"> *   @camera_id : camera ID</span></span><br><span class="line"><span class="comment"> *   @hw_device : ptr to struct storing camera hardware device info</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * RETURN     : int32_t type of status</span></span><br><span class="line"><span class="comment"> *              NO_ERROR  -- success</span></span><br><span class="line"><span class="comment"> *              none-zero failure code</span></span><br><span class="line"><span class="comment"> *==========================================================================*/</span></span><br><span class="line"><span class="keyword">int</span> QCamera2Factory::camera_device_open(</span><br><span class="line">    <span class="keyword">const</span> struct <span class="keyword">hw_module_t</span> *<span class="keyword">module</span>, <span class="keyword">const</span> <span class="keyword">char</span> *id,</span><br><span class="line">    struct <span class="keyword">hw_device_t</span> **hw_device)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> rc = NO_ERROR;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">module</span> != &amp;HAL_MODULE_INFO_SYM.common) &#123;</span><br><span class="line">        LOGE(<span class="string">"Invalid module. Trying to open %p, expect %p"</span>,</span><br><span class="line">            <span class="keyword">module</span>, &amp;HAL_MODULE_INFO_SYM.common);</span><br><span class="line">        <span class="keyword">return</span> INVALID_OPERATION;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!id) &#123;</span><br><span class="line">        LOGE(<span class="string">"Invalid camera id"</span>);</span><br><span class="line">        <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> QCAMERA_HAL1_SUPPORT</span></span><br><span class="line">    <span class="keyword">if</span>(gQCameraMuxer)</span><br><span class="line">        rc =  gQCameraMuxer-&gt;camera_device_open(<span class="keyword">module</span>, id, hw_device);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">#endif</span><br><span class="line">        rc = gQCamera2Factory-&gt;cameraDeviceOpen(atoi(id), hw_device);</span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hw_module_methods_t</span> <span class="title">QCamera2Factory</span>:</span>:mModuleMethods = &#123;</span><br><span class="line">    .open = QCamera2Factory::camera_device_open,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>模块方法只有一个open方法,然后如果支持是hal1多摄,则走QCameraMuxer,如何是hal3,直接走QCamera3HardwareInterface,否则走QCamera2HardwareInterface.最后都会调用openCamera方法.<br>QCameraMuxer用于多个物理相机对应一个逻辑相机,这部分不细看.继续看QCamera2HardwareInterface的openCamera方法.<br>QCamera2HardwareInterface定义在QCamera2HWI里,就是一个简写.</p><h3 id="QCamera2HardwareInterface"><a href="#QCamera2HardwareInterface" class="headerlink" title="QCamera2HardwareInterface"></a>QCamera2HardwareInterface</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> QCamera2HardwareInterface::openCamera(struct <span class="keyword">hw_device_t</span> **hw_device)</span><br><span class="line">&#123;</span><br><span class="line">    KPI_ATRACE_CAMSCOPE_CALL(CAMSCOPE_HAL1_OPENCAMERA);</span><br><span class="line">    <span class="keyword">int</span> rc = NO_ERROR;</span><br><span class="line">    <span class="keyword">if</span> (mCameraOpened) &#123;</span><br><span class="line">        *hw_device = <span class="literal">NULL</span>;</span><br><span class="line">        LOGE(<span class="string">"Permission Denied"</span>);</span><br><span class="line">        <span class="keyword">return</span> PERMISSION_DENIED;</span><br><span class="line">    &#125;</span><br><span class="line">    LOGI(<span class="string">"[KPI Perf]: E PROFILE_OPEN_CAMERA camera id %d"</span>,</span><br><span class="line">            mCameraId);</span><br><span class="line"></span><br><span class="line">    m_perfLockMgr.acquirePerfLock(PERF_LOCK_OPEN_CAMERA);</span><br><span class="line"></span><br><span class="line">    rc = openCamera();</span><br><span class="line">    <span class="keyword">if</span> (rc == NO_ERROR)&#123;</span><br><span class="line">        *hw_device = &amp;mCameraDevice.common;</span><br><span class="line">        <span class="keyword">if</span> (m_thermalAdapter.init(<span class="keyword">this</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">          LOGW(<span class="string">"Init thermal adapter failed"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        *hw_device = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    LOGI(<span class="string">"[KPI Perf]: X PROFILE_OPEN_CAMERA camera id %d, rc: %d"</span>,</span><br><span class="line">            mCameraId, rc);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mCameraDevice是一个camera_device,camera_device的common是一个hw_device,打开相机成功则返回给*hw_device.<br>继续看openCamera方法:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> QCamera2HardwareInterface::openCamera()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> rc = NO_ERROR;</span><br><span class="line">    <span class="keyword">char</span> value[PROPERTY_VALUE_MAX];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mCameraHandle) &#123;</span><br><span class="line">        LOGE(<span class="string">"Failure: Camera already opened"</span>);</span><br><span class="line">        <span class="keyword">return</span> ALREADY_EXISTS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rc = QCameraFlash::getInstance().reserveFlashForCamera(mCameraId);</span><br><span class="line">    <span class="keyword">if</span> (rc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        LOGE(<span class="string">"Failed to reserve flash for camera id: %d"</span>,</span><br><span class="line">                mCameraId);</span><br><span class="line">        <span class="keyword">return</span> UNKNOWN_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// alloc param buffer</span></span><br><span class="line">    DeferWorkArgs args;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;args, <span class="number">0</span>, <span class="keyword">sizeof</span>(args));</span><br><span class="line">    mParamAllocJob = queueDeferredWork(CMD_DEF_PARAM_ALLOC, args);</span><br><span class="line">    <span class="keyword">if</span> (mParamAllocJob == <span class="number">0</span>) &#123;</span><br><span class="line">        LOGE(<span class="string">"Failed queueing PARAM_ALLOC job"</span>);</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (gCamCapability[mCameraId] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// allocate metadata buffers</span></span><br><span class="line">        DeferWorkArgs args;</span><br><span class="line">        DeferMetadataAllocArgs metadataAllocArgs;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(&amp;args, <span class="number">0</span>, <span class="keyword">sizeof</span>(args));</span><br><span class="line">        <span class="built_in">memset</span>(&amp;metadataAllocArgs, <span class="number">0</span>, <span class="keyword">sizeof</span>(metadataAllocArgs));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">uint32_t</span> padding =</span><br><span class="line">                gCamCapability[mCameraId]-&gt;padding_info.plane_padding;</span><br><span class="line">        metadataAllocArgs.size = PAD_TO_SIZE(<span class="keyword">sizeof</span>(<span class="keyword">metadata_buffer_t</span>),</span><br><span class="line">                padding);</span><br><span class="line">        metadataAllocArgs.bufferCnt = CAMERA_MIN_METADATA_BUFFERS;</span><br><span class="line">        args.metadataAllocArgs = metadataAllocArgs;</span><br><span class="line"></span><br><span class="line">        mMetadataAllocJob = queueDeferredWork(CMD_DEF_METADATA_ALLOC, args);</span><br><span class="line">        <span class="keyword">if</span> (mMetadataAllocJob == <span class="number">0</span>) &#123;</span><br><span class="line">            LOGE(<span class="string">"Failed to allocate metadata buffer"</span>);</span><br><span class="line">            rc = -ENOMEM;</span><br><span class="line">            <span class="keyword">goto</span> error_exit1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        rc = camera_open((<span class="keyword">uint8_t</span>)mCameraId, &amp;mCameraHandle);</span><br><span class="line">        <span class="keyword">if</span> (rc) &#123;</span><br><span class="line">            LOGE(<span class="string">"camera_open failed. rc = %d, mCameraHandle = %p"</span>,</span><br><span class="line">                     rc, mCameraHandle);</span><br><span class="line">            <span class="keyword">goto</span> error_exit2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mCameraHandle-&gt;ops-&gt;register_event_notify(mCameraHandle-&gt;camera_handle,</span><br><span class="line">                camEvtHandle,</span><br><span class="line">                (<span class="keyword">void</span> *) <span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        LOGH(<span class="string">"Capabilities not inited, initializing now."</span>);</span><br><span class="line"></span><br><span class="line">        rc = camera_open((<span class="keyword">uint8_t</span>)mCameraId, &amp;mCameraHandle);</span><br><span class="line">        <span class="keyword">if</span> (rc) &#123;</span><br><span class="line">            LOGE(<span class="string">"camera_open failed. rc = %d, mCameraHandle = %p"</span>,</span><br><span class="line">                     rc, mCameraHandle);</span><br><span class="line">            <span class="keyword">goto</span> error_exit2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(NO_ERROR != initCapabilities(mCameraId,mCameraHandle)) &#123;</span><br><span class="line">            LOGE(<span class="string">"initCapabilities failed."</span>);</span><br><span class="line">            rc = UNKNOWN_ERROR;</span><br><span class="line">            <span class="keyword">goto</span> error_exit3;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mCameraHandle-&gt;ops-&gt;register_event_notify(mCameraHandle-&gt;camera_handle,</span><br><span class="line">                camEvtHandle,</span><br><span class="line">                (<span class="keyword">void</span> *) <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mBundledSnapshot = <span class="number">0</span>;</span><br><span class="line">    mActiveCameras = MM_CAMERA_TYPE_MAIN;</span><br><span class="line">    <span class="keyword">if</span> (isDualCamera()) &#123;</span><br><span class="line">        mActiveCameras |= MM_CAMERA_TYPE_AUX;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create and initialize FOV-control object</span></span><br><span class="line">        m_pFovControl = QCameraFOVControl::create(gCamCapability[mCameraId]-&gt;main_cam_cap,</span><br><span class="line">                gCamCapability[mCameraId]-&gt;aux_cam_cap);</span><br><span class="line">        <span class="keyword">if</span> (m_pFovControl) &#123;</span><br><span class="line">            *gCamCapability[mCameraId] = m_pFovControl-&gt;consolidateCapabilities(</span><br><span class="line">                    gCamCapability[mCameraId]-&gt;main_cam_cap,</span><br><span class="line">                    gCamCapability[mCameraId]-&gt;aux_cam_cap);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            LOGE(<span class="string">"FOV-control: Failed to create an object"</span>);</span><br><span class="line">            rc = NO_MEMORY;</span><br><span class="line">            <span class="keyword">goto</span> error_exit3;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Init params in the background</span></span><br><span class="line">    <span class="comment">// 1. It's safe to queue init job, even if alloc job is not yet complete.</span></span><br><span class="line">    <span class="comment">// It will be queued to the same thread, so the alloc is guaranteed to</span></span><br><span class="line">    <span class="comment">// finish first.</span></span><br><span class="line">    <span class="comment">// 2. However, it is not safe to begin param init until after camera is</span></span><br><span class="line">    <span class="comment">// open. That is why we wait until after camera open completes to schedule</span></span><br><span class="line">    <span class="comment">// this task.</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;args, <span class="number">0</span>, <span class="keyword">sizeof</span>(args));</span><br><span class="line">    mParamInitJob = queueDeferredWork(CMD_DEF_PARAM_INIT, args);</span><br><span class="line">    <span class="keyword">if</span> (mParamInitJob == <span class="number">0</span>) &#123;</span><br><span class="line">        LOGE(<span class="string">"Failed queuing PARAM_INIT job"</span>);</span><br><span class="line">        rc = -ENOMEM;</span><br><span class="line">        <span class="keyword">goto</span> error_exit3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mCameraOpened = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Notify display HAL that a camera session is active.</span></span><br><span class="line">    <span class="comment">//But avoid calling the same during bootup because camera service might open/close</span></span><br><span class="line">    <span class="comment">//cameras at boot time during its initialization and display service will also internally</span></span><br><span class="line">    <span class="comment">//wait for camera service to initialize first while calling this display API, resulting in a</span></span><br><span class="line">    <span class="comment">//deadlock situation. Since boot time camera open/close calls are made only to fetch</span></span><br><span class="line">    <span class="comment">//capabilities, no need of this display bw optimization.</span></span><br><span class="line">    <span class="comment">//Use "service.bootanim.exit" property to know boot status.</span></span><br><span class="line">    property_get(<span class="string">"service.bootanim.exit"</span>, value, <span class="string">"0"</span>);</span><br><span class="line">    <span class="keyword">if</span> (atoi(value) == <span class="number">1</span>) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;gCamLock);</span><br><span class="line">        <span class="keyword">if</span> (gNumCameraSessions++ == <span class="number">0</span>) &#123;</span><br><span class="line">            setCameraLaunchStatus(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_mutex_unlock(&amp;gCamLock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Setprop to decide the time source (whether boottime or monotonic).</span></span><br><span class="line">    <span class="comment">// By default, use monotonic time.</span></span><br><span class="line">    property_get(<span class="string">"persist.camera.time.monotonic"</span>, value, <span class="string">"1"</span>);</span><br><span class="line">    mBootToMonoTimestampOffset = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (atoi(value) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// if monotonic is set, then need to use time in monotonic.</span></span><br><span class="line">        <span class="comment">// So, Measure the clock offset between BOOTTIME and MONOTONIC</span></span><br><span class="line">        <span class="comment">// The clock domain source for ISP is BOOTTIME and</span></span><br><span class="line">        <span class="comment">// for Video/display is MONOTONIC</span></span><br><span class="line">        <span class="comment">// The below offset is used to convert from clock domain of other subsystem</span></span><br><span class="line">        <span class="comment">// (video/hardware composer) to that of camera. Assumption is that this</span></span><br><span class="line">        <span class="comment">// offset won't change during the life cycle of the camera device. In other</span></span><br><span class="line">        <span class="comment">// words, camera device shouldn't be open during CPU suspend.</span></span><br><span class="line">        mBootToMonoTimestampOffset = getBootToMonoTimeOffset();</span><br><span class="line">    &#125;</span><br><span class="line">    LOGH(<span class="string">"mBootToMonoTimestampOffset = %lld"</span>, mBootToMonoTimestampOffset);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(value, <span class="number">0</span>, <span class="keyword">sizeof</span>(value));</span><br><span class="line">    property_get(<span class="string">"persist.camera.depth.focus.cb"</span>, value, <span class="string">"1"</span>);</span><br><span class="line">    bDepthAFCallbacks = atoi(value);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(value, <span class="number">0</span>, <span class="keyword">sizeof</span>(value));</span><br><span class="line">    property_get(<span class="string">"persist.camera.cache.optimize"</span>, value, <span class="string">"1"</span>);</span><br><span class="line">    m_bOptimizeCacheOps = atoi(value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line"></span><br><span class="line">error_exit3:</span><br><span class="line">    <span class="keyword">if</span>(mJpegClientHandle) &#123;</span><br><span class="line">        deinitJpegHandle();</span><br><span class="line">    &#125;</span><br><span class="line">    mCameraHandle-&gt;ops-&gt;close_camera(mCameraHandle-&gt;camera_handle);</span><br><span class="line">    mCameraHandle = <span class="literal">NULL</span>;</span><br><span class="line">error_exit2:</span><br><span class="line">    waitDeferredWork(mMetadataAllocJob);</span><br><span class="line">error_exit1:</span><br><span class="line">    waitDeferredWork(mParamAllocJob);</span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mm-camera-interface"><a href="#mm-camera-interface" class="headerlink" title="mm-camera-interface"></a>mm-camera-interface</h3><p>有一个camera_open方法,实现在QCamera2/stack/mm-camera-interface/src/mm_camera_interface.c里,这里都是一些相机非常底层方法了,一些公共定义的方法,进而调用到驱动层.打出的代码在libmmcamera_interface.so.</p><p>找到实现方法:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int32_t</span> camera_open(<span class="keyword">uint8_t</span> camera_idx, <span class="keyword">mm_camera_vtbl_t</span> **camera_vtbl)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> rc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">mm_camera_obj_t</span> *cam_obj = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> cam_idx = camera_idx;</span><br><span class="line">    <span class="keyword">uint32_t</span> aux_idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint8_t</span> is_multi_camera = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> QCAMERA_REDEFINE_LOG</span></span><br><span class="line">    mm_camera_debug_open();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    LOGD(<span class="string">"E camera_idx = %d\n"</span>, camera_idx);</span><br><span class="line">    <span class="keyword">if</span> (is_dual_camera_by_idx(camera_idx)) &#123;</span><br><span class="line">        is_multi_camera = <span class="number">1</span>;</span><br><span class="line">        cam_idx = mm_camera_util_get_handle_by_num(<span class="number">0</span>,</span><br><span class="line">                g_cam_ctrl.cam_index[camera_idx]);</span><br><span class="line">        aux_idx = (get_aux_camera_handle(g_cam_ctrl.cam_index[camera_idx])</span><br><span class="line">                &gt;&gt; MM_CAMERA_HANDLE_SHIFT_MASK);</span><br><span class="line">        LOGH(<span class="string">"Dual Camera: Main ID = %d Aux ID = %d"</span>, cam_idx, aux_idx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cam_idx &gt;= (<span class="keyword">uint32_t</span>)g_cam_ctrl.num_cam || cam_idx &gt;=</span><br><span class="line">        MM_CAMERA_MAX_NUM_SENSORS || aux_idx &gt;= MM_CAMERA_MAX_NUM_SENSORS) &#123;</span><br><span class="line">        LOGE(<span class="string">"Invalid camera_idx (%d)"</span>, cam_idx);</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;g_intf_lock);</span><br><span class="line">    <span class="comment">/* opened already */</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> != g_cam_ctrl.cam_obj[cam_idx] &amp;&amp;</span><br><span class="line">            g_cam_ctrl.cam_obj[cam_idx]-&gt;ref_count != <span class="number">0</span>) &#123;</span><br><span class="line">        pthread_mutex_unlock(&amp;g_intf_lock);</span><br><span class="line">        LOGE(<span class="string">"Camera %d is already open"</span>, cam_idx);</span><br><span class="line">        <span class="keyword">return</span> -EBUSY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cam_obj = (<span class="keyword">mm_camera_obj_t</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">mm_camera_obj_t</span>));</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == cam_obj) &#123;</span><br><span class="line">        pthread_mutex_unlock(&amp;g_intf_lock);</span><br><span class="line">        LOGE(<span class="string">"no mem"</span>);</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* initialize camera obj */</span></span><br><span class="line">    <span class="built_in">memset</span>(cam_obj, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">mm_camera_obj_t</span>));</span><br><span class="line">    cam_obj-&gt;ctrl_fd = <span class="number">-1</span>;</span><br><span class="line">    cam_obj-&gt;ds_fd = <span class="number">-1</span>;</span><br><span class="line">    cam_obj-&gt;ref_count++;</span><br><span class="line">    cam_obj-&gt;my_num = <span class="number">0</span>;</span><br><span class="line">    cam_obj-&gt;my_hdl = mm_camera_util_generate_handler(cam_idx);</span><br><span class="line">    cam_obj-&gt;vtbl.camera_handle = cam_obj-&gt;my_hdl; <span class="comment">/* set handler */</span></span><br><span class="line">    cam_obj-&gt;vtbl.ops = &amp;mm_camera_ops;</span><br><span class="line">    pthread_mutex_init(&amp;cam_obj-&gt;cam_lock, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_init(&amp;cam_obj-&gt;muxer_lock, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">/* unlock global interface lock, if not, in dual camera use case,</span></span><br><span class="line"><span class="comment">      * current open will block operation of another opened camera obj*/</span></span><br><span class="line">    pthread_mutex_lock(&amp;cam_obj-&gt;cam_lock);</span><br><span class="line">    pthread_mutex_unlock(&amp;g_intf_lock);</span><br><span class="line"></span><br><span class="line">    rc = mm_camera_open(cam_obj);</span><br><span class="line">    <span class="keyword">if</span> (rc != <span class="number">0</span>) &#123;</span><br><span class="line">        LOGE(<span class="string">"mm_camera_open err = %d"</span>, rc);</span><br><span class="line">        pthread_mutex_destroy(&amp;cam_obj-&gt;cam_lock);</span><br><span class="line">        pthread_mutex_lock(&amp;g_intf_lock);</span><br><span class="line">        g_cam_ctrl.cam_obj[cam_idx] = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">free</span>(cam_obj);</span><br><span class="line">        cam_obj = <span class="literal">NULL</span>;</span><br><span class="line">        pthread_mutex_unlock(&amp;g_intf_lock);</span><br><span class="line">        *camera_vtbl = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> rc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is_multi_camera) &#123;</span><br><span class="line">        <span class="comment">/*Open Aux camer's*/</span></span><br><span class="line">        pthread_mutex_lock(&amp;g_intf_lock);</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span> != g_cam_ctrl.cam_obj[aux_idx] &amp;&amp;</span><br><span class="line">                g_cam_ctrl.cam_obj[aux_idx]-&gt;ref_count != <span class="number">0</span>) &#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;g_intf_lock);</span><br><span class="line">            LOGE(<span class="string">"Camera %d is already open"</span>, aux_idx);</span><br><span class="line">            rc = -EBUSY;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pthread_mutex_lock(&amp;cam_obj-&gt;muxer_lock);</span><br><span class="line">            pthread_mutex_unlock(&amp;g_intf_lock);</span><br><span class="line">            rc = mm_camera_muxer_camera_open(aux_idx, cam_obj);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rc != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int32_t</span> temp_rc = <span class="number">0</span>;</span><br><span class="line">            LOGE(<span class="string">"muxer open err = %d"</span>, rc);</span><br><span class="line">            pthread_mutex_lock(&amp;g_intf_lock);</span><br><span class="line">            g_cam_ctrl.cam_obj[cam_idx] = <span class="literal">NULL</span>;</span><br><span class="line">            pthread_mutex_lock(&amp;cam_obj-&gt;cam_lock);</span><br><span class="line">            pthread_mutex_unlock(&amp;g_intf_lock);</span><br><span class="line">            temp_rc = mm_camera_close(cam_obj);</span><br><span class="line">            pthread_mutex_destroy(&amp;cam_obj-&gt;cam_lock);</span><br><span class="line">            pthread_mutex_destroy(&amp;cam_obj-&gt;muxer_lock);</span><br><span class="line">            <span class="built_in">free</span>(cam_obj);</span><br><span class="line">            cam_obj = <span class="literal">NULL</span>;</span><br><span class="line">            *camera_vtbl = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="comment">// Propagate the original error to caller</span></span><br><span class="line">            <span class="keyword">return</span> rc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LOGH(<span class="string">"Open succeded: handle = %d"</span>, cam_obj-&gt;vtbl.camera_handle);</span><br><span class="line">    g_cam_ctrl.cam_obj[cam_idx] = cam_obj;</span><br><span class="line">    *camera_vtbl = &amp;cam_obj-&gt;vtbl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里出了一些状态值设置,实际调用的是mm_camera_open方法,如果双摄,则是mm_camera_muxer_camera_open方法,在mm_camera.c中找到实现:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int32_t</span> mm_camera_open(<span class="keyword">mm_camera_obj_t</span> *my_obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> dev_name[MM_CAMERA_DEV_NAME_LEN];</span><br><span class="line">    <span class="keyword">int32_t</span> rc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int8_t</span> n_try=MM_CAMERA_DEV_OPEN_TRIES;</span><br><span class="line">    <span class="keyword">uint8_t</span> sleep_msec=MM_CAMERA_DEV_OPEN_RETRY_SLEEP;</span><br><span class="line">    <span class="keyword">int</span> cam_idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *dev_name_value = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> l_errno = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    LOGD(<span class="string">"begin\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == my_obj) &#123;</span><br><span class="line">        <span class="keyword">goto</span> on_error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dev_name_value = mm_camera_util_get_dev_name_by_num(my_obj-&gt;my_num,</span><br><span class="line">            my_obj-&gt;my_hdl);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == dev_name_value) &#123;</span><br><span class="line">        <span class="keyword">goto</span> on_error;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">snprintf</span>(dev_name, <span class="keyword">sizeof</span>(dev_name), <span class="string">"/dev/%s"</span>,</span><br><span class="line">             dev_name_value);</span><br><span class="line">    <span class="built_in">sscanf</span>(dev_name, <span class="string">"/dev/video%d"</span>, &amp;cam_idx);</span><br><span class="line">    LOGD(<span class="string">"dev name = %s, cam_idx = %d"</span>, dev_name, cam_idx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        n_try--;</span><br><span class="line">        errno = <span class="number">0</span>;</span><br><span class="line">        my_obj-&gt;ctrl_fd = open(dev_name, O_RDWR | O_NONBLOCK);</span><br><span class="line">        l_errno = errno;</span><br><span class="line">        LOGD(<span class="string">"ctrl_fd = %d, errno == %d"</span>, my_obj-&gt;ctrl_fd, l_errno);</span><br><span class="line">        <span class="keyword">if</span>((my_obj-&gt;ctrl_fd &gt;= <span class="number">0</span>) || (errno != EIO &amp;&amp; errno != ETIMEDOUT) || (n_try &lt;= <span class="number">0</span> )) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LOGE(<span class="string">"Failed with %s error, retrying after %d milli-seconds"</span>,</span><br><span class="line">              strerror(errno), sleep_msec);</span><br><span class="line">        usleep(sleep_msec * <span class="number">1000U</span>);</span><br><span class="line">    &#125;<span class="keyword">while</span> (n_try &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (my_obj-&gt;ctrl_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        LOGE(<span class="string">"cannot open control fd of '%s' (%s)\n"</span>,</span><br><span class="line">                  dev_name, strerror(l_errno));</span><br><span class="line">        <span class="keyword">if</span> (l_errno == EBUSY)</span><br><span class="line">            rc = -EUSERS;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            rc = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">goto</span> on_error;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mm_camera_get_session_id(my_obj, &amp;my_obj-&gt;sessionid);</span><br><span class="line">        LOGH(<span class="string">"Camera Opened id = %d sessionid = %d"</span>, cam_idx, my_obj-&gt;sessionid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DAEMON_PRESENT</span></span><br><span class="line">    <span class="comment">/* open domain socket*/</span></span><br><span class="line">    n_try = MM_CAMERA_DEV_OPEN_TRIES;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        n_try--;</span><br><span class="line">        my_obj-&gt;ds_fd = mm_camera_socket_create(cam_idx, MM_CAMERA_SOCK_TYPE_UDP);</span><br><span class="line">        l_errno = errno;</span><br><span class="line">        LOGD(<span class="string">"ds_fd = %d, errno = %d"</span>, my_obj-&gt;ds_fd, l_errno);</span><br><span class="line">        <span class="keyword">if</span>((my_obj-&gt;ds_fd &gt;= <span class="number">0</span>) || (n_try &lt;= <span class="number">0</span> )) &#123;</span><br><span class="line">            LOGD(<span class="string">"opened, break out while loop"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LOGD(<span class="string">"failed with I/O error retrying after %d milli-seconds"</span>,</span><br><span class="line">              sleep_msec);</span><br><span class="line">        usleep(sleep_msec * <span class="number">1000U</span>);</span><br><span class="line">    &#125; <span class="keyword">while</span> (n_try &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (my_obj-&gt;ds_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        LOGE(<span class="string">"cannot open domain socket fd of '%s'(%s)\n"</span>,</span><br><span class="line">                  dev_name, strerror(l_errno));</span><br><span class="line">        rc = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">goto</span> on_error;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* DAEMON_PRESENT */</span></span></span><br><span class="line">    <span class="keyword">cam_status_t</span> cam_status;</span><br><span class="line">    cam_status = mm_camera_module_open_session(my_obj-&gt;sessionid,</span><br><span class="line">            mm_camera_module_event_handler);</span><br><span class="line">    <span class="keyword">if</span> (cam_status &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        LOGE(<span class="string">"Failed to open session"</span>);</span><br><span class="line">        <span class="keyword">if</span> (cam_status == CAM_STATUS_BUSY) &#123;</span><br><span class="line">            rc = -EUSERS;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            rc = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">goto</span> on_error;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* DAEMON_PRESENT */</span></span></span><br><span class="line"></span><br><span class="line">    pthread_mutex_init(&amp;my_obj-&gt;msg_lock, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_init(&amp;my_obj-&gt;cb_lock, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_init(&amp;my_obj-&gt;evt_lock, <span class="literal">NULL</span>);</span><br><span class="line">    PTHREAD_COND_INIT(&amp;my_obj-&gt;evt_cond);</span><br><span class="line"></span><br><span class="line">    LOGD(<span class="string">"Launch evt Thread in Cam Open"</span>);</span><br><span class="line">    <span class="built_in">snprintf</span>(my_obj-&gt;evt_thread.threadName, THREAD_NAME_SIZE, <span class="string">"CAM_Dispatch"</span>);</span><br><span class="line">    mm_camera_cmd_thread_launch(&amp;my_obj-&gt;evt_thread,</span><br><span class="line">                                mm_camera_dispatch_app_event,</span><br><span class="line">                                (<span class="keyword">void</span> *)my_obj);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* launch event poll thread</span></span><br><span class="line"><span class="comment">     * we will add evt fd into event poll thread upon user first register for evt */</span></span><br><span class="line">    LOGD(<span class="string">"Launch evt Poll Thread in Cam Open"</span>);</span><br><span class="line">    <span class="built_in">snprintf</span>(my_obj-&gt;evt_poll_thread.threadName, THREAD_NAME_SIZE, <span class="string">"CAM_evntPoll"</span>);</span><br><span class="line">    mm_camera_poll_thread_launch(&amp;my_obj-&gt;evt_poll_thread,</span><br><span class="line">                                 MM_CAMERA_POLL_TYPE_EVT);</span><br><span class="line">    mm_camera_evt_sub(my_obj, TRUE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* unlock cam_lock, we need release global intf_lock in camera_open(),</span></span><br><span class="line"><span class="comment">     * in order not block operation of other Camera in dual camera use case.*/</span></span><br><span class="line">    pthread_mutex_unlock(&amp;my_obj-&gt;cam_lock);</span><br><span class="line">    LOGD(<span class="string">"end (rc = %d)\n"</span>, rc);</span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line"></span><br><span class="line">on_error:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == dev_name_value) &#123;</span><br><span class="line">        LOGE(<span class="string">"Invalid device name\n"</span>);</span><br><span class="line">        rc = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == my_obj) &#123;</span><br><span class="line">        LOGE(<span class="string">"Invalid camera object\n"</span>);</span><br><span class="line">        rc = <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (my_obj-&gt;ctrl_fd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            close(my_obj-&gt;ctrl_fd);</span><br><span class="line">            my_obj-&gt;ctrl_fd = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DAEMON_PRESENT</span></span><br><span class="line">        <span class="keyword">if</span> (my_obj-&gt;ds_fd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            mm_camera_socket_close(my_obj-&gt;ds_fd);</span><br><span class="line">            my_obj-&gt;ds_fd = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* unlock cam_lock, we need release global intf_lock in camera_open(),</span></span><br><span class="line"><span class="comment">     * in order not block operation of other Camera in dual camera use case.*/</span></span><br><span class="line">    pthread_mutex_unlock(&amp;my_obj-&gt;cam_lock);</span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里看到一个很特别会尝试多次打开,MM_CAMERA_DEV_OPEN_TRIES值看到定义为20,每次失败都会睡眠一定时间.<br>打开驱动设备的方法是open(dev_name, O_RDWR | O_NONBLOCK),这里应该就调用到了驱动层了.剩下的操作看到有打开会话,初始化消息锁等.</p><p>回头看QCamera2HardwareInterface,其定义了一个camera_device_ops_t</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">camera_device_ops_t</span> QCamera2HardwareInterface::mCameraOps = &#123;</span><br><span class="line">    .set_preview_window =        QCamera2HardwareInterface::set_preview_window,</span><br><span class="line">    .set_callbacks =             QCamera2HardwareInterface::set_CallBacks,</span><br><span class="line">    .enable_msg_type =           QCamera2HardwareInterface::enable_msg_type,</span><br><span class="line">    .disable_msg_type =          QCamera2HardwareInterface::disable_msg_type,</span><br><span class="line">    .msg_type_enabled =          QCamera2HardwareInterface::msg_type_enabled,</span><br><span class="line"></span><br><span class="line">    .start_preview =             QCamera2HardwareInterface::start_preview,</span><br><span class="line">    .stop_preview =              QCamera2HardwareInterface::stop_preview,</span><br><span class="line">    .preview_enabled =           QCamera2HardwareInterface::preview_enabled,</span><br><span class="line">    .store_meta_data_in_buffers= QCamera2HardwareInterface::store_meta_data_in_buffers,</span><br><span class="line"></span><br><span class="line">    .start_recording =           QCamera2HardwareInterface::start_recording,</span><br><span class="line">    .stop_recording =            QCamera2HardwareInterface::stop_recording,</span><br><span class="line">    .recording_enabled =         QCamera2HardwareInterface::recording_enabled,</span><br><span class="line">    .release_recording_frame =   QCamera2HardwareInterface::release_recording_frame,</span><br><span class="line"></span><br><span class="line">    .auto_focus =                QCamera2HardwareInterface::auto_focus,</span><br><span class="line">    .cancel_auto_focus =         QCamera2HardwareInterface::cancel_auto_focus,</span><br><span class="line"></span><br><span class="line">    .take_picture =              QCamera2HardwareInterface::take_picture,</span><br><span class="line">    .cancel_picture =            QCamera2HardwareInterface::cancel_picture,</span><br><span class="line"></span><br><span class="line">    .set_parameters =            QCamera2HardwareInterface::set_parameters,</span><br><span class="line">    .get_parameters =            QCamera2HardwareInterface::get_parameters,</span><br><span class="line">    .put_parameters =            QCamera2HardwareInterface::put_parameters,</span><br><span class="line">    .send_command =              QCamera2HardwareInterface::send_command,</span><br><span class="line"></span><br><span class="line">    .release =                   QCamera2HardwareInterface::release,</span><br><span class="line">    .dump =                      QCamera2HardwareInterface::dump,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>初始化时传给了mCameraDevice.ops.</p><h3 id="流程总结"><a href="#流程总结" class="headerlink" title="流程总结"></a>流程总结</h3><p>相机hal注册及打开设备流程:</p><ol><li>QCamera2Hal注册一个hal模块结构hw_module_t,注册了模块方法QCamera2Factory::mModuleMethods</li><li>mModuleMethods的open方法包含camera_device_open方法</li><li>camera_device_open方法根据不同情况调用,最终调用QCamera2HardwareInterface的openCamera方法</li><li>QCamera2HardwareInterface有一个camera_device_t变量mCameraDevice,内包含注册注册hal方法的camera_device_ops_t和hal设备模板hw_device_t</li><li>openCamera方法调用mm_camera_interface的camera_open,再到mm_camera_open</li><li>mm_camera_open会尝试多次打开驱动,使用open(dev_name, O_RDWR | O_NONBLOCK)调用到驱动层方法</li></ol><h2 id="hal拍照流程"><a href="#hal拍照流程" class="headerlink" title="hal拍照流程"></a>hal拍照流程</h2><p>接下来分析下hal层拍照的流程从而梳理下hal层代码.</p><h3 id="发起请求"><a href="#发起请求" class="headerlink" title="发起请求"></a>发起请求</h3><p>发起请求的方法就是上面注册的take_picture方法:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> QCamera2HardwareInterface::take_picture(struct camera_device *device)</span><br><span class="line">&#123;</span><br><span class="line">    KPI_ATRACE_CAMSCOPE_CALL(CAMSCOPE_HAL1_TAKE_PICTURE);</span><br><span class="line">    <span class="keyword">int</span> ret = NO_ERROR;</span><br><span class="line">    QCamera2HardwareInterface *hw =</span><br><span class="line">        <span class="keyword">reinterpret_cast</span>&lt;QCamera2HardwareInterface *&gt;(device-&gt;priv);</span><br><span class="line">    <span class="keyword">if</span> (!hw) &#123;</span><br><span class="line">        LOGE(<span class="string">"NULL camera device"</span>);</span><br><span class="line">        <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    LOGI(<span class="string">"[KPI Perf]: E PROFILE_TAKE_PICTURE camera id %d"</span>,</span><br><span class="line">             hw-&gt;getCameraId());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Acquire the perf lock for JPEG snapshot only</span></span><br><span class="line">    <span class="keyword">if</span> (hw-&gt;mParameters.isJpegPictureFormat()) &#123;</span><br><span class="line">        hw-&gt;m_perfLockMgr.acquirePerfLock(PERF_LOCK_TAKE_SNAPSHOT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">qcamera_api_result_t</span> apiResult;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/** Added support for Retro-active Frames:</span></span><br><span class="line"><span class="comment">     *  takePicture() is called before preparing Snapshot to indicate the</span></span><br><span class="line"><span class="comment">     *  mm-camera-channel to pick up legacy frames even</span></span><br><span class="line"><span class="comment">     *  before LED estimation is triggered.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    LOGH(<span class="string">"isLiveSnap %d, isZSL %d, isHDR %d longshot = %d"</span>,</span><br><span class="line">           hw-&gt;isLiveSnapshot(), hw-&gt;isZSLMode(), hw-&gt;isHDRMode(),</span><br><span class="line">           hw-&gt;isLongshotEnabled());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check for Retro-active Frames</span></span><br><span class="line">    <span class="keyword">if</span> ((hw-&gt;mParameters.getNumOfRetroSnapshots() &gt; <span class="number">0</span>) &amp;&amp;</span><br><span class="line">        !hw-&gt;isLiveSnapshot() &amp;&amp; hw-&gt;isZSLMode() &amp;&amp;</span><br><span class="line">        !hw-&gt;isHDRMode() &amp;&amp; !hw-&gt;isLongshotEnabled()) &#123;</span><br><span class="line">        <span class="comment">// Set Retro Picture Mode</span></span><br><span class="line">        hw-&gt;setRetroPicture(<span class="number">1</span>);</span><br><span class="line">        hw-&gt;m_bLedAfAecLock = <span class="number">0</span>;</span><br><span class="line">        LOGL(<span class="string">"Retro Enabled"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Give HWI control to call pre_take_picture in single camera mode.</span></span><br><span class="line">        <span class="comment">// In dual-cam mode, this control belongs to muxer.</span></span><br><span class="line">        <span class="keyword">if</span> (hw-&gt;getRelatedCamSyncInfo()-&gt;sync_control != CAM_SYNC_RELATED_SENSORS_ON) &#123;</span><br><span class="line">            ret = pre_take_picture(device);</span><br><span class="line">            <span class="keyword">if</span> (ret != NO_ERROR) &#123;</span><br><span class="line">                LOGE(<span class="string">"pre_take_picture failed with ret = %d"</span>,ret);</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Call take Picture for total number of snapshots required.</span></span><br><span class="line"><span class="comment">             This includes the number of retro frames and normal frames */</span></span><br><span class="line">        hw-&gt;lockAPI();</span><br><span class="line">        ret = hw-&gt;processAPI(QCAMERA_SM_EVT_TAKE_PICTURE, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret == NO_ERROR) &#123;</span><br><span class="line">          <span class="comment">// Wait for retro frames, before calling prepare snapshot</span></span><br><span class="line">          LOGD(<span class="string">"Wait for Retro frames to be done"</span>);</span><br><span class="line">          hw-&gt;waitAPIResult(QCAMERA_SM_EVT_TAKE_PICTURE, &amp;apiResult);</span><br><span class="line">            ret = apiResult.status;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Unlock API since it is acquired in prepare snapshot seperately */</span></span><br><span class="line">        hw-&gt;unlockAPI();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Prepare snapshot in case LED needs to be flashed */</span></span><br><span class="line">        LOGD(<span class="string">"Start Prepare Snapshot"</span>);</span><br><span class="line">        ret = hw-&gt;prepare_snapshot(device);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        hw-&gt;setRetroPicture(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// Check if prepare snapshot is done</span></span><br><span class="line">        <span class="keyword">if</span> (!hw-&gt;mPrepSnapRun) &#123;</span><br><span class="line">            <span class="comment">// Ignore the status from prepare_snapshot</span></span><br><span class="line">            hw-&gt;prepare_snapshot(device);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Give HWI control to call pre_take_picture in single camera mode.</span></span><br><span class="line">        <span class="comment">// In dual-cam mode, this control belongs to muxer.</span></span><br><span class="line">        <span class="keyword">if</span> (hw-&gt;getRelatedCamSyncInfo()-&gt;sync_control != CAM_SYNC_RELATED_SENSORS_ON) &#123;</span><br><span class="line">            ret = pre_take_picture(device);</span><br><span class="line">            <span class="keyword">if</span> (ret != NO_ERROR) &#123;</span><br><span class="line">                LOGE(<span class="string">"pre_take_picture failed with ret = %d"</span>,ret);</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Regardless what the result value for prepare_snapshot,</span></span><br><span class="line">        <span class="comment">// go ahead with capture anyway. Just like the way autofocus</span></span><br><span class="line">        <span class="comment">// is handled in capture case</span></span><br><span class="line">        <span class="comment">/* capture */</span></span><br><span class="line">        LOGL(<span class="string">"Capturing normal frames"</span>);</span><br><span class="line">        hw-&gt;lockAPI();</span><br><span class="line">        ret = hw-&gt;processAPI(QCAMERA_SM_EVT_TAKE_PICTURE, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret == NO_ERROR) &#123;</span><br><span class="line">          hw-&gt;waitAPIResult(QCAMERA_SM_EVT_TAKE_PICTURE, &amp;apiResult);</span><br><span class="line">            ret = apiResult.status;</span><br><span class="line">        &#125;</span><br><span class="line">        hw-&gt;unlockAPI();</span><br><span class="line">        <span class="keyword">if</span> (!hw-&gt;isLongshotEnabled())&#123;</span><br><span class="line">            <span class="comment">// For longshot mode, we prepare snapshot only once</span></span><br><span class="line">            hw-&gt;mPrepSnapRun = <span class="literal">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    LOGI(<span class="string">"[KPI Perf]: X ret = %d"</span>, ret);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>调用processAPI传递消息,如果没有错误,则使用waitAPIResult等待结果:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> QCamera2HardwareInterface::processAPI(<span class="keyword">qcamera_sm_evt_enum_t</span> api, <span class="keyword">void</span> *api_payload)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = DEAD_OBJECT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m_smThreadActive) &#123;</span><br><span class="line">        ret = m_stateMachine.procAPI(api, api_payload);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里又调用到相机状态机:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*===========================================================================</span></span><br><span class="line"><span class="comment"> * FUNCTION   : procEvt</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * DESCRIPTION: process incoming envent from mm-camera-interface and</span></span><br><span class="line"><span class="comment"> *              mm-jpeg-interface.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * PARAMETERS :</span></span><br><span class="line"><span class="comment"> *   @evt          : event to be processed</span></span><br><span class="line"><span class="comment"> *   @evt_payload  : event payload. Can be NULL if not needed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * RETURN     : int32_t type of status</span></span><br><span class="line"><span class="comment"> *              NO_ERROR  -- success</span></span><br><span class="line"><span class="comment"> *              none-zero failure code</span></span><br><span class="line"><span class="comment"> *==========================================================================*/</span></span><br><span class="line"><span class="keyword">int32_t</span> QCameraStateMachine::procAPI(<span class="keyword">qcamera_sm_evt_enum_t</span> evt,</span><br><span class="line">                                     <span class="keyword">void</span> *api_payload)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">qcamera_sm_cmd_t</span> *node =</span><br><span class="line">        (<span class="keyword">qcamera_sm_cmd_t</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">qcamera_sm_cmd_t</span>));</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == node) &#123;</span><br><span class="line">        LOGE(<span class="string">"No memory for qcamera_sm_cmd_t"</span>);</span><br><span class="line">        <span class="keyword">return</span> NO_MEMORY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(node, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">qcamera_sm_cmd_t</span>));</span><br><span class="line">    node-&gt;cmd = QCAMERA_SM_CMD_TYPE_API;</span><br><span class="line">    node-&gt;evt = evt;</span><br><span class="line">    node-&gt;evt_payload = api_payload;</span><br><span class="line">    <span class="keyword">if</span> (api_queue.enqueue((<span class="keyword">void</span> *)node)) &#123;</span><br><span class="line">        cam_sem_post(&amp;cmd_sem);</span><br><span class="line">        <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        LOGE(<span class="string">"API enqueue failed API = %d"</span>, evt);</span><br><span class="line">        <span class="built_in">free</span>(node);</span><br><span class="line">        <span class="keyword">return</span> UNKNOWN_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注释说明这里是处理mm-camera-interface和mm-jpeg-interface的消息.<br>这里在列队里添加一个消息,然后信号量同步.cam_sem_post方法在cam_semaphore.h中,不深入看了.<br>继续看QCameraQueue::enqueue方法:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> QCameraQueue::enqueue(<span class="keyword">void</span> *data)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">bool</span> rc;</span><br><span class="line">    camera_q_node *node =</span><br><span class="line">        (camera_q_node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(camera_q_node));</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == node) &#123;</span><br><span class="line">        LOGE(<span class="string">"No memory for camera_q_node"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(node, <span class="number">0</span>, <span class="keyword">sizeof</span>(camera_q_node));</span><br><span class="line">    node-&gt;data = data;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;m_lock);</span><br><span class="line">    <span class="keyword">if</span> (m_active) &#123;</span><br><span class="line">        cam_list_add_tail_node(&amp;node-&gt;<span class="built_in">list</span>, &amp;m_head.<span class="built_in">list</span>);</span><br><span class="line">        m_size++;</span><br><span class="line">        rc = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">free</span>(node);</span><br><span class="line">        rc = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;m_lock);</span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在队尾添加了一个节点,cam_list_add_tail_node也是在stack/common中的方法.</p><h3 id="状态机处理"><a href="#状态机处理" class="headerlink" title="状态机处理"></a>状态机处理</h3><p>消息进队后还是得找到处理消息的方法,回到QCameraStateMachine,其有一个周期性方法smEvtProcRoutine,初始化时起了一个线程循环调用.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*===========================================================================</span></span><br><span class="line"><span class="comment"> * FUNCTION   : smEvtProcRoutine</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * DESCRIPTION: Statemachine process thread routine to handle events</span></span><br><span class="line"><span class="comment"> *              in different state.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * PARAMETERS :</span></span><br><span class="line"><span class="comment"> *   @data    : ptr to QCameraStateMachine object</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * RETURN     : none</span></span><br><span class="line"><span class="comment"> *==========================================================================*/</span></span><br><span class="line"><span class="keyword">void</span> *QCameraStateMachine::smEvtProcRoutine(<span class="keyword">void</span> *data)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> running = <span class="number">1</span>, ret;</span><br><span class="line">    QCameraStateMachine *pme = (QCameraStateMachine *)data;</span><br><span class="line"></span><br><span class="line">    LOGH(<span class="string">"E"</span>);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            ret = cam_sem_wait(&amp;pme-&gt;cmd_sem);</span><br><span class="line">            <span class="keyword">if</span> (ret != <span class="number">0</span> &amp;&amp; errno != EINVAL) &#123;</span><br><span class="line">                LOGE(<span class="string">"cam_sem_wait error (%s)"</span>,</span><br><span class="line">                            strerror(errno));</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (ret != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// we got notified about new cmd avail in cmd queue</span></span><br><span class="line">        <span class="comment">// first check API cmd queue</span></span><br><span class="line">        <span class="keyword">qcamera_sm_cmd_t</span> *node = (<span class="keyword">qcamera_sm_cmd_t</span> *)pme-&gt;api_queue.dequeue();</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// no API cmd, then check evt cmd queue</span></span><br><span class="line">            node = (<span class="keyword">qcamera_sm_cmd_t</span> *)pme-&gt;evt_queue.dequeue();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (node-&gt;cmd) &#123;</span><br><span class="line">            <span class="keyword">case</span> QCAMERA_SM_CMD_TYPE_API:</span><br><span class="line">                pme-&gt;stateMachine(node-&gt;evt, node-&gt;evt_payload);</span><br><span class="line">                <span class="comment">// API is in a way sync call, so evt_payload is managed by HWI</span></span><br><span class="line">                <span class="comment">// no need to free payload for API</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> QCAMERA_SM_CMD_TYPE_EVT:</span><br><span class="line">                pme-&gt;stateMachine(node-&gt;evt, node-&gt;evt_payload);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// EVT is async call, so payload need to be free after use</span></span><br><span class="line">                <span class="built_in">free</span>(node-&gt;evt_payload);</span><br><span class="line">                node-&gt;evt_payload = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> QCAMERA_SM_CMD_TYPE_EXIT:</span><br><span class="line">                running = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">free</span>(node);</span><br><span class="line">            node = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (running);</span><br><span class="line">    LOGH(<span class="string">"X"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*===========================================================================</span></span><br><span class="line"><span class="comment"> * FUNCTION   : QCameraStateMachine</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * DESCRIPTION: constructor of QCameraStateMachine. Will start process thread</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * PARAMETERS :</span></span><br><span class="line"><span class="comment"> *   @ctrl    : ptr to HWI object</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * RETURN     : none</span></span><br><span class="line"><span class="comment"> *==========================================================================*/</span></span><br><span class="line">QCameraStateMachine::QCameraStateMachine(QCamera2HardwareInterface *ctrl) :</span><br><span class="line">    api_queue(),</span><br><span class="line">    evt_queue()</span><br><span class="line">&#123;</span><br><span class="line">    m_parent = ctrl;</span><br><span class="line">    m_state = QCAMERA_SM_STATE_PREVIEW_STOPPED;</span><br><span class="line">    cmd_pid = <span class="number">0</span>;</span><br><span class="line">    cam_sem_init(&amp;cmd_sem, <span class="number">0</span>);</span><br><span class="line">    xunh(&amp;cmd_pid,</span><br><span class="line">                   <span class="literal">NULL</span>,</span><br><span class="line">                   smEvtProcRoutine,</span><br><span class="line">                   <span class="keyword">this</span>);</span><br><span class="line">    pthread_setname_np(cmd_pid, <span class="string">"CAM_stMachine"</span>);</span><br><span class="line">    m_bDelayPreviewMsgs = <span class="literal">false</span>;</span><br><span class="line">    m_DelayedMsgs = <span class="number">0</span>;</span><br><span class="line">    m_RestoreZSL = TRUE;</span><br><span class="line">    m_bPreviewCallbackNeeded = TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>smEvtProcRoutine就是通过信号量判断是否有消息等待,然后通过api_queue.dequeue()就是QCameraQueue的出队方法获取命令.<br>然后通过stateMachine(node-&gt;evt, node-&gt;evt_payload)方法处理,QCAMERA_SM_CMD_TYPE_API不需要清空消息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int32_t</span> QCameraStateMachine::stateMachine(<span class="keyword">qcamera_sm_evt_enum_t</span> evt, <span class="keyword">void</span> *payload)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> rc = NO_ERROR;</span><br><span class="line">    LOGL(<span class="string">"m_state %d, event (%d)"</span>, m_state, evt);</span><br><span class="line">    <span class="keyword">switch</span> (m_state) &#123;</span><br><span class="line">    <span class="keyword">case</span> QCAMERA_SM_STATE_PREVIEW_STOPPED:</span><br><span class="line">        rc = procEvtPreviewStoppedState(evt, payload);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> QCAMERA_SM_STATE_PREVIEW_READY:</span><br><span class="line">        rc = procEvtPreviewReadyState(evt, payload);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> QCAMERA_SM_STATE_PREVIEWING:</span><br><span class="line">        rc = procEvtPreviewingState(evt, payload);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> QCAMERA_SM_STATE_PREPARE_SNAPSHOT:</span><br><span class="line">        rc = procEvtPrepareSnapshotState(evt, payload);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> QCAMERA_SM_STATE_PIC_TAKING:</span><br><span class="line">        rc = procEvtPicTakingState(evt, payload);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> QCAMERA_SM_STATE_RECORDING:</span><br><span class="line">        rc = procEvtRecordingState(evt, payload);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> QCAMERA_SM_STATE_VIDEO_PIC_TAKING:</span><br><span class="line">        rc = procEvtVideoPicTakingState(evt, payload);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> QCAMERA_SM_STATE_PREVIEW_PIC_TAKING:</span><br><span class="line">        rc = procEvtPreviewPicTakingState(evt, payload);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设当前是preview状态,看procEvtPreviewingState代码:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int32_t</span> QCameraStateMachine::procEvtPreviewingState(<span class="keyword">qcamera_sm_evt_enum_t</span> evt,</span><br><span class="line">                                                    <span class="keyword">void</span> *payload)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> rc = NO_ERROR;</span><br><span class="line">    <span class="keyword">qcamera_api_result_t</span> result;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;result, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">qcamera_api_result_t</span>));</span><br><span class="line"></span><br><span class="line">    LOGL(<span class="string">"event (%d)"</span>, evt);</span><br><span class="line">    <span class="keyword">switch</span> (evt) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> QCAMERA_SM_EVT_TAKE_PICTURE:</span><br><span class="line">       &#123;</span><br><span class="line">           LOGL(<span class="string">"QCAMERA_SM_EVT_TAKE_PICTURE "</span>);</span><br><span class="line">           <span class="keyword">if</span> ( m_parent-&gt;mParameters.getRecordingHintValue() == <span class="literal">true</span>) &#123;</span><br><span class="line">                m_parent-&gt;stopPreview();</span><br><span class="line">                m_parent-&gt;mParameters.updateRecordingHintValue(FALSE);</span><br><span class="line">                <span class="comment">// start preview again</span></span><br><span class="line">                rc = m_parent-&gt;preparePreview();</span><br><span class="line">                <span class="keyword">if</span> (rc == NO_ERROR) &#123;</span><br><span class="line">                    rc = m_parent-&gt;startPreview();</span><br><span class="line">                    <span class="keyword">if</span> (rc != NO_ERROR) &#123;</span><br><span class="line">                        m_parent-&gt;unpreparePreview();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (m_parent-&gt;isZSLMode() || m_parent-&gt;isLongshotEnabled()) &#123;</span><br><span class="line">               <span class="keyword">bool</span> restartPreview = m_parent-&gt;isPreviewRestartEnabled();</span><br><span class="line">               <span class="keyword">if</span> ((restartPreview) &amp;&amp; (m_parent-&gt;mParameters.getManualCaptureMode()</span><br><span class="line">                       &gt;= CAM_MANUAL_CAPTURE_TYPE_3)) &#123;</span><br><span class="line">                   <span class="comment">/* stop preview and disable ZSL now */</span></span><br><span class="line">                   m_parent-&gt;stopPreview();</span><br><span class="line">                   m_parent-&gt;mParameters.updateZSLModeValue(FALSE);</span><br><span class="line">                   m_RestoreZSL = TRUE;</span><br><span class="line">                   m_bDelayPreviewMsgs = <span class="literal">true</span>;</span><br><span class="line">                   m_state = QCAMERA_SM_STATE_PIC_TAKING;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   m_state = QCAMERA_SM_STATE_PREVIEW_PIC_TAKING;</span><br><span class="line">                   m_bDelayPreviewMsgs = <span class="literal">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               rc = m_parent-&gt;takePicture();</span><br><span class="line">               <span class="keyword">if</span> (rc != NO_ERROR) &#123;</span><br><span class="line">                   <span class="comment">// move state to previewing state</span></span><br><span class="line">                   m_parent-&gt;unconfigureAdvancedCapture();</span><br><span class="line">                   m_state = QCAMERA_SM_STATE_PREVIEWING;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (!(m_parent-&gt;isRetroPicture()) || (rc != NO_ERROR)) &#123;</span><br><span class="line">                   LOGD(<span class="string">"signal API result, m_state = %d"</span>,</span><br><span class="line">                          m_state);</span><br><span class="line">                   result.status = rc;</span><br><span class="line">                   result.request_api = evt;</span><br><span class="line">                   result.result_type = QCAMERA_API_RESULT_TYPE_DEF;</span><br><span class="line">                   m_parent-&gt;signalAPIResult(&amp;result);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               m_state = QCAMERA_SM_STATE_PIC_TAKING;</span><br><span class="line">               rc = m_parent-&gt;takePicture();</span><br><span class="line">               <span class="keyword">if</span> (rc != NO_ERROR) &#123;</span><br><span class="line">                   <span class="keyword">int32_t</span> temp_rc = NO_ERROR;</span><br><span class="line">                   <span class="comment">// move state to preview stopped state</span></span><br><span class="line">                   m_parent-&gt;unconfigureAdvancedCapture();</span><br><span class="line">                   m_parent-&gt;stopPreview();</span><br><span class="line">                   <span class="comment">// start preview again</span></span><br><span class="line">                   temp_rc = m_parent-&gt;preparePreview();</span><br><span class="line">                   <span class="keyword">if</span> (temp_rc == NO_ERROR) &#123;</span><br><span class="line">                       temp_rc = m_parent-&gt;startPreview();</span><br><span class="line">                       <span class="keyword">if</span> (temp_rc != NO_ERROR) &#123;</span><br><span class="line">                           m_parent-&gt;unpreparePreview();</span><br><span class="line">                           m_state = QCAMERA_SM_STATE_PREVIEW_STOPPED;</span><br><span class="line">                       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                           m_state = QCAMERA_SM_STATE_PREVIEWING;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       m_state = QCAMERA_SM_STATE_PREVIEW_STOPPED;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               result.status = rc;</span><br><span class="line">               result.request_api = evt;</span><br><span class="line">               result.result_type = QCAMERA_API_RESULT_TYPE_DEF;</span><br><span class="line">               m_parent-&gt;signalAPIResult(&amp;result);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        LOGW(<span class="string">"Cannot handle evt(%d) in state(%d)"</span>, evt, m_state);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>把状态置为QCAMERA_SM_STATE_PIC_TAKING,调用QCamera2HardwareInterface的takePicture,如果返回没有错误,则重新startPreview.<br>最后用signalAPIResult回调状态结果.</p><h3 id="拍照实现"><a href="#拍照实现" class="headerlink" title="拍照实现"></a>拍照实现</h3><p>takePicture方法:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> QCamera2HardwareInterface::takePicture()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> rc = NO_ERROR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get total number for snapshots (retro + regular)</span></span><br><span class="line">    <span class="keyword">uint8_t</span> numSnapshots = mParameters.getNumOfSnapshots();</span><br><span class="line">    <span class="comment">// Get number of retro-active snapshots</span></span><br><span class="line">    <span class="keyword">uint8_t</span> numRetroSnapshots = mParameters.getNumOfRetroSnapshots();</span><br><span class="line">    LOGH(<span class="string">"E"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Set rotation value from user settings as Jpeg rotation</span></span><br><span class="line">    <span class="comment">//to configure back-end modules.</span></span><br><span class="line">    mParameters.setJpegRotation(mParameters.getRotation());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if retro-active snapshots are not enabled</span></span><br><span class="line">    <span class="keyword">if</span> (!isRetroPicture() || !mParameters.isZSLMode()) &#123;</span><br><span class="line">      numRetroSnapshots = <span class="number">0</span>;</span><br><span class="line">      LOGH(<span class="string">"Reset retro snaphot count to zero"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Do special configure for advanced capture modes.</span></span><br><span class="line">    rc = configureAdvancedCapture();</span><br><span class="line">    <span class="keyword">if</span> (rc != NO_ERROR) &#123;</span><br><span class="line">        LOGE(<span class="string">"Unsupported capture call"</span>);</span><br><span class="line">        <span class="keyword">return</span> rc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mAdvancedCaptureConfigured) &#123;</span><br><span class="line">        numSnapshots = mParameters.getBurstCountForAdvancedCapture();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mActiveCameras == MM_CAMERA_DUAL_CAM &amp;&amp; mBundledSnapshot) &#123;</span><br><span class="line">        <span class="keyword">char</span> prop[PROPERTY_VALUE_MAX];</span><br><span class="line">        <span class="built_in">memset</span>(prop, <span class="number">0</span>, <span class="keyword">sizeof</span>(prop));</span><br><span class="line">        property_get(<span class="string">"persist.camera.dualfov.jpegnum"</span>, prop, <span class="string">"1"</span>);</span><br><span class="line">        <span class="keyword">int</span> dualfov_snap_num = atoi(prop);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(prop, <span class="number">0</span>, <span class="keyword">sizeof</span>(prop));</span><br><span class="line">        property_get(<span class="string">"persist.camera.halpp"</span>, prop, <span class="string">"0"</span>);</span><br><span class="line">        <span class="keyword">int</span> halpp_enabled = atoi(prop);</span><br><span class="line">        <span class="keyword">if</span>(halpp_enabled == <span class="number">0</span>) &#123;</span><br><span class="line">            dualfov_snap_num = MM_CAMERA_MAX_CAM_CNT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dualfov_snap_num = (dualfov_snap_num == <span class="number">0</span>) ? <span class="number">1</span> : dualfov_snap_num;</span><br><span class="line">        LOGD(<span class="string">"dualfov_snap_num:%d"</span>, dualfov_snap_num);</span><br><span class="line">        numSnapshots /= dualfov_snap_num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LOGI(<span class="string">"snap count = %d zsl = %d advanced = %d, active camera:%d"</span>,</span><br><span class="line">            numSnapshots, mParameters.isZSLMode(), mAdvancedCaptureConfigured, mActiveCameras);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mParameters.isZSLMode()) &#123;</span><br><span class="line">        QCameraChannel *pChannel = m_channels[QCAMERA_CH_TYPE_ZSL];</span><br><span class="line">        QCameraPicChannel *pPicChannel = (QCameraPicChannel *)pChannel;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> != pPicChannel) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mParameters.getofflineRAW()) &#123;</span><br><span class="line">                startRAWChannel(pPicChannel);</span><br><span class="line">                pPicChannel = (QCameraPicChannel *)m_channels[QCAMERA_CH_TYPE_RAW];</span><br><span class="line">                <span class="keyword">if</span> (pPicChannel == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    LOGE(<span class="string">"RAW Channel is NULL in Manual capture mode"</span>);</span><br><span class="line">                    stopRAWChannel();</span><br><span class="line">                    <span class="keyword">return</span> UNKNOWN_ERROR;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            rc = configureOnlineRotation(*pPicChannel);</span><br><span class="line">            <span class="keyword">if</span> (rc != NO_ERROR) &#123;</span><br><span class="line">                LOGE(<span class="string">"online rotation failed"</span>);</span><br><span class="line">                <span class="keyword">return</span> rc;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// start postprocessor</span></span><br><span class="line">            DeferWorkArgs args;</span><br><span class="line">            <span class="built_in">memset</span>(&amp;args, <span class="number">0</span>, <span class="keyword">sizeof</span>(DeferWorkArgs));</span><br><span class="line"></span><br><span class="line">            args.pprocArgs = pPicChannel;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// No need to wait for mInitPProcJob here, because it was</span></span><br><span class="line">            <span class="comment">// queued in startPreview, and will definitely be processed before</span></span><br><span class="line">            <span class="comment">// mReprocJob can begin.</span></span><br><span class="line">            mReprocJob = queueDeferredWork(CMD_DEF_PPROC_START,</span><br><span class="line">                    args);</span><br><span class="line">            <span class="keyword">if</span> (mReprocJob == <span class="number">0</span>) &#123;</span><br><span class="line">                LOGE(<span class="string">"Failure: Unable to start pproc"</span>);</span><br><span class="line">                <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check if all preview buffers are mapped before creating</span></span><br><span class="line">            <span class="comment">// a jpeg session as preview stream buffers are queried during the same</span></span><br><span class="line">            <span class="keyword">uint8_t</span> numStreams = pChannel-&gt;getNumOfStreams();</span><br><span class="line">            QCameraStream *pStream = <span class="literal">NULL</span>;</span><br><span class="line">            QCameraStream *pPreviewStream = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">uint8_t</span> i = <span class="number">0</span> ; i &lt; numStreams ; i++ ) &#123;</span><br><span class="line">                pStream = pChannel-&gt;getStreamByIndex(i);</span><br><span class="line">                <span class="keyword">if</span> (!pStream)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (CAM_STREAM_TYPE_PREVIEW == pStream-&gt;getMyType()) &#123;</span><br><span class="line">                    pPreviewStream = pStream;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pPreviewStream != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                Mutex::<span class="function">Autolock <span class="title">l</span><span class="params">(mMapLock)</span></span>;</span><br><span class="line">                QCameraMemory *pMemory = pStream-&gt;getStreamBufs();</span><br><span class="line">                <span class="keyword">if</span> (!pMemory) &#123;</span><br><span class="line">                    LOGE(<span class="string">"Error!! pMemory is NULL"</span>);</span><br><span class="line">                    <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">uint8_t</span> waitCnt = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">while</span> (!pMemory-&gt;checkIfAllBuffersMapped() &amp;&amp; (waitCnt &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">                    LOGL(<span class="string">" Waiting for preview buffers to be mapped"</span>);</span><br><span class="line">                    mMapCond.waitRelative(</span><br><span class="line">                            mMapLock, CAMERA_DEFERRED_MAP_BUF_TIMEOUT);</span><br><span class="line">                    LOGL(<span class="string">"Wait completed!!"</span>);</span><br><span class="line">                    waitCnt--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// If all buffers are not mapped after retries, assert</span></span><br><span class="line">                assert(pMemory-&gt;checkIfAllBuffersMapped());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                assert(pPreviewStream);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Create JPEG session</span></span><br><span class="line">            mJpegJob = queueDeferredWork(CMD_DEF_CREATE_JPEG_SESSION,</span><br><span class="line">                    args);</span><br><span class="line">            <span class="keyword">if</span> (mJpegJob == <span class="number">0</span>) &#123;</span><br><span class="line">                LOGE(<span class="string">"Failed to queue CREATE_JPEG_SESSION"</span>);</span><br><span class="line">                <span class="keyword">if</span> (NO_ERROR != waitDeferredWork(mReprocJob)) &#123;</span><br><span class="line">                        LOGE(<span class="string">"Reprocess Deferred work was failed"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                m_postprocessor.stop();</span><br><span class="line">                <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mAdvancedCaptureConfigured) &#123;</span><br><span class="line">                rc = startAdvancedCapture(pPicChannel);</span><br><span class="line">                <span class="keyword">if</span> (rc != NO_ERROR) &#123;</span><br><span class="line">                    LOGE(<span class="string">"cannot start zsl advanced capture"</span>);</span><br><span class="line">                    <span class="keyword">return</span> rc;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mLongshotEnabled &amp;&amp; mPrepSnapRun) &#123;</span><br><span class="line">                mCameraHandle-&gt;ops-&gt;start_zsl_snapshot(</span><br><span class="line">                        mCameraHandle-&gt;camera_handle,</span><br><span class="line">                        pPicChannel-&gt;getMyHandle());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// If frame sync is ON and it is a SECONDARY camera,</span></span><br><span class="line">            <span class="comment">// we do not need to send the take picture command to interface</span></span><br><span class="line">            <span class="comment">// It will be handled along with PRIMARY camera takePicture request</span></span><br><span class="line">            <span class="keyword">mm_camera_req_buf_t</span> buf;</span><br><span class="line">            <span class="built_in">memset</span>(&amp;buf, <span class="number">0x0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="keyword">if</span> ((!mParameters.isAdvCamFeaturesEnabled() &amp;&amp;</span><br><span class="line">                    !mFlashNeeded &amp;&amp;</span><br><span class="line">                    !isLongshotEnabled() &amp;&amp;</span><br><span class="line">                    isFrameSyncEnabled()) &amp;&amp;</span><br><span class="line">                    (getRelatedCamSyncInfo()-&gt;sync_control ==</span><br><span class="line">                    CAM_SYNC_RELATED_SENSORS_ON)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (getRelatedCamSyncInfo()-&gt;mode == CAM_MODE_PRIMARY) &#123;</span><br><span class="line">                    buf.type = MM_CAMERA_REQ_FRAME_SYNC_BUF;</span><br><span class="line">                    buf.num_buf_requested = numSnapshots;</span><br><span class="line">                    rc = pPicChannel-&gt;takePicture(&amp;buf);</span><br><span class="line">                    <span class="keyword">if</span> (rc != NO_ERROR) &#123;</span><br><span class="line">                        LOGE(<span class="string">"FS_DBG cannot take ZSL picture, stop pproc"</span>);</span><br><span class="line">                        <span class="keyword">if</span> (NO_ERROR != waitDeferredWork(mReprocJob)) &#123;</span><br><span class="line">                            LOGE(<span class="string">"Reprocess Deferred work failed"</span>);</span><br><span class="line">                            <span class="keyword">return</span> UNKNOWN_ERROR;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (NO_ERROR != waitDeferredWork(mJpegJob)) &#123;</span><br><span class="line">                            LOGE(<span class="string">"Jpeg Deferred work failed"</span>);</span><br><span class="line">                            <span class="keyword">return</span> UNKNOWN_ERROR;</span><br><span class="line">                        &#125;</span><br><span class="line">                        m_postprocessor.stop();</span><br><span class="line">                        <span class="keyword">return</span> rc;</span><br><span class="line">                    &#125;</span><br><span class="line">                    LOGI(<span class="string">"PRIMARY camera: send frame sync takePicture!!"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                buf.type = MM_CAMERA_REQ_SUPER_BUF;</span><br><span class="line">                buf.num_buf_requested = numSnapshots;</span><br><span class="line">                buf.num_retro_buf_requested = numRetroSnapshots;</span><br><span class="line">                rc = pPicChannel-&gt;takePicture(&amp;buf);</span><br><span class="line">                <span class="keyword">if</span> (rc != NO_ERROR) &#123;</span><br><span class="line">                    LOGE(<span class="string">"cannot take ZSL picture, stop pproc"</span>);</span><br><span class="line">                        <span class="keyword">if</span> (NO_ERROR != waitDeferredWork(mReprocJob)) &#123;</span><br><span class="line">                            LOGE(<span class="string">"Reprocess Deferred work failed"</span>);</span><br><span class="line">                            <span class="keyword">return</span> UNKNOWN_ERROR;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (NO_ERROR != waitDeferredWork(mJpegJob)) &#123;</span><br><span class="line">                            LOGE(<span class="string">"Jpeg Deferred work failed"</span>);</span><br><span class="line">                            <span class="keyword">return</span> UNKNOWN_ERROR;</span><br><span class="line">                        &#125;</span><br><span class="line">                    m_postprocessor.stop();</span><br><span class="line">                    <span class="keyword">return</span> rc;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            LOGE(<span class="string">"ZSL channel is NULL"</span>);</span><br><span class="line">            <span class="keyword">return</span> UNKNOWN_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// start snapshot</span></span><br><span class="line">        <span class="keyword">if</span> (mParameters.isJpegPictureFormat() ||</span><br><span class="line">                mParameters.isNV16PictureFormat() ||</span><br><span class="line">                mParameters.isNV21PictureFormat()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//STOP Preview for Non ZSL use case</span></span><br><span class="line">            stopPreview();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Config CAPTURE channels</span></span><br><span class="line">            rc = declareSnapshotStreams();</span><br><span class="line">            <span class="keyword">if</span> (NO_ERROR != rc) &#123;</span><br><span class="line">                <span class="keyword">return</span> rc;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            rc = addCaptureChannel();</span><br><span class="line">            <span class="keyword">if</span> ((rc == NO_ERROR) &amp;&amp;</span><br><span class="line">                    (<span class="literal">NULL</span> != m_channels[QCAMERA_CH_TYPE_CAPTURE])) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!mParameters.getofflineRAW()) &#123;</span><br><span class="line">                    rc = configureOnlineRotation(</span><br><span class="line">                        *m_channels[QCAMERA_CH_TYPE_CAPTURE]);</span><br><span class="line">                    <span class="keyword">if</span> (rc != NO_ERROR) &#123;</span><br><span class="line">                        LOGE(<span class="string">"online rotation failed"</span>);</span><br><span class="line">                        delChannel(QCAMERA_CH_TYPE_CAPTURE);</span><br><span class="line">                        <span class="keyword">return</span> rc;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                DeferWorkArgs args;</span><br><span class="line">                <span class="built_in">memset</span>(&amp;args, <span class="number">0</span>, <span class="keyword">sizeof</span>(DeferWorkArgs));</span><br><span class="line"></span><br><span class="line">                args.pprocArgs = m_channels[QCAMERA_CH_TYPE_CAPTURE];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// No need to wait for mInitPProcJob here, because it was</span></span><br><span class="line">                <span class="comment">// queued in startPreview, and will definitely be processed before</span></span><br><span class="line">                <span class="comment">// mReprocJob can begin.</span></span><br><span class="line">                mReprocJob = queueDeferredWork(CMD_DEF_PPROC_START,</span><br><span class="line">                        args);</span><br><span class="line">                <span class="keyword">if</span> (mReprocJob == <span class="number">0</span>) &#123;</span><br><span class="line">                    LOGE(<span class="string">"Failure: Unable to start pproc"</span>);</span><br><span class="line">                    <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Create JPEG session</span></span><br><span class="line">                mJpegJob = queueDeferredWork(CMD_DEF_CREATE_JPEG_SESSION,</span><br><span class="line">                        args);</span><br><span class="line">                <span class="keyword">if</span> (mJpegJob == <span class="number">0</span>) &#123;</span><br><span class="line">                    LOGE(<span class="string">"Failed to queue CREATE_JPEG_SESSION"</span>);</span><br><span class="line">                    <span class="keyword">if</span> (NO_ERROR != waitDeferredWork(mReprocJob)) &#123;</span><br><span class="line">                        LOGE(<span class="string">"Reprocess Deferred work was failed"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    m_postprocessor.stop();</span><br><span class="line">                    <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// start catpure channel</span></span><br><span class="line">                rc =  m_channels[QCAMERA_CH_TYPE_CAPTURE]-&gt;start();</span><br><span class="line">                <span class="keyword">if</span> (rc != NO_ERROR) &#123;</span><br><span class="line">                    LOGE(<span class="string">"cannot start capture channel"</span>);</span><br><span class="line">                    <span class="keyword">if</span> (NO_ERROR != waitDeferredWork(mReprocJob)) &#123;</span><br><span class="line">                        LOGE(<span class="string">"Reprocess Deferred work failed"</span>);</span><br><span class="line">                        <span class="keyword">return</span> UNKNOWN_ERROR;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (NO_ERROR != waitDeferredWork(mJpegJob)) &#123;</span><br><span class="line">                        LOGE(<span class="string">"Jpeg Deferred work failed"</span>);</span><br><span class="line">                        <span class="keyword">return</span> UNKNOWN_ERROR;</span><br><span class="line">                    &#125;</span><br><span class="line">                    delChannel(QCAMERA_CH_TYPE_CAPTURE);</span><br><span class="line">                    <span class="keyword">return</span> rc;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                QCameraPicChannel *pCapChannel =</span><br><span class="line">                    (QCameraPicChannel *)m_channels[QCAMERA_CH_TYPE_CAPTURE];</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">NULL</span> != pCapChannel) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mParameters.isUbiFocusEnabled() ||</span><br><span class="line">                            mParameters.isUbiRefocus() ||</span><br><span class="line">                            mParameters.isChromaFlashEnabled()) &#123;</span><br><span class="line">                        rc = startAdvancedCapture(pCapChannel);</span><br><span class="line">                        <span class="keyword">if</span> (rc != NO_ERROR) &#123;</span><br><span class="line">                            LOGE(<span class="string">"cannot start advanced capture"</span>);</span><br><span class="line">                            <span class="keyword">return</span> rc;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ( mLongshotEnabled ) &#123;</span><br><span class="line">                    rc = longShot();</span><br><span class="line">                    <span class="keyword">if</span> (NO_ERROR != rc) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (NO_ERROR != waitDeferredWork(mReprocJob)) &#123;</span><br><span class="line">                            LOGE(<span class="string">"Reprocess Deferred work failed"</span>);</span><br><span class="line">                            <span class="keyword">return</span> UNKNOWN_ERROR;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (NO_ERROR != waitDeferredWork(mJpegJob)) &#123;</span><br><span class="line">                            LOGE(<span class="string">"Jpeg Deferred work failed"</span>);</span><br><span class="line">                            <span class="keyword">return</span> UNKNOWN_ERROR;</span><br><span class="line">                        &#125;</span><br><span class="line">                        delChannel(QCAMERA_CH_TYPE_CAPTURE);</span><br><span class="line">                        <span class="keyword">return</span> rc;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                LOGE(<span class="string">"cannot add capture channel"</span>);</span><br><span class="line">                delChannel(QCAMERA_CH_TYPE_CAPTURE);</span><br><span class="line">                <span class="keyword">return</span> rc;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Stop Preview before taking NZSL snapshot</span></span><br><span class="line">            stopPreview();</span><br><span class="line"></span><br><span class="line">            rc = mParameters.updateRAW(gCamCapability[mCameraId]-&gt;raw_dim[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">if</span> (NO_ERROR != rc) &#123;</span><br><span class="line">                LOGE(<span class="string">"Raw dimension update failed %d"</span>, rc);</span><br><span class="line">                <span class="keyword">return</span> rc;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            rc = declareSnapshotStreams();</span><br><span class="line">            <span class="keyword">if</span> (NO_ERROR != rc) &#123;</span><br><span class="line">                LOGE(<span class="string">"RAW stream info configuration failed %d"</span>, rc);</span><br><span class="line">                <span class="keyword">return</span> rc;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            rc = addChannel(QCAMERA_CH_TYPE_RAW);</span><br><span class="line">            <span class="keyword">if</span> (rc == NO_ERROR) &#123;</span><br><span class="line">                <span class="comment">// start postprocessor</span></span><br><span class="line">                <span class="keyword">if</span> (NO_ERROR != waitDeferredWork(mInitPProcJob)) &#123;</span><br><span class="line">                    LOGE(<span class="string">"Reprocess Deferred work failed"</span>);</span><br><span class="line">                    <span class="keyword">return</span> UNKNOWN_ERROR;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                rc = m_postprocessor.start(m_channels[QCAMERA_CH_TYPE_RAW]);</span><br><span class="line">                <span class="keyword">if</span> (rc != NO_ERROR) &#123;</span><br><span class="line">                    LOGE(<span class="string">"cannot start postprocessor"</span>);</span><br><span class="line">                    delChannel(QCAMERA_CH_TYPE_RAW);</span><br><span class="line">                    <span class="keyword">return</span> rc;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                rc = startChannel(QCAMERA_CH_TYPE_RAW);</span><br><span class="line">                <span class="keyword">if</span> (rc != NO_ERROR) &#123;</span><br><span class="line">                    LOGE(<span class="string">"cannot start raw channel"</span>);</span><br><span class="line">                    m_postprocessor.stop();</span><br><span class="line">                    delChannel(QCAMERA_CH_TYPE_RAW);</span><br><span class="line">                    <span class="keyword">return</span> rc;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                LOGE(<span class="string">"cannot add raw channel"</span>);</span><br><span class="line">                <span class="keyword">return</span> rc;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//When take picture, stop sending preview callbacks to APP</span></span><br><span class="line">    m_stateMachine.setPreviewCallbackNeeded(<span class="literal">false</span>);</span><br><span class="line">    LOGI(<span class="string">"X rc = %d"</span>, rc);</span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建了一个QCameraChannel,调用其takePicture方法:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*===========================================================================</span></span><br><span class="line"><span class="comment"> * FUNCTION   : takePicture</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * DESCRIPTION: send request for queued snapshot frames</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * PARAMETERS :</span></span><br><span class="line"><span class="comment"> *   @buf : request buf info</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * RETURN     : int32_t type of status</span></span><br><span class="line"><span class="comment"> *              NO_ERROR  -- success</span></span><br><span class="line"><span class="comment"> *              none-zero failure code</span></span><br><span class="line"><span class="comment"> *==========================================================================*/</span></span><br><span class="line"><span class="keyword">int32_t</span> QCameraPicChannel::takePicture (<span class="keyword">mm_camera_req_buf_t</span> *buf)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> snapshotHandle = getSnapshotHandle();</span><br><span class="line">    LOGD(<span class="string">"mSnapshotHandle = 0x%x"</span>, snapshotHandle);</span><br><span class="line">    <span class="keyword">int32_t</span> rc = m_camOps-&gt;request_super_buf(m_camHandle, snapshotHandle, buf);</span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的调用就又进入了mm-camera-interface了,通过mm_camera_channel获取到super_buf,里面不再深入了.<br>QCamera2HardwareInterface的takePicture方法首先是创建一个QCameraChannel,开始一个无压缩的RAW管道,调用takePicture方法获取到buffer,最后等待延迟任务mJpegJob创建Jpeg.</p><h3 id="结果同步"><a href="#结果同步" class="headerlink" title="结果同步"></a>结果同步</h3><p>拍照方法基本完成了,再看一下回调.QCameraStateMachine调用QCamera2HardwareInterface的takePicture后又调用了signalAPIResult方法发送结果:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> QCamera2HardwareInterface::signalAPIResult(<span class="keyword">qcamera_api_result_t</span> *result)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;m_lock);</span><br><span class="line">    api_result_list *apiResult = (api_result_list *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(api_result_list));</span><br><span class="line">    <span class="keyword">if</span> (apiResult == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        LOGE(<span class="string">"ERROR: malloc for api result failed, Result will not be sent"</span>);</span><br><span class="line">        <span class="keyword">goto</span> malloc_failed;</span><br><span class="line">    &#125;</span><br><span class="line">    apiResult-&gt;result = *result;</span><br><span class="line">    apiResult-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (m_apiResultList == <span class="literal">NULL</span>) m_apiResultList = apiResult;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        api_result_list *apiResultList = m_apiResultList;</span><br><span class="line">        <span class="keyword">while</span>(apiResultList-&gt;next != <span class="literal">NULL</span>) apiResultList = apiResultList-&gt;next;</span><br><span class="line">        apiResultList-&gt;next = apiResult;</span><br><span class="line">    &#125;</span><br><span class="line">malloc_failed:</span><br><span class="line">    pthread_cond_broadcast(&amp;m_cond);</span><br><span class="line">    pthread_mutex_unlock(&amp;m_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把result给m_apiResultList的末尾.</p><p>回到初始QCamera2HardwareInterface的take_picture方法,其最后用waitAPIResult等待结果返回.看这个方法:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*===========================================================================</span></span><br><span class="line"><span class="comment"> * FUNCTION   : waitAPIResult</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * DESCRIPTION: wait for API result coming back. This is a blocking call, it will</span></span><br><span class="line"><span class="comment"> *              return only cerntain API event type arrives</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * PARAMETERS :</span></span><br><span class="line"><span class="comment"> *   @api_evt : API event type</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * RETURN     : none</span></span><br><span class="line"><span class="comment"> *==========================================================================*/</span></span><br><span class="line"><span class="keyword">void</span> QCamera2HardwareInterface::waitAPIResult(<span class="keyword">qcamera_sm_evt_enum_t</span> api_evt,</span><br><span class="line">        <span class="keyword">qcamera_api_result_t</span> *apiResult)</span><br><span class="line">&#123;</span><br><span class="line">    LOGD(<span class="string">"wait for API result of evt (%d)"</span>, api_evt);</span><br><span class="line">    <span class="keyword">int</span> resultReceived = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>  (!resultReceived) &#123;</span><br><span class="line">        pthread_cond_wait(&amp;m_cond, &amp;m_lock);</span><br><span class="line">        <span class="keyword">if</span> (m_apiResultList != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            api_result_list *apiResultList = m_apiResultList;</span><br><span class="line">            api_result_list *apiResultListPrevious = m_apiResultList;</span><br><span class="line">            <span class="keyword">while</span> (apiResultList != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (apiResultList-&gt;result.request_api == api_evt) &#123;</span><br><span class="line">                    resultReceived = <span class="number">1</span>;</span><br><span class="line">                    *apiResult = apiResultList-&gt;result;</span><br><span class="line">                    apiResultListPrevious-&gt;next = apiResultList-&gt;next;</span><br><span class="line">                    <span class="keyword">if</span> (apiResultList == m_apiResultList) &#123;</span><br><span class="line">                        m_apiResultList = apiResultList-&gt;next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">free</span>(apiResultList);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    apiResultListPrevious = apiResultList;</span><br><span class="line">                    apiResultList = apiResultList-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    LOGD(<span class="string">"return (%d) from API result wait for evt (%d)"</span>,</span><br><span class="line">           apiResult-&gt;status, api_evt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方发是阻塞的,直到有对应消息返回,通过signalAPIResult方法拍照完成的消息传递过去了,这时候我们就能通过waitAPIResult获取到结果了.</p><h3 id="流程总结-1"><a href="#流程总结-1" class="headerlink" title="流程总结"></a>流程总结</h3><p>hal层拍照流程:</p><ol><li>QCamera2HardwareInterface调用take_picture方法,调用processAPI发出QCAMERA_SM_EVT_TAKE_PICTURE请求,使用waitAPIResult等待结果</li><li>processAPI调用QCameraStateMachine的proAPI,proAPI给QCameraQueue添加一个qcamera_sm_cmd_t,然后用信号量同步</li><li>QCameraStateMachine周期方法smEvtProcRoutine根据信号量从QCameraQueue中取出命令,交给stateMachine方法执行</li><li>stateMachine根据对应状态执行方法,如果在preview状态,则设置为拍照进行状态,调用QCamera2HardwareInterface的takePicture方法完成后调用signalAPIResult同步结果</li><li>takePicture方法内部过程是创建一个QCameraChannel,使用无压缩的管道,调用QCameraChannel的takePicture方法获取buffer,等待创建Jpeg的任务完成</li><li>waitAPIResult收到对应请求的结果,take_picture方法完成,返回请求结果.</li></ol>]]></content>
    
    <summary type="html">
    
      相机流程深入解析:高通Camera的HAL
    
    </summary>
    
    
      <category term="Android" scheme="http://anddymao.com/tags/Android/"/>
    
      <category term="Camera" scheme="http://anddymao.com/tags/Camera/"/>
    
  </entry>
  
  <entry>
    <title>Android8.0相机源码深入解析(四)</title>
    <link href="http://anddymao.com/2018/05/08/2018-5-8-%E7%9B%B8%E6%9C%BA%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90(%E5%9B%9B)/"/>
    <id>http://anddymao.com/2018/05/08/2018-5-8-相机源码深入解析(四)/</id>
    <published>2018-05-08T04:00:00.000Z</published>
    <updated>2019-10-25T03:38:48.886Z</updated>
    
    <content type="html"><![CDATA[<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>上一篇介绍了相机hal到app的数据传递,通过前面三篇对相机数据传输流程弄清楚了,相机各层结构也梳理清除.本篇继续介绍相机启动流程.</p><h2 id="相机服务过程"><a href="#相机服务过程" class="headerlink" title="相机服务过程"></a>相机服务过程</h2><h3 id="服务注册及启动"><a href="#服务注册及启动" class="headerlink" title="服务注册及启动"></a>服务注册及启动</h3><p>CameraServer在7.0之前是在MediaServer里,7.0改成了单独的Server.我们看最新的8.0的代码.<br>CameraServer定义在framework/av/camera/cameraserver.看cameraserver的make文件:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_PATH:= $(call my-dir)</span><br><span class="line"></span><br><span class="line">include $(CLEAR_VARS)</span><br><span class="line"></span><br><span class="line">LOCAL_SRC_FILES:= \</span><br><span class="line">main_cameraserver.cpp</span><br><span class="line"></span><br><span class="line">LOCAL_SHARED_LIBRARIES := \</span><br><span class="line">libcameraservice \</span><br><span class="line">liblog \</span><br><span class="line">libutils \</span><br><span class="line">libui \</span><br><span class="line">libgui \</span><br><span class="line">libbinder \</span><br><span class="line">libhidltransport \</span><br><span class="line">android.hardware.camera.common@<span class="number">1.0</span> \</span><br><span class="line">android.hardware.camera.provider@<span class="number">2.4</span> \</span><br><span class="line">android.hardware.camera.device@<span class="number">1.0</span> \</span><br><span class="line">vendor.qti.hardware.camera.device@<span class="number">1.0</span> \</span><br><span class="line">android.hardware.camera.device@<span class="number">3.2</span></span><br><span class="line"></span><br><span class="line">LOCAL_MODULE:= cameraserver</span><br><span class="line">LOCAL_32_BIT_ONLY := <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">LOCAL_CFLAGS += -Wall -Wextra -Werror -Wno-unused-parameter</span><br><span class="line"></span><br><span class="line">LOCAL_INIT_RC := cameraserver.rc</span><br><span class="line"></span><br><span class="line">include $(BUILD_EXECUTABLE)</span><br></pre></td></tr></table></figure><p>LOCAL_SHARED_LIBRARIES包括了此前一直讲到的libcameraservice,再加上工具类,provide,device1,device2,device3.2等.aidl的定义也写在这里.<br>这里我们看到很重要的信息LOCAL_INIT_RC := cameraserver.rc,这个就是进程启动地方了.init进程启动后会加载init.rc(system\core\rootdir\init.rc)脚本，当它执行mount_all指令挂载分区时，会加载/{system,vendor,odm}/etc/init目录下的所有rc脚本，这样就会启动cameraserver进程.<br>找到了启动位置,也知道了启动流程,再看启动时做了些什么.看下main_cameraserver.cpp:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc __unused, <span class="keyword">char</span>** argv __unused)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    signal(SIGPIPE, SIG_IGN);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set 3 threads for HIDL calls</span></span><br><span class="line">    hardware::configureRpcThreadpool(<span class="number">3</span>, <span class="comment">/*willjoin*/</span> <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    sp&lt;ProcessState&gt; proc(ProcessState::self());</span><br><span class="line">    sp&lt;IServiceManager&gt; sm = defaultServiceManager();</span><br><span class="line">    ALOGI(<span class="string">"ServiceManager: %p"</span>, sm.get());</span><br><span class="line">    CameraService::instantiate();</span><br><span class="line">    ProcessState::self()-&gt;startThreadPool();</span><br><span class="line">    IPCThreadState::self()-&gt;joinThreadPool();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就一个main方法,让CameraService实例化,然后是让自己启动和加入线程池,这个不细看了.CameraService继承了模板类BinderService,我们找到instantiate方法:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> SERVICE&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinderService</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> status_t <span class="title">publish</span><span class="params">(<span class="keyword">bool</span> allowIsolated = <span class="literal">false</span>)</span> </span>&#123;</span><br><span class="line">        sp&lt;IServiceManager&gt; sm(defaultServiceManager());</span><br><span class="line">        <span class="keyword">return</span> sm-&gt;addService(</span><br><span class="line">                String16(SERVICE::getServiceName()),</span><br><span class="line">                <span class="keyword">new</span> SERVICE(), allowIsolated);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">publishAndJoinThreadPool</span><span class="params">(<span class="keyword">bool</span> allowIsolated = <span class="literal">false</span>)</span> </span>&#123;</span><br><span class="line">        publish(allowIsolated);</span><br><span class="line">        joinThreadPool();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">instantiate</span><span class="params">()</span> </span>&#123; publish(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> status_t <span class="title">shutdown</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> NO_ERROR; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">joinThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sp&lt;ProcessState&gt; ps(ProcessState::self());</span><br><span class="line">        ps-&gt;startThreadPool();</span><br><span class="line">        ps-&gt;giveThreadPoolName();</span><br><span class="line">        IPCThreadState::self()-&gt;joinThreadPool();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>instantiate调用了publish方法,就是发布,通过ServiceManager添加一个服务.</p><p>在IServiceManager找到addService方法:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> status_t <span class="title">addService</span><span class="params">(<span class="keyword">const</span> String16&amp; name, <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; service,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">bool</span> allowIsolated)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Parcel data, reply;</span><br><span class="line">    data.writeInterfaceToken(IServiceManager::getInterfaceDescriptor());</span><br><span class="line">    data.writeString16(name);</span><br><span class="line">    data.writeStrongBinder(service);</span><br><span class="line">    data.writeInt32(allowIsolated ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">status_t</span> err = remote()-&gt;transact(ADD_SERVICE_TRANSACTION, data, &amp;reply);</span><br><span class="line">    <span class="keyword">return</span> err == NO_ERROR ? reply.readExceptionCode() : err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>service是强指针sp<ibinder>&amp;,初始化时会调用其引用对象的onFirstRef方法.<br>继续看CameraService代码,在服务添加后做了什么:</ibinder></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">CameraService::CameraService() :</span><br><span class="line">        mEventLog(DEFAULT_EVENT_LOG_LENGTH),</span><br><span class="line">        mNumberOfCameras(<span class="number">0</span>), mNumberOfNormalCameras(<span class="number">0</span>),</span><br><span class="line">        mSoundRef(<span class="number">0</span>), mInitialized(<span class="literal">false</span>) &#123;</span><br><span class="line">    ALOGI(<span class="string">"CameraService started (pid=%d)"</span>, getpid());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>-&gt;camera_device_status_change = android::camera_device_status_change;</span><br><span class="line">    <span class="keyword">this</span>-&gt;torch_mode_status_change = android::torch_mode_status_change;</span><br><span class="line"></span><br><span class="line">    mServiceLockWrapper = <span class="built_in">std</span>::make_shared&lt;WaitableMutexWrapper&gt;(&amp;mServiceLock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CameraService::onFirstRef()</span><br><span class="line">&#123;</span><br><span class="line">    ALOGI(<span class="string">"CameraService process starting"</span>);</span><br><span class="line"></span><br><span class="line">    BnCameraService::onFirstRef();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update battery life tracking if service is restarting</span></span><br><span class="line">    <span class="function">BatteryNotifier&amp; <span class="title">notifier</span><span class="params">(BatteryNotifier::getInstance())</span></span>;</span><br><span class="line">    notifier.noteResetCamera();</span><br><span class="line">    notifier.noteResetFlashlight();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> res = INVALID_OPERATION;</span><br><span class="line"></span><br><span class="line">    res = enumerateProviders();</span><br><span class="line">    <span class="keyword">if</span> (res == OK) &#123;</span><br><span class="line">        mInitialized = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CameraService::pingCameraServiceProxy();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例方法里面没有做什么,另外果然看到了onFirstRef方法.这里调用了BnCameraService的onFirstRef方法,然后电池通知,和主线无关,不管.然后枚举providers,最后连接CameraServiceProxy服务.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> CameraService::enumerateProviders() &#123;</span><br><span class="line">    <span class="keyword">status_t</span> res;</span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">l</span><span class="params">(mServiceLock)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nullptr</span> == mCameraProviderManager.get()) &#123;</span><br><span class="line">        mCameraProviderManager = <span class="keyword">new</span> CameraProviderManager();</span><br><span class="line">        res = mCameraProviderManager-&gt;initialize(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (res != OK) &#123;</span><br><span class="line">            ALOGE(<span class="string">"%s: Unable to initialize camera provider manager: %s (%d)"</span>,</span><br><span class="line">                    __FUNCTION__, strerror(-res), res);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mNumberOfCameras = mCameraProviderManager-&gt;getCameraCount();</span><br><span class="line">    mNumberOfNormalCameras =</span><br><span class="line">            mCameraProviderManager-&gt;getAPI1CompatibleCameraCount();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Setup vendor tags before we call get_camera_info the first time</span></span><br><span class="line">    <span class="comment">// because HAL might need to setup static vendor keys in get_camera_info</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> maybe put this into CameraProviderManager::initialize()?</span></span><br><span class="line">    mCameraProviderManager-&gt;setUpVendorTags();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nullptr</span> == mFlashlight.get()) &#123;</span><br><span class="line">        mFlashlight = <span class="keyword">new</span> CameraFlashlight(mCameraProviderManager, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res = mFlashlight-&gt;findFlashUnits();</span><br><span class="line">    <span class="keyword">if</span> (res != OK) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Failed to enumerate flash units: %s (%d)"</span>, strerror(-res), res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; cameraId : mCameraProviderManager-&gt;getCameraDeviceIds()) &#123;</span><br><span class="line">        String8 id8 = String8(cameraId.c_str());</span><br><span class="line">        &#123;</span><br><span class="line">            Mutex::<span class="function">Autolock <span class="title">lock</span><span class="params">(mCameraStatesLock)</span></span>;</span><br><span class="line">            <span class="keyword">auto</span> iter = mCameraStates.find(id8);</span><br><span class="line">            <span class="keyword">if</span> (iter != mCameraStates.end()) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        hardware::camera::common::V1_0::CameraResourceCost cost;</span><br><span class="line">        res = mCameraProviderManager-&gt;getResourceCost(cameraId, &amp;cost);</span><br><span class="line">        <span class="keyword">if</span> (res != OK) &#123;</span><br><span class="line">            ALOGE(<span class="string">"Failed to query device resource cost: %s (%d)"</span>, strerror(-res), res);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">set</span>&lt;String8&gt; conflicting;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; cost.conflictingDevices.size(); i++) &#123;</span><br><span class="line">            conflicting.emplace(String8(cost.conflictingDevices[i].c_str()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            Mutex::<span class="function">Autolock <span class="title">lock</span><span class="params">(mCameraStatesLock)</span></span>;</span><br><span class="line">            mCameraStates.emplace(id8,</span><br><span class="line">                <span class="built_in">std</span>::make_shared&lt;CameraState&gt;(id8, cost.resourceCost, conflicting));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        onDeviceStatusChanged(id8, CameraDeviceStatus::PRESENT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mFlashlight-&gt;hasFlashUnit(id8)) &#123;</span><br><span class="line">            mTorchStatusMap.add(id8, TorchModeStatus::AVAILABLE_OFF);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单独做了flashlight闪光灯的初始化操作,不细看.然后获取所有deviceids,遍历调用getResourceCost方法,这个是返回device消耗的资源,然后做对应操作,最后onDeviceStatusChanged状态改变.</p><h3 id="连接hal层相机设备"><a href="#连接hal层相机设备" class="headerlink" title="连接hal层相机设备"></a>连接hal层相机设备</h3><p>在types.hal里找到了状态值的定义:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> CameraDeviceStatus : <span class="keyword">uint32_t</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The camera device is not currently connected, and trying to reference it</span></span><br><span class="line"><span class="comment">     * in provider method calls must return status code ILLEGAL_ARGUMENT.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    NOT_PRESENT = <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The camera device is connected, and opening it is possible, as long as</span></span><br><span class="line"><span class="comment">     * sufficient resources are available.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * By default, the framework must assume all devices returned by</span></span><br><span class="line"><span class="comment">     * ICameraProvider::getCameraIdList() are in this state.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    PRESENT = <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The camera device is connected, but it is undergoing enumeration and</span></span><br><span class="line"><span class="comment">     * startup, and so opening the device must return CAMERA_IN_USE.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Attempting to call ICameraProvider::getCameraCharacteristics() must</span></span><br><span class="line"><span class="comment">     * succeed, however.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ENUMERATING = <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>NOT_PRESENT是未连接,PRESENT是连接,ENUMERATING就是占用,那经过enumerateProviders就连接到了相机设备.enumerateProviders调用了mCameraProviderManager的初始化方法:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">CameraProviderManager::HardwareServiceInteractionProxy</span><br><span class="line">CameraProviderManager::sHardwareServiceInteractionProxy&#123;&#125;;</span><br><span class="line"></span><br><span class="line">CameraProviderManager::~CameraProviderManager() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">status_t</span> CameraProviderManager::initialize(wp&lt;CameraProviderManager::StatusListener&gt; listener,</span><br><span class="line">        ServiceInteractionProxy* proxy) &#123;</span><br><span class="line">    <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lock(mInterfaceMutex);</span><br><span class="line">    <span class="keyword">if</span> (proxy == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"%s: No valid service interaction proxy provided"</span>, __FUNCTION__);</span><br><span class="line">        <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    mListener = listener;</span><br><span class="line">    mServiceProxy = proxy;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Registering will trigger notifications for all already-known providers</span></span><br><span class="line">    <span class="keyword">bool</span> success = mServiceProxy-&gt;registerForNotifications(</span><br><span class="line">        <span class="comment">/* instance name, empty means no filter */</span> <span class="string">""</span>,</span><br><span class="line">        <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        ALOGE(<span class="string">"%s: Unable to register with hardware service manager for notifications "</span></span><br><span class="line">                <span class="string">"about camera providers"</span>, __FUNCTION__);</span><br><span class="line">        <span class="keyword">return</span> INVALID_OPERATION;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// See if there's a passthrough HAL, but let's not complain if there's not</span></span><br><span class="line">    addProviderLocked(kLegacyProviderName, <span class="comment">/*expected*/</span> <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> pDeviceInfo = pFindDeviceInfoLocked(</span><br><span class="line">            <span class="comment">/*minVersion*/</span> &#123;<span class="number">1</span>,<span class="number">0</span>&#125;, <span class="comment">/*maxVersion*/</span> &#123;<span class="number">2</span>,<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">auto</span> *pDeviceInfo1 = <span class="keyword">static_cast</span>&lt;ProviderInfo::DeviceInfo1*&gt;(pDeviceInfo);</span><br><span class="line">        gSession = pDeviceInfo1-&gt;mInterface;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(gSession != <span class="literal">nullptr</span>)</span><br><span class="line">       mQHidlDevice = vendor::qti::hardware::camera::device::V1_0::IQCameraDevice::castFrom(gSession);</span><br><span class="line"></span><br><span class="line">     mQHidlDevice-&gt;addParallelProcessListener(mHidlParallList);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CameraProviderManager是一个hidl代理,那肯定就是这里连接到了hal层方法了.先注册了一个通知,通过addProviderLocked连接到hal,然后获取deviceInfo,再获得mQHidlDevice,就可以调到hal层方法了.看下addProviderLocked方法:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> CameraProviderManager::addProviderLocked(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; newProvider, <span class="keyword">bool</span> expected) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; providerInfo : mProviders) &#123;</span><br><span class="line">        <span class="keyword">if</span> (providerInfo-&gt;mProviderName == newProvider) &#123;</span><br><span class="line">            ALOGW(<span class="string">"%s: Camera provider HAL with name '%s' already registered"</span>, __FUNCTION__,</span><br><span class="line">                    newProvider.c_str());</span><br><span class="line">            <span class="keyword">return</span> ALREADY_EXISTS;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp&lt;provider::V2_4::ICameraProvider&gt; interface;</span><br><span class="line">    interface = mServiceProxy-&gt;getService(newProvider);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (interface == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (expected) &#123;</span><br><span class="line">            ALOGE(<span class="string">"%s: Camera provider HAL '%s' is not actually available"</span>, __FUNCTION__,</span><br><span class="line">                    newProvider.c_str());</span><br><span class="line">            <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> OK;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp&lt;ProviderInfo&gt; providerInfo =</span><br><span class="line">            <span class="keyword">new</span> ProviderInfo(newProvider, interface, <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">status_t</span> res = providerInfo-&gt;initialize();</span><br><span class="line">    <span class="keyword">if</span> (res != OK) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mProviders.push_back(providerInfo);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取hidl的代理服务,关键是ProviderInfo的initialize方法,然后添加进mProviders里,继续看initialize方法:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> CameraProviderManager::ProviderInfo::initialize() &#123;</span><br><span class="line">    <span class="keyword">status_t</span> res = parseProviderName(mProviderName, &amp;mType, &amp;mId);</span><br><span class="line">    <span class="keyword">if</span> (res != OK) &#123;</span><br><span class="line">        ALOGE(<span class="string">"%s: Invalid provider name, ignoring"</span>, __FUNCTION__);</span><br><span class="line">        <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    ALOGI(<span class="string">"Connecting to new camera provider: %s, isRemote? %d"</span>,</span><br><span class="line">            mProviderName.c_str(), mInterface-&gt;isRemote());</span><br><span class="line">    hardware::Return&lt;Status&gt; status = mInterface-&gt;setCallback(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (!status.isOk()) &#123;</span><br><span class="line">        ALOGE(<span class="string">"%s: Transaction error setting up callbacks with camera provider '%s': %s"</span>,</span><br><span class="line">                __FUNCTION__, mProviderName.c_str(), status.description().c_str());</span><br><span class="line">        <span class="keyword">return</span> DEAD_OBJECT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (status != Status::OK) &#123;</span><br><span class="line">        ALOGE(<span class="string">"%s: Unable to register callbacks with camera provider '%s'"</span>,</span><br><span class="line">                __FUNCTION__, mProviderName.c_str());</span><br><span class="line">        <span class="keyword">return</span> mapToStatusT(status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hardware::Return&lt;<span class="keyword">bool</span>&gt; linked = mInterface-&gt;linkToDeath(<span class="keyword">this</span>, <span class="comment">/*cookie*/</span> mId);</span><br><span class="line">    <span class="keyword">if</span> (!linked.isOk()) &#123;</span><br><span class="line">        ALOGE(<span class="string">"%s: Transaction error in linking to camera provider '%s' death: %s"</span>,</span><br><span class="line">                __FUNCTION__, mProviderName.c_str(), linked.description().c_str());</span><br><span class="line">        <span class="keyword">return</span> DEAD_OBJECT;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!linked) &#123;</span><br><span class="line">        ALOGW(<span class="string">"%s: Unable to link to provider '%s' death notifications"</span>,</span><br><span class="line">                __FUNCTION__, mProviderName.c_str());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get initial list of camera devices, if any</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; devices;</span><br><span class="line">    hardware::Return&lt;<span class="keyword">void</span>&gt; ret = mInterface-&gt;getCameraIdList([&amp;status, &amp;devices](</span><br><span class="line">            Status idStatus,</span><br><span class="line">            <span class="keyword">const</span> hardware::hidl_vec&lt;hardware::hidl_string&gt;&amp; cameraDeviceNames) &#123;</span><br><span class="line">        status = idStatus;</span><br><span class="line">        <span class="keyword">if</span> (status == Status::OK) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; cameraDeviceNames.size(); i++) &#123;</span><br><span class="line">                devices.push_back(cameraDeviceNames[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; &#125;);</span><br><span class="line">    <span class="keyword">if</span> (!ret.isOk()) &#123;</span><br><span class="line">        ALOGE(<span class="string">"%s: Transaction error in getting camera ID list from provider '%s': %s"</span>,</span><br><span class="line">                __FUNCTION__, mProviderName.c_str(), linked.description().c_str());</span><br><span class="line">        <span class="keyword">return</span> DEAD_OBJECT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (status != Status::OK) &#123;</span><br><span class="line">        ALOGE(<span class="string">"%s: Unable to query for camera devices from provider '%s'"</span>,</span><br><span class="line">                __FUNCTION__, mProviderName.c_str());</span><br><span class="line">        <span class="keyword">return</span> mapToStatusT(status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp&lt;StatusListener&gt; listener = mManager-&gt;getStatusListener();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; device : devices) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> id;</span><br><span class="line">        <span class="keyword">status_t</span> res = addDevice(device,</span><br><span class="line">                hardware::camera::common::V1_0::CameraDeviceStatus::PRESENT, &amp;id);</span><br><span class="line">        <span class="keyword">if</span> (res != OK) &#123;</span><br><span class="line">            ALOGE(<span class="string">"%s: Unable to enumerate camera device '%s': %s (%d)"</span>,</span><br><span class="line">                    __FUNCTION__, device.c_str(), strerror(-res), res);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; device : mDevices) &#123;</span><br><span class="line">        mUniqueCameraIds.insert(device-&gt;mId);</span><br><span class="line">        <span class="keyword">if</span> (device-&gt;isAPI1Compatible()) &#123;</span><br><span class="line">            mUniqueAPI1CompatibleCameraIds.insert(device-&gt;mId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mUniqueDeviceCount = mUniqueCameraIds.size();</span><br><span class="line"></span><br><span class="line">    ALOGI(<span class="string">"Camera provider %s ready with %zu camera devices"</span>,</span><br><span class="line">            mProviderName.c_str(), mDevices.size());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里获取到camera设备,有device1,2,3,4,然后遍历调用addDevice方法,看addDevice方法:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> CameraProviderManager::ProviderInfo::addDevice(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name,</span><br><span class="line">        CameraDeviceStatus initialStatus, <span class="comment">/*out*/</span> <span class="built_in">std</span>::<span class="built_in">string</span>* parsedId) &#123;</span><br><span class="line">    ALOGI(<span class="string">"Enumerating new camera device: %s"</span>, name.c_str());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint16_t</span> major, minor;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> type, id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> res = parseDeviceName(name, &amp;major, &amp;minor, &amp;type, &amp;id);</span><br><span class="line">    <span class="keyword">if</span> (res != OK) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (type != mType) &#123;</span><br><span class="line">        ALOGE(<span class="string">"%s: Device type %s does not match provider type %s"</span>, __FUNCTION__,</span><br><span class="line">                type.c_str(), mType.c_str());</span><br><span class="line">        <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mManager-&gt;isValidDeviceLocked(id, major)) &#123;</span><br><span class="line">        ALOGE(<span class="string">"%s: Device %s: ID %s is already in use for device major version %d"</span>, __FUNCTION__,</span><br><span class="line">                name.c_str(), id.c_str(), major);</span><br><span class="line">        <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;DeviceInfo&gt; deviceInfo;</span><br><span class="line">    <span class="keyword">switch</span> (major) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            deviceInfo = initializeDeviceInfo&lt;DeviceInfo1&gt;(name, mProviderTagid,</span><br><span class="line">                    id, minor);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            deviceInfo = initializeDeviceInfo&lt;DeviceInfo3&gt;(name, mProviderTagid,</span><br><span class="line">                    id, minor);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            ALOGE(<span class="string">"%s: Device %s: Unknown HIDL device HAL major version %d:"</span>, __FUNCTION__,</span><br><span class="line">                    name.c_str(), major);</span><br><span class="line">            <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (deviceInfo == <span class="literal">nullptr</span>) <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">    deviceInfo-&gt;mStatus = initialStatus;</span><br><span class="line"></span><br><span class="line">    mDevices.push_back(<span class="built_in">std</span>::move(deviceInfo));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (parsedId != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        *parsedId = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过initializeDeviceInfo获取到deviceInfo,看initializeDeviceInfo方法:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">DeviceInfoT</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">std</span>:</span>:<span class="built_in">unique_ptr</span>&lt;CameraProviderManager::ProviderInfo::DeviceInfo&gt;</span><br><span class="line">    CameraProviderManager::ProviderInfo::initializeDeviceInfo(</span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name, <span class="keyword">const</span> <span class="keyword">metadata_vendor_id_t</span> tagId,</span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;id, <span class="keyword">uint16_t</span> minorVersion) <span class="keyword">const</span> &#123;</span><br><span class="line">    Status status;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> cameraInterface =</span><br><span class="line">            getDeviceInterface&lt;<span class="keyword">typename</span> DeviceInfoT::InterfaceT&gt;(name);</span><br><span class="line">    <span class="keyword">if</span> (cameraInterface == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    CameraResourceCost resourceCost;</span><br><span class="line">    cameraInterface-&gt;getResourceCost([&amp;status, &amp;resourceCost](</span><br><span class="line">        Status s, CameraResourceCost cost) &#123;</span><br><span class="line">                status = s;</span><br><span class="line">                resourceCost = cost;</span><br><span class="line">            &#125;);</span><br><span class="line">    <span class="keyword">if</span> (status != Status::OK) &#123;</span><br><span class="line">        ALOGE(<span class="string">"%s: Unable to obtain resource costs for camera device %s: %s"</span>, __FUNCTION__,</span><br><span class="line">                name.c_str(), statusToString(status));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;DeviceInfo&gt;(</span><br><span class="line">        <span class="keyword">new</span> DeviceInfoT(name, tagId, id, minorVersion, resourceCost,</span><br><span class="line">                cameraInterface));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>DeviceInfoT是一个模板类,找到DeviceInfo1的定义:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DeviceInfo1</span> :</span> <span class="keyword">public</span> DeviceInfo &#123;</span><br><span class="line">    <span class="keyword">typedef</span> hardware::camera::device::V1_0::ICameraDevice InterfaceT;</span><br><span class="line">    <span class="keyword">const</span> sp&lt;InterfaceT&gt; mInterface;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">setTorchMode</span><span class="params">(<span class="keyword">bool</span> enabled)</span> override</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">getCameraInfo</span><span class="params">(hardware::CameraInfo *info)</span> <span class="keyword">const</span> override</span>;</span><br><span class="line">    <span class="comment">//In case of Device1Info assume that we are always API1 compatible</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">isAPI1Compatible</span><span class="params">()</span> <span class="keyword">const</span> override </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">    DeviceInfo1(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">const</span> <span class="keyword">metadata_vendor_id_t</span> tagId,</span><br><span class="line">            <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;id, <span class="keyword">uint16_t</span> minorVersion,</span><br><span class="line">            <span class="keyword">const</span> hardware::camera::common::V1_0::CameraResourceCost&amp; resourceCost,</span><br><span class="line">            sp&lt;InterfaceT&gt; interface);</span><br><span class="line">    <span class="keyword">virtual</span> ~DeviceInfo1();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    CameraParameters2 mDefaultParameters;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>DeviceInfo1的mInterface就是一个ICameraDevice接口,可以用来调用hal层方法,看DeviceInfo1的实例方法:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">CameraProviderManager::ProviderInfo::DeviceInfo1::DeviceInfo1(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name,</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">metadata_vendor_id_t</span> tagId, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;id,</span><br><span class="line">        <span class="keyword">uint16_t</span> minorVersion,</span><br><span class="line">        <span class="keyword">const</span> CameraResourceCost&amp; resourceCost,</span><br><span class="line">        sp&lt;InterfaceT&gt; interface) :</span><br><span class="line">        DeviceInfo(name, tagId, id, hardware::hidl_version&#123;<span class="number">1</span>, minorVersion&#125;,</span><br><span class="line">                   resourceCost),</span><br><span class="line">        mInterface(interface) &#123;</span><br><span class="line">    <span class="comment">// Get default parameters and initialize flash unit availability</span></span><br><span class="line">    <span class="comment">// Requires powering on the camera device</span></span><br><span class="line">    hardware::Return&lt;Status&gt; status = mInterface-&gt;open(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span> (!status.isOk()) &#123;</span><br><span class="line">        ALOGE(<span class="string">"%s: Transaction error opening camera device %s to check for a flash unit: %s"</span>,</span><br><span class="line">                __FUNCTION__, mId.c_str(), status.description().c_str());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (status != Status::OK) &#123;</span><br><span class="line">        ALOGE(<span class="string">"%s: Unable to open camera device %s to check for a flash unit: %s"</span>, __FUNCTION__,</span><br><span class="line">                mId.c_str(), CameraProviderManager::statusToString(status));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    hardware::Return&lt;<span class="keyword">void</span>&gt; ret;</span><br><span class="line">    ret = mInterface-&gt;getParameters([<span class="keyword">this</span>](<span class="keyword">const</span> hardware::hidl_string&amp; parms) &#123;</span><br><span class="line">                mDefaultParameters.unflatten(String8(parms.c_str()));</span><br><span class="line">            &#125;);</span><br><span class="line">    <span class="keyword">if</span> (!ret.isOk()) &#123;</span><br><span class="line">        ALOGE(<span class="string">"%s: Transaction error reading camera device %s params to check for a flash unit: %s"</span>,</span><br><span class="line">                __FUNCTION__, mId.c_str(), status.description().c_str());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *flashMode =</span><br><span class="line">            mDefaultParameters.get(CameraParameters::KEY_SUPPORTED_FLASH_MODES);</span><br><span class="line">    <span class="keyword">if</span> (flashMode &amp;&amp; <span class="built_in">strstr</span>(flashMode, CameraParameters::FLASH_MODE_TORCH)) &#123;</span><br><span class="line">        mHasFlashUnit = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = mInterface-&gt;close();</span><br><span class="line">    <span class="keyword">if</span> (!ret.isOk()) &#123;</span><br><span class="line">        ALOGE(<span class="string">"%s: Transaction error closing camera device %s after check for a flash unit: %s"</span>,</span><br><span class="line">                __FUNCTION__, mId.c_str(), status.description().c_str());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里调用了mInterface的open方法,就调用到了相机hal的启动方法了.hal层方法留到之后单独分析.</p><h3 id="流程总结"><a href="#流程总结" class="headerlink" title="流程总结"></a>流程总结</h3><p>相机库的启动过程大概就是这样了.总结一下.</p><p>相机服务启动流程:</p><ol><li>init进程启动后启动其它系统服务,包括相机服务,调用cameraserver.rc的main方法</li><li>cameraserver.rc通过ServiceManager启动CameraService</li><li>CameraService被被创建后调用onFirstRef方法,创建CameraProviderManager</li><li>CameraProviderManager的创建一个ProviderInfo并初始化</li><li>ProviderInfo创建DeviceInfo并初始化</li><li>DeviceInfo初始化时调用ICameraDevice实例的open方法,调用到hal层方法</li><li>CameraService调用pingCameraServiceProxy连接到一个服务代理</li></ol><h2 id="打开相机"><a href="#打开相机" class="headerlink" title="打开相机"></a>打开相机</h2><h3 id="从framework到native"><a href="#从framework到native" class="headerlink" title="从framework到native"></a>从framework到native</h3><p>服务启动后再看下打开相机方法.还是从上层看起,在android.hardare.Camera里找相机启动方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Creates a new Camera object to access the first back-facing camera on the</span></span><br><span class="line"><span class="comment">  * device. If the device does not have a back-facing camera, this returns</span></span><br><span class="line"><span class="comment">  * null.</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@see</span> #open(int)</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Camera <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> numberOfCameras = getNumberOfCameras();</span><br><span class="line">     CameraInfo cameraInfo = <span class="keyword">new</span> CameraInfo();</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numberOfCameras; i++) &#123;</span><br><span class="line">         getCameraInfo(i, cameraInfo);</span><br><span class="line">         <span class="keyword">if</span> (cameraInfo.facing == CameraInfo.CAMERA_FACING_BACK) &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">new</span> Camera(i);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Create a legacy camera object.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> cameraId The hardware camera to access, between 0 and</span></span><br><span class="line"><span class="comment">  * &#123;<span class="doctag">@link</span> #getNumberOfCameras()&#125;-1.</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> halVersion The HAL API version this camera device to be opened as.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="title">Camera</span><span class="params">(<span class="keyword">int</span> cameraId, <span class="keyword">int</span> halVersion)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> err = cameraInitVersion(cameraId, halVersion);</span><br><span class="line">     <span class="keyword">if</span> (checkInitErrors(err)) &#123;</span><br><span class="line">         <span class="keyword">if</span> (err == -EACCES) &#123;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Fail to connect to camera service"</span>);</span><br><span class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (err == -ENODEV) &#123;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Camera initialization failed"</span>);</span><br><span class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (err == -ENOSYS) &#123;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Camera initialization failed because some methods"</span></span><br><span class="line">                     + <span class="string">" are not implemented"</span>);</span><br><span class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (err == -EOPNOTSUPP) &#123;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Camera initialization failed because the hal"</span></span><br><span class="line">                     + <span class="string">" version is not supported by this device"</span>);</span><br><span class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (err == -EINVAL) &#123;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Camera initialization failed because the input"</span></span><br><span class="line">                     + <span class="string">" arugments are invalid"</span>);</span><br><span class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (err == -EBUSY) &#123;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Camera initialization failed because the camera"</span></span><br><span class="line">                     + <span class="string">" device was already opened"</span>);</span><br><span class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (err == -EUSERS) &#123;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Camera initialization failed because the max"</span></span><br><span class="line">                     + <span class="string">" number of camera devices were already opened"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// Should never hit this.</span></span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Unknown camera error"</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">cameraInitVersion</span><span class="params">(<span class="keyword">int</span> cameraId, <span class="keyword">int</span> halVersion)</span> </span>&#123;</span><br><span class="line">     mShutterCallback = <span class="keyword">null</span>;</span><br><span class="line">     mRawImageCallback = <span class="keyword">null</span>;</span><br><span class="line">     mJpegCallback = <span class="keyword">null</span>;</span><br><span class="line">     mPreviewCallback = <span class="keyword">null</span>;</span><br><span class="line">     mPostviewCallback = <span class="keyword">null</span>;</span><br><span class="line">     mUsingPreviewAllocation = <span class="keyword">false</span>;</span><br><span class="line">     mZoomListener = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">     Looper looper;</span><br><span class="line">     <span class="keyword">if</span> ((looper = Looper.myLooper()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">         mEventHandler = <span class="keyword">new</span> EventHandler(<span class="keyword">this</span>, looper);</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((looper = Looper.getMainLooper()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">         mEventHandler = <span class="keyword">new</span> EventHandler(<span class="keyword">this</span>, looper);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         mEventHandler = <span class="keyword">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> native_setup(<span class="keyword">new</span> WeakReference&lt;Camera&gt;(<span class="keyword">this</span>), cameraId, halVersion,</span><br><span class="line">             ActivityThread.currentOpPackageName());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>open方法会去获取相机数量,一般就是前置相机和后置相机.然后调用私有实例方法,检查相机版本,在这个方法里创建了前面几篇一致介绍的mEventHandler,用来接受相机消息.然后就是调用native_setup,jni方法,我们在android_hardware_Camera.cpp找到其实现:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// connect to camera service</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> jint <span class="title">android_hardware_Camera_native_setup</span><span class="params">(JNIEnv *env, jobject thiz,</span></span></span><br><span class="line"><span class="function"><span class="params">    jobject weak_this, jint cameraId, jint halVersion, jstring clientPackageName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Convert jstring to String16</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char16_t</span> *rawClientName = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">char16_t</span>*&gt;(</span><br><span class="line">        env-&gt;GetStringChars(clientPackageName, <span class="literal">NULL</span>));</span><br><span class="line">    jsize rawClientNameLen = env-&gt;GetStringLength(clientPackageName);</span><br><span class="line">    <span class="function">String16 <span class="title">clientName</span><span class="params">(rawClientName, rawClientNameLen)</span></span>;</span><br><span class="line">    env-&gt;ReleaseStringChars(clientPackageName,</span><br><span class="line">                            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> jchar*&gt;(rawClientName));</span><br><span class="line"></span><br><span class="line">    sp&lt;Camera&gt; camera;</span><br><span class="line">    <span class="keyword">if</span> (halVersion == CAMERA_HAL_API_VERSION_NORMAL_CONNECT) &#123;</span><br><span class="line">        <span class="comment">// Default path: hal version is don't care, do normal camera connect.</span></span><br><span class="line">        camera = Camera::connect(cameraId, clientName,</span><br><span class="line">                Camera::USE_CALLING_UID, Camera::USE_CALLING_PID);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        jint status = Camera::connectLegacy(cameraId, halVersion, clientName,</span><br><span class="line">                Camera::USE_CALLING_UID, camera);</span><br><span class="line">        <span class="keyword">if</span> (status != NO_ERROR) &#123;</span><br><span class="line">            <span class="keyword">return</span> status;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (camera == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -EACCES;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// make sure camera hardware is alive</span></span><br><span class="line">    <span class="keyword">if</span> (camera-&gt;getStatus() != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">return</span> NO_INIT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    jclass clazz = env-&gt;GetObjectClass(thiz);</span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// This should never happen</span></span><br><span class="line">        jniThrowRuntimeException(env, <span class="string">"Can't find android/hardware/Camera"</span>);</span><br><span class="line">        <span class="keyword">return</span> INVALID_OPERATION;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We use a weak reference so the Camera object can be garbage collected.</span></span><br><span class="line">    <span class="comment">// The reference is only used as a proxy for callbacks.</span></span><br><span class="line">    sp&lt;JNICameraContext&gt; context = <span class="keyword">new</span> JNICameraContext(env, weak_this, clazz, camera);</span><br><span class="line">    context-&gt;incStrong((<span class="keyword">void</span>*)android_hardware_Camera_native_setup);</span><br><span class="line">    camera-&gt;setListener(context);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// save context in opaque field</span></span><br><span class="line">    env-&gt;SetLongField(thiz, fields.context, (jlong)context.get());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update default display orientation in case the sensor is reverse-landscape</span></span><br><span class="line">    CameraInfo cameraInfo;</span><br><span class="line">    <span class="keyword">status_t</span> rc = Camera::getCameraInfo(cameraId, &amp;cameraInfo);</span><br><span class="line">    <span class="keyword">if</span> (rc != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">return</span> rc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> defaultOrientation = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (cameraInfo.orientation) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">90</span>:</span><br><span class="line">            <span class="keyword">if</span> (cameraInfo.facing == CAMERA_FACING_FRONT) &#123;</span><br><span class="line">                defaultOrientation = <span class="number">180</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">180</span>:</span><br><span class="line">            defaultOrientation = <span class="number">180</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">270</span>:</span><br><span class="line">            <span class="keyword">if</span> (cameraInfo.facing != CAMERA_FACING_FRONT) &#123;</span><br><span class="line">                defaultOrientation = <span class="number">180</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            ALOGE(<span class="string">"Unexpected camera orientation %d!"</span>, cameraInfo.orientation);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (defaultOrientation != <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGV(<span class="string">"Setting default display orientation to %d"</span>, defaultOrientation);</span><br><span class="line">        rc = camera-&gt;sendCommand(CAMERA_CMD_SET_DISPLAY_ORIENTATION,</span><br><span class="line">                defaultOrientation, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (rc != NO_ERROR) &#123;</span><br><span class="line">            ALOGE(<span class="string">"Unable to update default orientation: %s (%d)"</span>,</span><br><span class="line">                    strerror(-rc), rc);</span><br><span class="line">            <span class="keyword">return</span> rc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法就是连接到相机服务,获取状态,设置监听等.我们只看连接方法,就是Camera::connect方法.</p><h3 id="连接到相机服务"><a href="#连接到相机服务" class="headerlink" title="连接到相机服务"></a>连接到相机服务</h3><p>在Camera.cpp中找到connect方法:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;Camera&gt; Camera::connect(<span class="keyword">int</span> cameraId, <span class="keyword">const</span> String16&amp; clientPackageName,</span><br><span class="line">        <span class="keyword">int</span> clientUid, <span class="keyword">int</span> clientPid)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> CameraBaseT::connect(cameraId, clientPackageName, clientUid, clientPid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>找到CameraBaseT的定义:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> CameraBase&lt;TCam&gt;         CameraBaseT;</span><br></pre></td></tr></table></figure></p><p>CameraBaseT等同于CameraBase<tcam>,在CameraBase.cpp里找到connect方法:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TCam, <span class="keyword">typename</span> TCamTraits&gt;</span><br><span class="line">sp&lt;TCam&gt; CameraBase&lt;TCam, TCamTraits&gt;::connect(<span class="keyword">int</span> cameraId,</span><br><span class="line">                                               <span class="keyword">const</span> String16&amp; clientPackageName,</span><br><span class="line">                                               <span class="keyword">int</span> clientUid, <span class="keyword">int</span> clientPid)</span><br><span class="line">&#123;</span><br><span class="line">    ALOGV(<span class="string">"%s: connect"</span>, __FUNCTION__);</span><br><span class="line">    sp&lt;TCam&gt; c = <span class="keyword">new</span> TCam(cameraId);</span><br><span class="line">    sp&lt;TCamCallbacks&gt; cl = c;</span><br><span class="line">    <span class="keyword">const</span> sp&lt;::android::hardware::ICameraService&gt; cs = getCameraService();</span><br><span class="line"></span><br><span class="line">    binder::Status ret;</span><br><span class="line">    <span class="keyword">if</span> (cs != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        TCamConnectService fnConnectService = TCamTraits::fnConnectService;</span><br><span class="line">        ret = (cs.get()-&gt;*fnConnectService)(cl, cameraId, clientPackageName, clientUid,</span><br><span class="line">                                               clientPid, <span class="comment">/*out*/</span> &amp;c-&gt;mCamera);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ret.isOk() &amp;&amp; c-&gt;mCamera != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        IInterface::asBinder(c-&gt;mCamera)-&gt;linkToDeath(c);</span><br><span class="line">        c-&gt;mStatus = NO_ERROR;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ALOGW(<span class="string">"An error occurred while connecting to camera %d: %s"</span>, cameraId,</span><br><span class="line">                (cs == <span class="literal">nullptr</span>) ? <span class="string">"Service not available"</span> : ret.toString8().<span class="built_in">string</span>());</span><br><span class="line">        c.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></tcam></p><p>这里获取了相机服务,然后调用TCamConnectService的fnConnectService方法,找到方法定义:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CameraTraits&lt;Camera&gt;::TCamConnectService CameraTraits&lt;Camera&gt;::fnConnectService =</span><br><span class="line">        &amp;::android::hardware::ICameraService::connect;</span><br></pre></td></tr></table></figure></p><p>connect这是一个远程调用,在aidl找到定义:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Open a camera device through the old camera API</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ICamera <span class="title">connect</span><span class="params">(ICameraClient client,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> cameraId,</span></span></span><br><span class="line"><span class="function"><span class="params">        String opPackageName,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> clientUid, <span class="keyword">int</span> clientPid)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Open a camera device through the new camera API</span></span><br><span class="line"><span class="comment"> * Only supported for device HAL versions &gt;= 3.2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ICameraDeviceUser <span class="title">connectDevice</span><span class="params">(ICameraDeviceCallbacks callbacks,</span></span></span><br><span class="line"><span class="function"><span class="params">        String cameraId,</span></span></span><br><span class="line"><span class="function"><span class="params">        String opPackageName,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> clientUid)</span></span>;</span><br></pre></td></tr></table></figure></p><p>在CameraService找到connect方法:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Status CameraService::connect(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;ICameraClient&gt;&amp; cameraClient,</span><br><span class="line">        <span class="keyword">int</span> cameraId,</span><br><span class="line">        <span class="keyword">const</span> String16&amp; clientPackageName,</span><br><span class="line">        <span class="keyword">int</span> clientUid,</span><br><span class="line">        <span class="keyword">int</span> clientPid,</span><br><span class="line">        <span class="comment">/*out*/</span></span><br><span class="line">        sp&lt;ICamera&gt;* device) &#123;</span><br><span class="line"></span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    Status ret = Status::ok();</span><br><span class="line">    String8 id = String8::format(<span class="string">"%d"</span>, cameraId);</span><br><span class="line">    sp&lt;Client&gt; client = <span class="literal">nullptr</span>;</span><br><span class="line">    ret = connectHelper&lt;ICameraClient,Client&gt;(cameraClient, id,</span><br><span class="line">            CAMERA_HAL_API_VERSION_UNSPECIFIED, clientPackageName, clientUid, clientPid, API_1,</span><br><span class="line">            <span class="comment">/*legacyMode*/</span> <span class="literal">false</span>, <span class="comment">/*shimUpdateOnly*/</span> <span class="literal">false</span>,</span><br><span class="line">            <span class="comment">/*out*/</span>client);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!ret.isOk()) &#123;</span><br><span class="line">        logRejected(id, getCallingPid(), String8(clientPackageName),</span><br><span class="line">                ret.toString8());</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *device = client;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>继续看connectHelper方法:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">CALLBACK</span>, <span class="title">class</span> <span class="title">CLIENT</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Status</span> <span class="title">CameraService</span>:</span>:connectHelper(<span class="keyword">const</span> sp&lt;CALLBACK&gt;&amp; cameraCb, <span class="keyword">const</span> String8&amp; cameraId,</span><br><span class="line">        <span class="keyword">int</span> halVersion, <span class="keyword">const</span> String16&amp; clientPackageName, <span class="keyword">int</span> clientUid, <span class="keyword">int</span> clientPid,</span><br><span class="line">        apiLevel effectiveApiLevel, <span class="keyword">bool</span> legacyMode, <span class="keyword">bool</span> shimUpdateOnly,</span><br><span class="line">        <span class="comment">/*out*/</span>sp&lt;CLIENT&gt;&amp; device) &#123;</span><br><span class="line">    binder::Status ret = binder::Status::ok();</span><br><span class="line"></span><br><span class="line">    <span class="function">String8 <span class="title">clientName8</span><span class="params">(clientPackageName)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> originalClientPid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ALOGI(<span class="string">"CameraService::connect call (PID %d \"%s\", camera ID %s) for HAL version %s and "</span></span><br><span class="line">            <span class="string">"Camera API version %d"</span>, clientPid, clientName8.<span class="built_in">string</span>(), cameraId.<span class="built_in">string</span>(),</span><br><span class="line">            (halVersion == <span class="number">-1</span>) ? <span class="string">"default"</span> : <span class="built_in">std</span>::to_string(halVersion).c_str(),</span><br><span class="line">            <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(effectiveApiLevel));</span><br><span class="line"></span><br><span class="line">    sp&lt;CLIENT&gt; client = <span class="literal">nullptr</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Acquire mServiceLock and prevent other clients from connecting</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;AutoConditionLock&gt; lock =</span><br><span class="line">                AutoConditionLock::waitAndAcquire(mServiceLockWrapper, DEFAULT_CONNECT_TIMEOUT_NS);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (lock == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ALOGE(<span class="string">"CameraService::connect (PID %d) rejected (too many other clients connecting)."</span></span><br><span class="line">                    , clientPid);</span><br><span class="line">            <span class="keyword">return</span> STATUS_ERROR_FMT(ERROR_MAX_CAMERAS_IN_USE,</span><br><span class="line">                    <span class="string">"Cannot open camera %s for \"%s\" (PID %d): Too many other clients connecting"</span>,</span><br><span class="line">                    cameraId.<span class="built_in">string</span>(), clientName8.<span class="built_in">string</span>(), clientPid);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Enforce client permissions and do basic sanity checks</span></span><br><span class="line">        <span class="keyword">if</span>(!(ret = validateConnectLocked(cameraId, clientName8,</span><br><span class="line">                <span class="comment">/*inout*/</span>clientUid, <span class="comment">/*inout*/</span>clientPid, <span class="comment">/*out*/</span>originalClientPid)).isOk()) &#123;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check the shim parameters after acquiring lock, if they have already been updated and</span></span><br><span class="line">        <span class="comment">// we were doing a shim update, return immediately</span></span><br><span class="line">        <span class="keyword">if</span> (shimUpdateOnly) &#123;</span><br><span class="line">            <span class="keyword">auto</span> cameraState = getCameraState(cameraId);</span><br><span class="line">            <span class="keyword">if</span> (cameraState != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!cameraState-&gt;getShimParams().isEmpty()) <span class="keyword">return</span> ret;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">status_t</span> err;</span><br><span class="line"></span><br><span class="line">        sp&lt;BasicClient&gt; clientTmp = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;resource_policy::ClientDescriptor&lt;String8, sp&lt;BasicClient&gt;&gt;&gt; partial;</span><br><span class="line">        <span class="keyword">if</span> ((err = handleEvictionsLocked(cameraId, originalClientPid, effectiveApiLevel,</span><br><span class="line">                IInterface::asBinder(cameraCb), clientName8, <span class="comment">/*out*/</span>&amp;clientTmp,</span><br><span class="line">                <span class="comment">/*out*/</span>&amp;partial)) != NO_ERROR) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (err) &#123;</span><br><span class="line">                <span class="keyword">case</span> -ENODEV:</span><br><span class="line">                    <span class="keyword">return</span> STATUS_ERROR_FMT(ERROR_DISCONNECTED,</span><br><span class="line">                            <span class="string">"No camera device with ID \"%s\" currently available"</span>,</span><br><span class="line">                            cameraId.<span class="built_in">string</span>());</span><br><span class="line">                <span class="keyword">case</span> -EBUSY:</span><br><span class="line">                    <span class="keyword">return</span> STATUS_ERROR_FMT(ERROR_CAMERA_IN_USE,</span><br><span class="line">                            <span class="string">"Higher-priority client using camera, ID \"%s\" currently unavailable"</span>,</span><br><span class="line">                            cameraId.<span class="built_in">string</span>());</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">return</span> STATUS_ERROR_FMT(ERROR_INVALID_OPERATION,</span><br><span class="line">                            <span class="string">"Unexpected error %s (%d) opening camera \"%s\""</span>,</span><br><span class="line">                            strerror(-err), err, cameraId.<span class="built_in">string</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (clientTmp.get() != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="comment">// Handle special case for API1 MediaRecorder where the existing client is returned</span></span><br><span class="line">            device = <span class="keyword">static_cast</span>&lt;CLIENT*&gt;(clientTmp.get());</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// give flashlight a chance to close devices if necessary.</span></span><br><span class="line">        mFlashlight-&gt;prepareDeviceOpen(cameraId);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> facing = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> deviceVersion = getDeviceVersion(cameraId, <span class="comment">/*out*/</span>&amp;facing);</span><br><span class="line">        <span class="keyword">if</span> (facing == <span class="number">-1</span>) &#123;</span><br><span class="line">            ALOGE(<span class="string">"%s: Unable to get camera device \"%s\"  facing"</span>, __FUNCTION__, cameraId.<span class="built_in">string</span>());</span><br><span class="line">            <span class="keyword">return</span> STATUS_ERROR_FMT(ERROR_INVALID_OPERATION,</span><br><span class="line">                    <span class="string">"Unable to get camera device \"%s\" facing"</span>, cameraId.<span class="built_in">string</span>());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sp&lt;BasicClient&gt; tmp = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(!(ret = makeClient(<span class="keyword">this</span>, cameraCb, clientPackageName, cameraId, facing, clientPid,</span><br><span class="line">                clientUid, getpid(), legacyMode, halVersion, deviceVersion, effectiveApiLevel,</span><br><span class="line">                <span class="comment">/*out*/</span>&amp;tmp)).isOk()) &#123;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        client = <span class="keyword">static_cast</span>&lt;CLIENT*&gt;(tmp.get());</span><br><span class="line"></span><br><span class="line">        LOG_ALWAYS_FATAL_IF(client.get() == <span class="literal">nullptr</span>, <span class="string">"%s: CameraService in invalid state"</span>,</span><br><span class="line">                __FUNCTION__);</span><br><span class="line"></span><br><span class="line">        err = client-&gt;initialize(mCameraProviderManager);</span><br><span class="line">        <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">            ALOGE(<span class="string">"%s: Could not initialize client from HAL."</span>, __FUNCTION__);</span><br><span class="line">            <span class="comment">// Errors could be from the HAL module open call or from AppOpsManager</span></span><br><span class="line">            <span class="keyword">switch</span>(err) &#123;</span><br><span class="line">                <span class="keyword">case</span> BAD_VALUE:</span><br><span class="line">                    <span class="keyword">return</span> STATUS_ERROR_FMT(ERROR_ILLEGAL_ARGUMENT,</span><br><span class="line">                            <span class="string">"Illegal argument to HAL module for camera \"%s\""</span>, cameraId.<span class="built_in">string</span>());</span><br><span class="line">                <span class="keyword">case</span> -EBUSY:</span><br><span class="line">                    <span class="keyword">return</span> STATUS_ERROR_FMT(ERROR_CAMERA_IN_USE,</span><br><span class="line">                            <span class="string">"Camera \"%s\" is already open"</span>, cameraId.<span class="built_in">string</span>());</span><br><span class="line">                <span class="keyword">case</span> -EUSERS:</span><br><span class="line">                    <span class="keyword">return</span> STATUS_ERROR_FMT(ERROR_MAX_CAMERAS_IN_USE,</span><br><span class="line">                            <span class="string">"Too many cameras already open, cannot open camera \"%s\""</span>,</span><br><span class="line">                            cameraId.<span class="built_in">string</span>());</span><br><span class="line">                <span class="keyword">case</span> PERMISSION_DENIED:</span><br><span class="line">                    <span class="keyword">return</span> STATUS_ERROR_FMT(ERROR_PERMISSION_DENIED,</span><br><span class="line">                            <span class="string">"No permission to open camera \"%s\""</span>, cameraId.<span class="built_in">string</span>());</span><br><span class="line">                <span class="keyword">case</span> -EACCES:</span><br><span class="line">                    <span class="keyword">return</span> STATUS_ERROR_FMT(ERROR_DISABLED,</span><br><span class="line">                            <span class="string">"Camera \"%s\" disabled by policy"</span>, cameraId.<span class="built_in">string</span>());</span><br><span class="line">                <span class="keyword">case</span> -ENODEV:</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">return</span> STATUS_ERROR_FMT(ERROR_INVALID_OPERATION,</span><br><span class="line">                            <span class="string">"Failed to initialize camera \"%s\": %s (%d)"</span>, cameraId.<span class="built_in">string</span>(),</span><br><span class="line">                            strerror(-err), err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Update shim paremeters for legacy clients</span></span><br><span class="line">        <span class="keyword">if</span> (effectiveApiLevel == API_1) &#123;</span><br><span class="line">            <span class="comment">// Assume we have always received a Client subclass for API1</span></span><br><span class="line">            sp&lt;Client&gt; shimClient = <span class="keyword">reinterpret_cast</span>&lt;Client*&gt;(client.get());</span><br><span class="line">            String8 rawParams = shimClient-&gt;getParameters();</span><br><span class="line">            <span class="function">CameraParameters <span class="title">params</span><span class="params">(rawParams)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">auto</span> cameraState = getCameraState(cameraId);</span><br><span class="line">            <span class="keyword">if</span> (cameraState != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                cameraState-&gt;setShimParams(params);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ALOGE(<span class="string">"%s: Cannot update shim parameters for camera %s, no such device exists."</span>,</span><br><span class="line">                        __FUNCTION__, cameraId.<span class="built_in">string</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (shimUpdateOnly) &#123;</span><br><span class="line">            <span class="comment">// If only updating legacy shim parameters, immediately disconnect client</span></span><br><span class="line">            mServiceLock.unlock();</span><br><span class="line">            client-&gt;disconnect();</span><br><span class="line">            mServiceLock.lock();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Otherwise, add client to active clients list</span></span><br><span class="line">            finishConnectLocked(client, partial);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// lock is destroyed, allow further connect calls</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Important: release the mutex here so the client can call back into the service from its</span></span><br><span class="line">    <span class="comment">// destructor (can be at the end of the call)</span></span><br><span class="line">    device = client;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里创建了BasicClient作为代理调用到hal方法,BasicClient实际是Client.</p><h3 id="连接到hal"><a href="#连接到hal" class="headerlink" title="连接到hal"></a>连接到hal</h3><p>找到CameraService.h中Client的定义:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> :</span> <span class="keyword">public</span> hardware::BnCamera, <span class="keyword">public</span> BasicClient</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> hardware::ICameraClient TCamCallbacks;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ICamera interface (see ICamera for details)</span></span><br><span class="line">    <span class="keyword">virtual</span> binder::<span class="function">Status <span class="title">disconnect</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t      <span class="title">connect</span><span class="params">(<span class="keyword">const</span> sp&lt;hardware::ICameraClient&gt;&amp; client)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t      <span class="title">lock</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t      <span class="title">unlock</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t      <span class="title">setPreviewTarget</span><span class="params">(<span class="keyword">const</span> sp&lt;IGraphicBufferProducer&gt;&amp; bufferProducer)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span>          <span class="title">setPreviewCallbackFlag</span><span class="params">(<span class="keyword">int</span> flag)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t      <span class="title">setPreviewCallbackTarget</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">const</span> sp&lt;IGraphicBufferProducer&gt;&amp; callbackProducer)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t      <span class="title">startPreview</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span>          <span class="title">stopPreview</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span>          <span class="title">previewEnabled</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t      <span class="title">setVideoBufferMode</span><span class="params">(<span class="keyword">int32_t</span> videoBufferMode)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t      <span class="title">startRecording</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span>          <span class="title">stopRecording</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span>          <span class="title">recordingEnabled</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span>          <span class="title">releaseRecordingFrame</span><span class="params">(<span class="keyword">const</span> sp&lt;IMemory&gt;&amp; mem)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t      <span class="title">autoFocus</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t      <span class="title">cancelAutoFocus</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t      <span class="title">takePicture</span><span class="params">(<span class="keyword">int</span> msgType)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t      <span class="title">setParameters</span><span class="params">(<span class="keyword">const</span> String8&amp; params)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> String8       <span class="title">getParameters</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t      <span class="title">sendCommand</span><span class="params">(<span class="keyword">int32_t</span> cmd, <span class="keyword">int32_t</span> arg1, <span class="keyword">int32_t</span> arg2)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t      <span class="title">setVideoTarget</span><span class="params">(<span class="keyword">const</span> sp&lt;IGraphicBufferProducer&gt;&amp; bufferProducer)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Interface used by CameraService</span></span><br><span class="line">    Client(<span class="keyword">const</span> sp&lt;CameraService&gt;&amp; cameraService,</span><br><span class="line">            <span class="keyword">const</span> sp&lt;hardware::ICameraClient&gt;&amp; cameraClient,</span><br><span class="line">            <span class="keyword">const</span> String16&amp; clientPackageName,</span><br><span class="line">            <span class="keyword">const</span> String8&amp; cameraIdStr,</span><br><span class="line">            <span class="keyword">int</span> cameraFacing,</span><br><span class="line">            <span class="keyword">int</span> clientPid,</span><br><span class="line">            <span class="keyword">uid_t</span> clientUid,</span><br><span class="line">            <span class="keyword">int</span> servicePid);</span><br><span class="line">    ~Client();</span><br></pre></td></tr></table></figure></p><p>这里看到了我们很多熟悉的方法包括connect,startPreview,setParameters等等.像前篇介绍的,最后Client的实现在CameraClient中,在CameraClient找到initialize方法:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> CameraClient::initialize(sp&lt;CameraProviderManager&gt; manager) &#123;</span><br><span class="line">    <span class="keyword">int</span> callingPid = getCallingPid();</span><br><span class="line">    <span class="keyword">status_t</span> res;</span><br><span class="line"></span><br><span class="line">    LOG1(<span class="string">"CameraClient::initialize E (pid %d, id %d)"</span>, callingPid, mCameraId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Verify ops permissions</span></span><br><span class="line">    res = startCameraOps();</span><br><span class="line">    <span class="keyword">if</span> (res != OK) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> camera_device_name[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">snprintf</span>(camera_device_name, <span class="keyword">sizeof</span>(camera_device_name), <span class="string">"%d"</span>, mCameraId);</span><br><span class="line"></span><br><span class="line">    mHardware = <span class="keyword">new</span> CameraHardwareInterface(camera_device_name);</span><br><span class="line">    res = mHardware-&gt;initialize(manager);</span><br><span class="line">    <span class="keyword">if</span> (res != OK) &#123;</span><br><span class="line">        ALOGE(<span class="string">"%s: Camera %d: unable to initialize device: %s (%d)"</span>,</span><br><span class="line">                __FUNCTION__, mCameraId, strerror(-res), res);</span><br><span class="line">        mHardware.clear();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mHardware-&gt;setCallbacks(notifyCallback,</span><br><span class="line">            dataCallback,</span><br><span class="line">            dataCallbackTimestamp,</span><br><span class="line">            handleCallbackTimestampBatch,</span><br><span class="line">            (<span class="keyword">void</span> *)(<span class="keyword">uintptr_t</span>)mCameraId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Enable zoom, error, focus, and metadata messages by default</span></span><br><span class="line">    enableMsgType(CAMERA_MSG_ERROR | CAMERA_MSG_ZOOM | CAMERA_MSG_FOCUS |</span><br><span class="line">                  CAMERA_MSG_PREVIEW_METADATA | CAMERA_MSG_FOCUS_MOVE);</span><br><span class="line"></span><br><span class="line">    LOG1(<span class="string">"CameraClient::initialize X (pid %d, id %d)"</span>, callingPid, mCameraId);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看到这里创建了一个CameraHardwareInterface,这个属于device1的类,调用其初始化,然后设置监听,最后设置可用的消息类型,再看下CameraHardwareInterface的初始化方法:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> CameraHardwareInterface::initialize(sp&lt;CameraProviderManager&gt; manager) &#123;</span><br><span class="line">    ALOGI(<span class="string">"Opening camera %s"</span>, mName.<span class="built_in">string</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> ret = manager-&gt;openSession(mName.<span class="built_in">string</span>(), <span class="keyword">this</span>, &amp;mHidlDevice);</span><br><span class="line">    <span class="keyword">if</span> (ret != OK) &#123;</span><br><span class="line">        ALOGE(<span class="string">"%s: openSession failed! %s (%d)"</span>, __FUNCTION__, strerror(-ret), ret);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里也调用了CameraProviderManager,通过openSession方法获得一个hidlDevice,Client里面定义的方法都是通过hidlDevice调用到hal层方法的.</p><h3 id="流程总结-1"><a href="#流程总结-1" class="headerlink" title="流程总结"></a>流程总结</h3><p>总结一下打开相机整体流程:</p><ol><li>Camera.java调用android_hardware_Camera.cpp中的jni方法打开相机</li><li>native层通过binder代理连接到CameraService</li><li>CameraService生成一个CameraClient</li><li>CameraClient生成一个CameraHardwareInterface</li><li>CameraHardwareInterface通过CameraProviderManager的openSession获得hidlDevice调用到hal方法</li></ol>]]></content>
    
    <summary type="html">
    
      相机流程深入解析:相机启动
    
    </summary>
    
    
      <category term="Android" scheme="http://anddymao.com/tags/Android/"/>
    
      <category term="Camera" scheme="http://anddymao.com/tags/Camera/"/>
    
  </entry>
  
  <entry>
    <title>Android8.0相机源码深入解析(三)</title>
    <link href="http://anddymao.com/2018/05/07/2018-5-7-%E7%9B%B8%E6%9C%BA%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90(%E4%B8%89)/"/>
    <id>http://anddymao.com/2018/05/07/2018-5-7-相机源码深入解析(三)/</id>
    <published>2018-05-07T04:00:00.000Z</published>
    <updated>2019-10-25T03:38:48.885Z</updated>
    
    <content type="html"><![CDATA[<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>上一篇介绍了app到hal层数据传递,本偏介绍hal到app的数据传递.</p><h2 id="数据传递场景"><a href="#数据传递场景" class="headerlink" title="数据传递场景"></a>数据传递场景</h2><p>app到hal层主要传递配置参数,hal到app传递数据用于哪些场景呢.Camera有很多回调方法,FaceDetection,onPreviewFrame,onPictureTaken等,这些明显是需要传回数据的.<br>我们到Camera.java中找回调方法的使用位置:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">EventHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span></span></span><br><span class="line"><span class="class"> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> Camera mCamera;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">EventHandler</span><span class="params">(Camera c, Looper looper)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">super</span>(looper);</span><br><span class="line">         mCamera = c;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">switch</span>(msg.what) &#123;</span><br><span class="line">         <span class="keyword">case</span> CAMERA_MSG_SHUTTER:</span><br><span class="line">             <span class="keyword">if</span> (mShutterCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">                 mShutterCallback.onShutter();</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">case</span> CAMERA_MSG_RAW_IMAGE:</span><br><span class="line">             <span class="keyword">if</span> (mRawImageCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">                 mRawImageCallback.onPictureTaken((<span class="keyword">byte</span>[])msg.obj, mCamera);</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">case</span> CAMERA_MSG_COMPRESSED_IMAGE:</span><br><span class="line">             <span class="keyword">if</span> (mJpegCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">                 mJpegCallback.onPictureTaken((<span class="keyword">byte</span>[])msg.obj, mCamera);</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">case</span> CAMERA_MSG_PREVIEW_FRAME:</span><br><span class="line">             PreviewCallback pCb = mPreviewCallback;</span><br><span class="line">             <span class="keyword">if</span> (pCb != <span class="keyword">null</span>) &#123;</span><br><span class="line">                 <span class="keyword">if</span> (mOneShot) &#123;</span><br><span class="line">                     <span class="comment">// Clear the callback variable before the callback</span></span><br><span class="line">                     <span class="comment">// in case the app calls setPreviewCallback from</span></span><br><span class="line">                     <span class="comment">// the callback function</span></span><br><span class="line">                     mPreviewCallback = <span class="keyword">null</span>;</span><br><span class="line">                 &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!mWithBuffer) &#123;</span><br><span class="line">                     <span class="comment">// We're faking the camera preview mode to prevent</span></span><br><span class="line">                     <span class="comment">// the app from being flooded with preview frames.</span></span><br><span class="line">                     <span class="comment">// Set to oneshot mode again.</span></span><br><span class="line">                     setHasPreviewCallback(<span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">                 &#125;</span><br><span class="line">                 pCb.onPreviewFrame((<span class="keyword">byte</span>[])msg.obj, mCamera);</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">case</span> CAMERA_MSG_POSTVIEW_FRAME:</span><br><span class="line">             <span class="keyword">if</span> (mPostviewCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">                 mPostviewCallback.onPictureTaken((<span class="keyword">byte</span>[])msg.obj, mCamera);</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">case</span> CAMERA_MSG_FOCUS:</span><br><span class="line">             AutoFocusCallback cb = <span class="keyword">null</span>;</span><br><span class="line">             <span class="keyword">synchronized</span> (mAutoFocusCallbackLock) &#123;</span><br><span class="line">                 cb = mAutoFocusCallback;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span> (cb != <span class="keyword">null</span>) &#123;</span><br><span class="line">                 <span class="keyword">boolean</span> success = msg.arg1 == <span class="number">0</span> ? <span class="keyword">false</span> : <span class="keyword">true</span>;</span><br><span class="line">                 cb.onAutoFocus(success, mCamera);</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">case</span> CAMERA_MSG_ZOOM:</span><br><span class="line">             <span class="keyword">if</span> (mZoomListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                 mZoomListener.onZoomChange(msg.arg1, msg.arg2 != <span class="number">0</span>, mCamera);</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">case</span> CAMERA_MSG_PREVIEW_METADATA:</span><br><span class="line">             <span class="keyword">if</span> (mFaceListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                 mFaceListener.onFaceDetection((Face[])msg.obj, mCamera);</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">case</span> CAMERA_MSG_ERROR :</span><br><span class="line">             Log.e(TAG, <span class="string">"Error "</span> + msg.arg1);</span><br><span class="line">             <span class="keyword">if</span> (mErrorCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">                 mErrorCallback.onError(msg.arg1, mCamera);</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">case</span> CAMERA_MSG_FOCUS_MOVE:</span><br><span class="line">             <span class="keyword">if</span> (mAutoFocusMoveCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">                 mAutoFocusMoveCallback.onAutoFocusMoving(msg.arg1 == <span class="number">0</span> ? <span class="keyword">false</span> : <span class="keyword">true</span>, mCamera);</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">default</span>:</span><br><span class="line">             Log.e(TAG, <span class="string">"Unknown message type "</span> + msg.what);</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>看到各种数据传递,包括预览,拍照,人脸,错误,聚焦等,用一个Handler获取消息,obj传递数据,我们根据人脸识别参数CAMERA_MSG_PREVIEW_METADATA来深入分析.</p><h2 id="jni到native-library"><a href="#jni到native-library" class="headerlink" title="jni到native library"></a>jni到native library</h2><p>找到这个消息是哪里发出来的,按照之前经验要去jni中找,没有找到CAMERA_MSG_PREVIEW_METADATA的传递,但在android_hardware_Camera.cpp中找到了传递人脸数据的地方:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> JNICameraContext::postMetadata(JNIEnv *env, <span class="keyword">int32_t</span> msgType, <span class="keyword">camera_frame_metadata_t</span> *metadata)</span><br><span class="line">&#123;</span><br><span class="line">    jobjectArray obj = <span class="literal">NULL</span>;</span><br><span class="line">    obj = (jobjectArray) env-&gt;NewObjectArray(metadata-&gt;number_of_faces,</span><br><span class="line">                                             mFaceClass, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Couldn't allocate face metadata array"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; metadata-&gt;number_of_faces; i++) &#123;</span><br><span class="line">        jobject face = env-&gt;NewObject(mFaceClass, fields.face_constructor);</span><br><span class="line">        env-&gt;SetObjectArrayElement(obj, i, face);</span><br><span class="line"></span><br><span class="line">        jobject rect = env-&gt;NewObject(mRectClass, fields.rect_constructor);</span><br><span class="line">        env-&gt;SetIntField(rect, fields.rect_left, metadata-&gt;faces[i].rect[<span class="number">0</span>]);</span><br><span class="line">        env-&gt;SetIntField(rect, fields.rect_top, metadata-&gt;faces[i].rect[<span class="number">1</span>]);</span><br><span class="line">        env-&gt;SetIntField(rect, fields.rect_right, metadata-&gt;faces[i].rect[<span class="number">2</span>]);</span><br><span class="line">        env-&gt;SetIntField(rect, fields.rect_bottom, metadata-&gt;faces[i].rect[<span class="number">3</span>]);</span><br><span class="line">        env-&gt;SetObjectField(face, fields.face_rect, rect);</span><br><span class="line">        env-&gt;SetIntField(face, fields.face_score, metadata-&gt;faces[i].score);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> optionalFields = metadata-&gt;faces[i].id != <span class="number">0</span></span><br><span class="line">            &amp;&amp; metadata-&gt;faces[i].left_eye[<span class="number">0</span>] != <span class="number">-2000</span> &amp;&amp; metadata-&gt;faces[i].left_eye[<span class="number">1</span>] != <span class="number">-2000</span></span><br><span class="line">            &amp;&amp; metadata-&gt;faces[i].right_eye[<span class="number">0</span>] != <span class="number">-2000</span> &amp;&amp; metadata-&gt;faces[i].right_eye[<span class="number">1</span>] != <span class="number">-2000</span></span><br><span class="line">            &amp;&amp; metadata-&gt;faces[i].mouth[<span class="number">0</span>] != <span class="number">-2000</span> &amp;&amp; metadata-&gt;faces[i].mouth[<span class="number">1</span>] != <span class="number">-2000</span>;</span><br><span class="line">        <span class="keyword">if</span> (optionalFields) &#123;</span><br><span class="line">            <span class="keyword">int32_t</span> id = metadata-&gt;faces[i].id;</span><br><span class="line">            env-&gt;SetIntField(face, fields.face_id, id);</span><br><span class="line"></span><br><span class="line">            jobject leftEye = env-&gt;NewObject(mPointClass, fields.point_constructor);</span><br><span class="line">            env-&gt;SetIntField(leftEye, fields.point_x, metadata-&gt;faces[i].left_eye[<span class="number">0</span>]);</span><br><span class="line">            env-&gt;SetIntField(leftEye, fields.point_y, metadata-&gt;faces[i].left_eye[<span class="number">1</span>]);</span><br><span class="line">            env-&gt;SetObjectField(face, fields.face_left_eye, leftEye);</span><br><span class="line">            env-&gt;DeleteLocalRef(leftEye);</span><br><span class="line"></span><br><span class="line">            jobject rightEye = env-&gt;NewObject(mPointClass, fields.point_constructor);</span><br><span class="line">            env-&gt;SetIntField(rightEye, fields.point_x, metadata-&gt;faces[i].right_eye[<span class="number">0</span>]);</span><br><span class="line">            env-&gt;SetIntField(rightEye, fields.point_y, metadata-&gt;faces[i].right_eye[<span class="number">1</span>]);</span><br><span class="line">            env-&gt;SetObjectField(face, fields.face_right_eye, rightEye);</span><br><span class="line">            env-&gt;DeleteLocalRef(rightEye);</span><br><span class="line"></span><br><span class="line">            jobject mouth = env-&gt;NewObject(mPointClass, fields.point_constructor);</span><br><span class="line">            env-&gt;SetIntField(mouth, fields.point_x, metadata-&gt;faces[i].mouth[<span class="number">0</span>]);</span><br><span class="line">            env-&gt;SetIntField(mouth, fields.point_y, metadata-&gt;faces[i].mouth[<span class="number">1</span>]);</span><br><span class="line">            env-&gt;SetObjectField(face, fields.face_mouth, mouth);</span><br><span class="line">            env-&gt;DeleteLocalRef(mouth);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mIsExtendedFace) &#123;</span><br><span class="line">                env-&gt;SetIntField(face, fields.face_sm_degree, metadata-&gt;faces[i].smile_degree);</span><br><span class="line">                env-&gt;SetIntField(face, fields.face_sm_score, metadata-&gt;faces[i].smile_score);</span><br><span class="line">                env-&gt;SetIntField(face, fields.face_blink_detected, metadata-&gt;faces[i].blink_detected);</span><br><span class="line">                env-&gt;SetIntField(face, fields.face_recognised, metadata-&gt;faces[i].face_recognised);</span><br><span class="line">                env-&gt;SetIntField(face, fields.face_gaze_angle, metadata-&gt;faces[i].gaze_angle);</span><br><span class="line">                env-&gt;SetIntField(face, fields.face_updown_dir, metadata-&gt;faces[i].updown_dir);</span><br><span class="line">                env-&gt;SetIntField(face, fields.face_leftright_dir, metadata-&gt;faces[i].leftright_dir);</span><br><span class="line">                env-&gt;SetIntField(face, fields.face_roll_dir, metadata-&gt;faces[i].roll_dir);</span><br><span class="line">                env-&gt;SetIntField(face, fields.face_leye_blink, metadata-&gt;faces[i].leye_blink);</span><br><span class="line">                env-&gt;SetIntField(face, fields.face_reye_blink, metadata-&gt;faces[i].reye_blink);</span><br><span class="line">                env-&gt;SetIntField(face, fields.face_left_right_gaze, metadata-&gt;faces[i].left_right_gaze);</span><br><span class="line">                env-&gt;SetIntField(face, fields.face_top_bottom_gaze, metadata-&gt;faces[i].top_bottom_gaze);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        env-&gt;DeleteLocalRef(face);</span><br><span class="line">        env-&gt;DeleteLocalRef(rect);</span><br><span class="line">    &#125;</span><br><span class="line">    env-&gt;CallStaticVoidMethod(mCameraJClass, fields.post_event,</span><br><span class="line">            mCameraJObjectWeak, msgType, <span class="number">0</span>, <span class="number">0</span>, obj);</span><br><span class="line">    env-&gt;DeleteLocalRef(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里做了一次jni中C到java的数据转换,把C对象转成了java对象的Face数据,然后发送消息到Camera.java的handler中.<br>继续找CAMERA_MSG_PREVIEW_METADATA,在CameraClient中找到了:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> CameraClient::dataCallback(<span class="keyword">int32_t</span> msgType,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;IMemory&gt;&amp; dataPtr, <span class="keyword">camera_frame_metadata_t</span> *metadata, <span class="keyword">void</span>* user) &#123;</span><br><span class="line">    LOG2(<span class="string">"dataCallback(%d)"</span>, msgType);</span><br><span class="line"></span><br><span class="line">    sp&lt;CameraClient&gt; client = getClientFromCookie(user);</span><br><span class="line">    <span class="keyword">if</span> (client.get() == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!client-&gt;lockIfMessageWanted(msgType)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (dataPtr == <span class="number">0</span> &amp;&amp; metadata == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Null data returned in data callback"</span>);</span><br><span class="line">        client-&gt;handleGenericNotify(CAMERA_MSG_ERROR, UNKNOWN_ERROR, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (msgType &amp; ~CAMERA_MSG_PREVIEW_METADATA) &#123;</span><br><span class="line">        <span class="keyword">case</span> CAMERA_MSG_PREVIEW_FRAME:</span><br><span class="line">            client-&gt;handlePreviewData(msgType, dataPtr, metadata);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> CAMERA_MSG_POSTVIEW_FRAME:</span><br><span class="line">            client-&gt;handlePostview(dataPtr);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> CAMERA_MSG_RAW_IMAGE:</span><br><span class="line">            client-&gt;handleRawPicture(dataPtr);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> CAMERA_MSG_COMPRESSED_IMAGE:</span><br><span class="line">            client-&gt;handleCompressedPicture(dataPtr);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            client-&gt;handleGenericData(msgType, dataPtr, metadata);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里是把CAMERA_MSG_PREVIEW_METADATA消息屏蔽了,不是我们想要的.<br>在FrameProcessor找到了使用地方,FrameProcessor在libcameraservice的api1目录:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> FrameProcessor::callbackFaceDetection(<span class="keyword">const</span> sp&lt;Camera2Client&gt;&amp; client,</span><br><span class="line">                                     <span class="keyword">const</span> camera_frame_metadata &amp;metadata) &#123;</span><br><span class="line"></span><br><span class="line">    camera_frame_metadata *metadata_ptr =</span><br><span class="line">        <span class="keyword">const_cast</span>&lt;camera_frame_metadata*&gt;(&amp;metadata);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Filter out repeated 0-face callbacks,</span></span><br><span class="line"><span class="comment">     * but not when the last frame was &gt;0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (metadata.number_of_faces != <span class="number">0</span> ||</span><br><span class="line">        mLastFrameNumberOfFaces != metadata.number_of_faces) &#123;</span><br><span class="line"></span><br><span class="line">        Camera2Client::SharedCameraCallbacks::Lock</span><br><span class="line">            l(client-&gt;mSharedCameraCallbacks);</span><br><span class="line">        <span class="keyword">if</span> (l.mRemoteCallback != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            l.mRemoteCallback-&gt;dataCallback(CAMERA_MSG_PREVIEW_METADATA,</span><br><span class="line">                                            <span class="literal">NULL</span>,</span><br><span class="line">                                            metadata_ptr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mLastFrameNumberOfFaces = metadata.number_of_faces;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>在FrameProcessor找到processFaceDetect调用callbackFaceDetection,processSingleFrame调用callbackFaceDetection,FrameProcessorBase::processNewFrames调用processSingleFrame.然后看processNewFrames:</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> FrameProcessorBase::threadLoop() &#123;</span><br><span class="line">    <span class="keyword">status_t</span> res;</span><br><span class="line"></span><br><span class="line">    sp&lt;CameraDeviceBase&gt; device;</span><br><span class="line">    &#123;</span><br><span class="line">        device = mDevice.promote();</span><br><span class="line">        <span class="keyword">if</span> (device == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res = device-&gt;waitForNextFrame(kWaitDuration);</span><br><span class="line">    <span class="keyword">if</span> (res == OK) &#123;</span><br><span class="line">        processNewFrames(device);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (res != TIMED_OUT) &#123;</span><br><span class="line">        ALOGE(<span class="string">"FrameProcessorBase: Error waiting for new "</span></span><br><span class="line">                <span class="string">"frames: %s (%d)"</span>, strerror(-res), res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FrameProcessorBase是一个循环,找到启动地方:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> TProviderPtr&gt;</span><br><span class="line"><span class="keyword">status_t</span> CameraDeviceClient::initializeImpl(TProviderPtr providerPtr) &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    <span class="keyword">status_t</span> res;</span><br><span class="line"></span><br><span class="line">    res = Camera2ClientBase::initialize(providerPtr);</span><br><span class="line">    <span class="keyword">if</span> (res != OK) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String8 threadName;</span><br><span class="line">    mFrameProcessor = <span class="keyword">new</span> FrameProcessorBase(mDevice);</span><br><span class="line">    threadName = String8::format(<span class="string">"CDU-%s-FrameProc"</span>, mCameraIdStr.<span class="built_in">string</span>());</span><br><span class="line">    mFrameProcessor-&gt;run(threadName.<span class="built_in">string</span>());</span><br><span class="line"></span><br><span class="line">    mFrameProcessor-&gt;registerListener(FRAME_PROCESSOR_LISTENER_MIN_ID,</span><br><span class="line">                                      FRAME_PROCESSOR_LISTENER_MAX_ID,</span><br><span class="line">                                      <span class="comment">/*listener*/</span><span class="keyword">this</span>,</span><br><span class="line">                                      <span class="comment">/*sendPartials*/</span><span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CameraDeviceClient在api2的包里,api2走这部分逻辑,api1部分在Camera2Client找到了:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> TProviderPtr&gt;</span><br><span class="line"><span class="keyword">status_t</span> Camera2Client::initializeImpl(TProviderPtr providerPtr)</span><br><span class="line">&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    ALOGV(<span class="string">"%s: Initializing client for camera %d"</span>, __FUNCTION__, mCameraId);</span><br><span class="line">    <span class="keyword">status_t</span> res;</span><br><span class="line"></span><br><span class="line">    res = Camera2ClientBase::initialize(providerPtr);</span><br><span class="line">    <span class="keyword">if</span> (res != OK) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">    ...</span><br><span class="line">    mFrameProcessor = <span class="keyword">new</span> FrameProcessor(mDevice, <span class="keyword">this</span>);</span><br><span class="line">    threadName = String8::format(<span class="string">"C2-%d-FrameProc"</span>,</span><br><span class="line">            mCameraId);</span><br><span class="line">    mFrameProcessor-&gt;run(threadName.<span class="built_in">string</span>());</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>重新理下整个流程,不管api2的部分,在Camera2Client初始化时启动FrameProcessor的线程,给FrameProcessor绑定一个device,FrameProcessor线程调用processNewFrames,processNewFrames调用processSingleFrame,processSingleFrame调用callbackFaceDetection,然后通过CameraClient发出消息CAMERA_MSG_PREVIEW_METADATA消息到app层,触发FaceDetection的回调.<br>api2的不同点就是通过CameraDeviceClient,没有使用Camera2Client.通过包区分API.<br>但我们还没看到实际的人脸识别方法和数据传递,这些肯定是在hal层,继续数据传递代码.</p><h2 id="从native到hal层"><a href="#从native到hal层" class="headerlink" title="从native到hal层"></a>从native到hal层</h2><p>看processNewFrames方法:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> FrameProcessorBase::processNewFrames(<span class="keyword">const</span> sp&lt;CameraDeviceBase&gt; &amp;device) &#123;</span><br><span class="line">    <span class="keyword">status_t</span> res;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    CaptureResult result;</span><br><span class="line"></span><br><span class="line">    ALOGV(<span class="string">"%s: Camera %s: Process new frames"</span>, __FUNCTION__, device-&gt;getId().<span class="built_in">string</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ( (res = device-&gt;getNextResult(&amp;result)) == OK) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> instead of getting frame number from metadata, we should read</span></span><br><span class="line">        <span class="comment">// this from result.mResultExtras when CameraDeviceBase interface is fixed.</span></span><br><span class="line">        <span class="keyword">camera_metadata_entry_t</span> entry;</span><br><span class="line"></span><br><span class="line">        entry = result.mMetadata.find(ANDROID_REQUEST_FRAME_COUNT);</span><br><span class="line">        <span class="keyword">if</span> (entry.count == <span class="number">0</span>) &#123;</span><br><span class="line">            ALOGE(<span class="string">"%s: Camera %s: Error reading frame number"</span>,</span><br><span class="line">                    __FUNCTION__, device-&gt;getId().<span class="built_in">string</span>());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ATRACE_INT(<span class="string">"cam2_frame"</span>, entry.data.i32[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!processSingleFrame(result, device)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!result.mMetadata.isEmpty()) &#123;</span><br><span class="line">            Mutex::<span class="function">Autolock <span class="title">al</span><span class="params">(mLastFrameMutex)</span></span>;</span><br><span class="line">            mLastFrame.acquire(result.mMetadata);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (res != NOT_ENOUGH_DATA) &#123;</span><br><span class="line">        ALOGE(<span class="string">"%s: Camera %s: Error getting next frame: %s (%d)"</span>,</span><br><span class="line">                __FUNCTION__, device-&gt;getId().<span class="built_in">string</span>(), strerror(-res), res);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在一个while循环里通过device的getNextResult方法获取数据,然后送到processSingleFrame里.<br>获取数据的是device-&gt;getNextResult方法,这个定义在devices3里:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> Camera3Device::getNextResult(CaptureResult *frame) &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">l</span><span class="params">(mOutputLock)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mResultQueue.empty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> NOT_ENOUGH_DATA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (frame == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"%s: argument cannot be NULL"</span>, __FUNCTION__);</span><br><span class="line">        <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CaptureResult &amp;result = *(mResultQueue.begin());</span><br><span class="line">    frame-&gt;mResultExtras = result.mResultExtras;</span><br><span class="line">    frame-&gt;mMetadata.acquire(result.mMetadata);</span><br><span class="line">    mResultQueue.erase(mResultQueue.begin());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>mResultQueue是一个队列,获取到一个后然后使用,最后擦除.接下来找mResultQueue的调用:</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Camera3Device::insertResultLocked(CaptureResult *result,</span><br><span class="line">        <span class="keyword">uint32_t</span> frameNumber) &#123;</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">camera_metadata_t</span> *meta = <span class="keyword">const_cast</span>&lt;<span class="keyword">camera_metadata_t</span> *&gt;(</span><br><span class="line">            result-&gt;mMetadata.getAndLock());</span><br><span class="line">    set_camera_metadata_vendor_id(meta, mVendorTagId);</span><br><span class="line">    result-&gt;mMetadata.unlock(meta);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result-&gt;mMetadata.update(ANDROID_REQUEST_FRAME_COUNT,</span><br><span class="line">            (<span class="keyword">int32_t</span>*)&amp;frameNumber, <span class="number">1</span>) != OK) &#123;</span><br><span class="line">        SET_ERR(<span class="string">"Failed to set frame number %d in metadata"</span>, frameNumber);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result-&gt;mMetadata.update(ANDROID_REQUEST_ID, &amp;result-&gt;mResultExtras.requestId, <span class="number">1</span>) != OK) &#123;</span><br><span class="line">        SET_ERR(<span class="string">"Failed to set request ID in metadata for frame %d"</span>, frameNumber);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Valid result, insert into queue</span></span><br><span class="line">    List&lt;CaptureResult&gt;::iterator queuedResult =</span><br><span class="line">            mResultQueue.insert(mResultQueue.end(), CaptureResult(*result));</span><br><span class="line">    ALOGVV(<span class="string">"%s: result requestId = %"</span> PRId32 <span class="string">", frameNumber = %"</span> PRId64</span><br><span class="line">           <span class="string">", burstId = %"</span> PRId32, __FUNCTION__,</span><br><span class="line">           queuedResult-&gt;mResultExtras.requestId,</span><br><span class="line">           queuedResult-&gt;mResultExtras.frameNumber,</span><br><span class="line">           queuedResult-&gt;mResultExtras.burstId);</span><br><span class="line"></span><br><span class="line">    mResultSignal.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>insertResultLocked中有mResultQueue的插入方法,继续查找调用.找到hardware方法processCaptureResult,其调用过程是hardware::processCaptureResult-&gt;Camera3Device::processOneCaptureResultLocked-&gt;Camera3Device::sendPartialCaptureResult-&gt;Camera3Device::insertResultLocked-&gt;Camera3Device::insertResultLocked.hardware::processCaptureResult方法:</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Only one processCaptureResult should be called at a time, so</span></span><br><span class="line"><span class="comment">// the locks won't block. The locks are present here simply to enforce this.</span></span><br><span class="line">hardware::Return&lt;<span class="keyword">void</span>&gt; Camera3Device::processCaptureResult(</span><br><span class="line">        <span class="keyword">const</span> hardware::hidl_vec&lt;</span><br><span class="line">                hardware::camera::device::V3_2::CaptureResult&gt;&amp; results) &#123;</span><br><span class="line">    <span class="comment">// Ideally we should grab mLock, but that can lead to deadlock, and</span></span><br><span class="line">    <span class="comment">// it's not super important to get up to date value of mStatus for this</span></span><br><span class="line">    <span class="comment">// warning print, hence skipping the lock here</span></span><br><span class="line">    <span class="keyword">if</span> (mStatus == STATUS_ERROR) &#123;</span><br><span class="line">        <span class="comment">// Per API contract, HAL should act as closed after device error</span></span><br><span class="line">        <span class="comment">// But mStatus can be set to error by framework as well, so just log</span></span><br><span class="line">        <span class="comment">// a warning here.</span></span><br><span class="line">        ALOGW(<span class="string">"%s: received capture result in error state."</span>, __FUNCTION__);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mProcessCaptureResultLock.tryLock() != OK) &#123;</span><br><span class="line">        <span class="comment">// This should never happen; it indicates a wrong client implementation</span></span><br><span class="line">        <span class="comment">// that doesn't follow the contract. But, we can be tolerant here.</span></span><br><span class="line">        ALOGE(<span class="string">"%s: callback overlapped! waiting 1s..."</span>,</span><br><span class="line">                __FUNCTION__);</span><br><span class="line">        <span class="keyword">if</span> (mProcessCaptureResultLock.timedLock(<span class="number">1000000000</span> <span class="comment">/* 1s */</span>) != OK) &#123;</span><br><span class="line">            ALOGE(<span class="string">"%s: cannot acquire lock in 1s, dropping results"</span>,</span><br><span class="line">                    __FUNCTION__);</span><br><span class="line">            <span class="comment">// really don't know what to do, so bail out.</span></span><br><span class="line">            <span class="keyword">return</span> hardware::Void();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; result : results) &#123;</span><br><span class="line">        processOneCaptureResultLocked(result);</span><br><span class="line">    &#125;</span><br><span class="line">    mProcessCaptureResultLock.unlock();</span><br><span class="line">    <span class="keyword">return</span> hardware::Void();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>这里获取了一个锁,然后处理捕获的结果,最后释放锁.hardware::processCaptureResult就是hidl方法了,果然在ICameraDeviceSession.hal里面找到了定义:</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">processCaptureRequest(vec&lt;CaptureRequest&gt; requests,</span><br><span class="line">        vec&lt;BufferCache&gt; cachesToRemove)</span><br><span class="line">        generates (Status status, <span class="keyword">uint32_t</span> numRequestProcessed);</span><br></pre></td></tr></table></figure><pre><code>在ICameraDeviceSession.cpp里面可以看到方法的实现:</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Return&lt;<span class="keyword">void</span>&gt; CameraDeviceSession::processCaptureRequest(</span><br><span class="line">        <span class="keyword">const</span> hidl_vec&lt;CaptureRequest&gt;&amp; requests,</span><br><span class="line">        <span class="keyword">const</span> hidl_vec&lt;BufferCache&gt;&amp; cachesToRemove,</span><br><span class="line">        ICameraDeviceSession::processCaptureRequest_cb _hidl_cb)  &#123;</span><br><span class="line">    updateBufferCaches(cachesToRemove);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> numRequestProcessed = <span class="number">0</span>;</span><br><span class="line">    Status s = Status::OK;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; requests.size(); i++, numRequestProcessed++) &#123;</span><br><span class="line">        s = processOneCaptureRequest(requests[i]);</span><br><span class="line">        <span class="keyword">if</span> (s != Status::OK) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s == Status::OK &amp;&amp; requests.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        mResultBatcher.registerBatch(requests);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _hidl_cb(s, numRequestProcessed);</span><br><span class="line">    <span class="keyword">return</span> Void();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总结一下整体流程:</p><ol><li>CameraServer从hal层调用processCaptureRequest,发出一个CaptureResult到Camera3Device的mResultQueue队列中</li><li>在FrameProcessorBase的线程里等待新的frame,然后调用processNewFrames处理每一帧</li><li>在processNewFrames中循环获取mResultQueue的最新结果,通过processSingleFrame处理,处理调用callbackFaceDetection发送到CameraClient</li><li>callbackFaceDetection发出CAMERA_MSG_PREVIEW_METADATA的消息和metadata数据</li><li>JniContext使用postMetadata把消息发送到framework层</li><li>Camera的EventHandler收到消息,通过mFaceListener回调到app层</li></ol><p>这个流程走下来hal层到app的数据调用基本清楚了,所有的拍照,人脸,预览的数据都是如此传递的.但我们还不清楚CameraServer的整体流程,相机服务什么启动,这些数据从哪里捕获,什么时候下发的.<br>我们下一篇分析相机启动的流程.</p>]]></content>
    
    <summary type="html">
    
      相机流程深入解析:hal到app数据传递
    
    </summary>
    
    
      <category term="Android" scheme="http://anddymao.com/tags/Android/"/>
    
      <category term="Camera" scheme="http://anddymao.com/tags/Camera/"/>
    
  </entry>
  
  <entry>
    <title>Android8.0相机源码深入解析(二)</title>
    <link href="http://anddymao.com/2018/05/05/2018-5-5-%E7%9B%B8%E6%9C%BA%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90(%E4%BA%8C)/"/>
    <id>http://anddymao.com/2018/05/05/2018-5-5-相机源码深入解析(二)/</id>
    <published>2018-05-05T04:00:00.000Z</published>
    <updated>2019-10-25T03:38:48.885Z</updated>
    
    <content type="html"><![CDATA[<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>上一篇介绍了framework到hal的调用过程,从framework到相机本地库到hal层.本篇介绍app和hal层数据传递.</p><h2 id="app到相机本地库"><a href="#app到相机本地库" class="headerlink" title="app到相机本地库"></a>app到相机本地库</h2><p>app到hal层数据传递有Camera的方法setParameters传递参数,Parameters是Camera的内部类,主要包含一个LinkedHashMap对象.看Camera的方法实现:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Changes the settings for this Camera service.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param params the Parameters to use for this Camera service</span></span><br><span class="line"><span class="comment"> * @throws RuntimeException if any parameter is invalid or not supported.</span></span><br><span class="line"><span class="comment"> * @see #getParameters()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParameters</span><span class="params">(Parameters params)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// If using preview allocations, don't allow preview size changes</span></span><br><span class="line">    <span class="keyword">if</span> (mUsingPreviewAllocation) &#123;</span><br><span class="line">        Size newPreviewSize = params.getPreviewSize();</span><br><span class="line">        Size currentPreviewSize = getParameters().getPreviewSize();</span><br><span class="line">        <span class="keyword">if</span> (newPreviewSize.width != currentPreviewSize.width ||</span><br><span class="line">                newPreviewSize.height != currentPreviewSize.height) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot change preview size"</span> +</span><br><span class="line">                    <span class="string">" while a preview allocation is configured."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    native_setParameters(params.flatten());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> native final <span class="keyword">void</span> <span class="title">native_setParameters</span><span class="params">(String params)</span></span>;</span><br></pre></td></tr></table></figure><p>预览时不能改变窗口大小,然后使用native方法.<br>找到native方法,根据前一篇的流程,同样可以在android_hardware_Camera.cpp找到jni方法的定义和native方法:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_hardware_Camera_setParameters</span><span class="params">(JNIEnv *env, jobject thiz, jstring params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ALOGV(<span class="string">"setParameters"</span>);</span><br><span class="line">    sp&lt;Camera&gt; camera = get_native_camera(env, thiz, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (camera == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> jchar* str = env-&gt;GetStringCritical(params, <span class="number">0</span>);</span><br><span class="line">    String8 params8;</span><br><span class="line">    <span class="keyword">if</span> (params) &#123;</span><br><span class="line">        params8 = String8(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">char16_t</span>*&gt;(str),</span><br><span class="line">                          env-&gt;GetStringLength(params));</span><br><span class="line">        env-&gt;ReleaseStringCritical(params, str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (camera-&gt;setParameters(params8) != NO_ERROR) &#123;</span><br><span class="line">        jniThrowRuntimeException(env, <span class="string">"setParameters failed"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后到Camera.cpp</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String8 Camera::getParameters() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    ALOGV(<span class="string">"getParameters"</span>);</span><br><span class="line">    String8 params;</span><br><span class="line">    sp &lt;::android::hardware::ICamera&gt; c = mCamera;</span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) params = mCamera-&gt;getParameters();</span><br><span class="line">    <span class="keyword">return</span> params;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再到ICamera:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// get preview/capture parameters - key/value pairs</span></span><br><span class="line"><span class="function">String8 <span class="title">getParameters</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ALOGV(<span class="string">"getParameters"</span>);</span><br><span class="line">    Parcel data, reply;</span><br><span class="line">    data.writeInterfaceToken(ICamera::getInterfaceDescriptor());</span><br><span class="line">    remote()-&gt;transact(GET_PARAMETERS, data, &amp;reply);</span><br><span class="line">    <span class="keyword">return</span> reply.readString8();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过Binder机制到CameraClient:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> CameraClient::setParameters(<span class="keyword">const</span> String8&amp; params) &#123;</span><br><span class="line">    LOG1(<span class="string">"setParameters (pid %d) (%s)"</span>, getCallingPid(), params.<span class="built_in">string</span>());</span><br><span class="line"></span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">lock</span><span class="params">(mLock)</span></span>;</span><br><span class="line">    <span class="keyword">status_t</span> result = checkPidAndHardware();</span><br><span class="line">    <span class="keyword">if</span> (result != NO_ERROR) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    mLatestSetParameters = CameraParameters(params);</span><br><span class="line">    <span class="function">CameraParameters <span class="title">p</span><span class="params">(params)</span></span>;</span><br><span class="line">    <span class="comment">// MIUI MOD:</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* mute = p.get(CameraParameters::KEY_CAMERA_SERVICE_MUTE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mute != <span class="literal">NULL</span> &amp;&amp; <span class="built_in">strcmp</span>(mute, CameraParameters::TRUE) == <span class="number">0</span>) &#123;</span><br><span class="line">        sCameraService-&gt;setMuteState(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mHardware-&gt;setParameters(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>整个流程和前一篇的完全一致,熟悉整体过程中间步骤就不一一介绍了,看到这里之后我们就可以到hal层找对应的实现了.</p><h2 id="hal层实现"><a href="#hal层实现" class="headerlink" title="hal层实现"></a>hal层实现</h2><p>找到QCamera2HardwareInterface的set_parameters方法:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*===========================================================================</span></span><br><span class="line"><span class="comment"> * FUNCTION   : set_parameters</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * DESCRIPTION: set camera parameters</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * PARAMETERS :</span></span><br><span class="line"><span class="comment"> *   @device  : ptr to camera device struct</span></span><br><span class="line"><span class="comment"> *   @parms   : string of packed parameters</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * RETURN     : int32_t type of status</span></span><br><span class="line"><span class="comment"> *              NO_ERROR  -- success</span></span><br><span class="line"><span class="comment"> *              none-zero failure code</span></span><br><span class="line"><span class="comment"> *==========================================================================*/</span></span><br><span class="line"><span class="keyword">int</span> QCamera2HardwareInterface::set_parameters(struct camera_device *device,</span><br><span class="line">                                              <span class="keyword">const</span> <span class="keyword">char</span> *parms)</span><br><span class="line">&#123;</span><br><span class="line">    ATRACE_CAMSCOPE_CALL(CAMSCOPE_HAL1_SET_PARAMETERS);</span><br><span class="line">    <span class="keyword">int</span> ret = NO_ERROR;</span><br><span class="line">    QCamera2HardwareInterface *hw =</span><br><span class="line">        <span class="keyword">reinterpret_cast</span>&lt;QCamera2HardwareInterface *&gt;(device-&gt;priv);</span><br><span class="line">    <span class="keyword">if</span> (!hw) &#123;</span><br><span class="line">        LOGE(<span class="string">"NULL camera device"</span>);</span><br><span class="line">        <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    LOGI(<span class="string">"E camera id %d"</span>, hw-&gt;getCameraId());</span><br><span class="line">    hw-&gt;lockAPI();</span><br><span class="line">    <span class="keyword">qcamera_api_result_t</span> apiResult;</span><br><span class="line">    ret = hw-&gt;processAPI(QCAMERA_SM_EVT_SET_PARAMS, (<span class="keyword">void</span> *)parms);</span><br><span class="line">    <span class="keyword">if</span> (ret == NO_ERROR) &#123;</span><br><span class="line">        hw-&gt;waitAPIResult(QCAMERA_SM_EVT_SET_PARAMS, &amp;apiResult);</span><br><span class="line">        ret = apiResult.status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Give HWI control to restart (if necessary) after set params</span></span><br><span class="line">    <span class="comment">// in single camera mode. In dual-cam mode, this control belongs to muxer.</span></span><br><span class="line">    <span class="keyword">if</span> (hw-&gt;getRelatedCamSyncInfo()-&gt;sync_control != CAM_SYNC_RELATED_SENSORS_ON) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((ret == NO_ERROR) &amp;&amp; hw-&gt;getNeedRestart()) &#123;</span><br><span class="line">            LOGD(<span class="string">"stopping after param change"</span>);</span><br><span class="line">            ret = hw-&gt;processAPI(QCAMERA_SM_EVT_SET_PARAMS_STOP, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">if</span> (ret == NO_ERROR) &#123;</span><br><span class="line">                hw-&gt;waitAPIResult(QCAMERA_SM_EVT_SET_PARAMS_STOP, &amp;apiResult);</span><br><span class="line">                ret = apiResult.status;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ret == NO_ERROR) &#123;</span><br><span class="line">            LOGD(<span class="string">"committing param change"</span>);</span><br><span class="line">            ret = hw-&gt;processAPI(QCAMERA_SM_EVT_SET_PARAMS_COMMIT, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">if</span> (ret == NO_ERROR) &#123;</span><br><span class="line">                hw-&gt;waitAPIResult(QCAMERA_SM_EVT_SET_PARAMS_COMMIT, &amp;apiResult);</span><br><span class="line">                ret = apiResult.status;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((ret == NO_ERROR) &amp;&amp; hw-&gt;getNeedRestart()) &#123;</span><br><span class="line">            LOGD(<span class="string">"restarting after param change"</span>);</span><br><span class="line">            ret = hw-&gt;processAPI(QCAMERA_SM_EVT_SET_PARAMS_RESTART, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">if</span> (ret == NO_ERROR) &#123;</span><br><span class="line">                hw-&gt;waitAPIResult(QCAMERA_SM_EVT_SET_PARAMS_RESTART, &amp;apiResult);</span><br><span class="line">                ret = apiResult.status;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hw-&gt;unlockAPI();</span><br><span class="line">    LOGI(<span class="string">"X camera id %d ret %d"</span>, hw-&gt;getCameraId(), ret);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后到QCameraStateMachine状态机:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> QCAMERA_SM_EVT_SET_PARAMS:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> needRestart = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        rc = m_parent-&gt;waitDeferredWork(m_parent-&gt;mParamInitJob);</span><br><span class="line">        <span class="keyword">if</span> (NO_ERROR != rc) &#123;</span><br><span class="line">            LOGE(<span class="string">"Param init deferred work failed"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            rc = m_parent-&gt;updateParameters((<span class="keyword">char</span>*)payload, needRestart);</span><br><span class="line">        &#125;</span><br><span class="line">        result.status = rc;</span><br><span class="line">        result.request_api = evt;</span><br><span class="line">        result.result_type = QCAMERA_API_RESULT_TYPE_DEF;</span><br><span class="line">        m_parent-&gt;signalAPIResult(&amp;result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure></p><p>根据状态又回到了QCamera2HardwareInterface的updateParameters方法:<br> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*===========================================================================</span></span><br><span class="line"><span class="comment"> * FUNCTION   : updateParameters</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * DESCRIPTION: update parameters</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * PARAMETERS :</span></span><br><span class="line"><span class="comment"> *   @parms       : input parameters string</span></span><br><span class="line"><span class="comment"> *   @needRestart : output, flag to indicate if preview restart is needed</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * RETURN     : int32_t type of status</span></span><br><span class="line"><span class="comment"> *              NO_ERROR  -- success</span></span><br><span class="line"><span class="comment"> *              none-zero failure code</span></span><br><span class="line"><span class="comment"> *==========================================================================*/</span></span><br><span class="line"><span class="keyword">int</span> QCamera2HardwareInterface::updateParameters(<span class="keyword">const</span> <span class="keyword">char</span> *parms, <span class="keyword">bool</span> &amp;needRestart)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> rc = NO_ERROR;</span><br><span class="line">    <span class="keyword">int</span> retParallel = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    String8 str = String8(parms);</span><br><span class="line">    rc =  mParameters.updateParameters(str, needRestart);</span><br><span class="line">    setNeedRestart(needRestart);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// update stream based parameter settings</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; QCAMERA_CH_TYPE_MAX; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_channels[i] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            m_channels[i]-&gt;UpdateStreamBasedParameters(mParameters);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mHalInf-&gt;onSetParameters(mParameters.setting1(),mParameters.setting2()...);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>updateParameters会更新所有参数,首先更新基础参数,然后可以通过mHalInf更新一些自定义的参数,这部分代码省略了.<br>定制相机开发时可以增加Parameters中的key,做自定义开关配置参数传递等.</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>参数传递和第一篇setPreview走的流程都差不多,熟悉后整体流程更清楚了,具体到代码阅读是只需要找Parameters对应的key,就可以找到关键方法了,系统代码的阅读也不复杂.<br>知道了app到hal的数据传递,那hal如何把数据传递给app层呢?我们下一篇分析hal到app的数据传递.</p>]]></content>
    
    <summary type="html">
    
      相机流程深入解析:app到hal数据传递
    
    </summary>
    
    
      <category term="Android" scheme="http://anddymao.com/tags/Android/"/>
    
      <category term="Camera" scheme="http://anddymao.com/tags/Camera/"/>
    
  </entry>
  
  <entry>
    <title>Android8.0相机源码深入解析(一)</title>
    <link href="http://anddymao.com/2018/05/04/2018-5-4-%E7%9B%B8%E6%9C%BA%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90(%E4%B8%80)/"/>
    <id>http://anddymao.com/2018/05/04/2018-5-4-相机源码深入解析(一)/</id>
    <published>2018-05-04T04:00:00.000Z</published>
    <updated>2019-10-25T03:38:48.885Z</updated>
    
    <content type="html"><![CDATA[<h1 id="相机整体架构"><a href="#相机整体架构" class="headerlink" title="相机整体架构"></a>相机整体架构</h1><p>相机api1的HAL接口被设计成了三种运行模式：预览,静态拍摄和视频录制.<br>预览对应于代码中 Camera 类的 startPreview 函数，而静态拍摄对应于Camera类的takePicture函数，视频录制则是在MediaRecorder类的setCamera函数中传入Camera对象实例。整体架构图如下所示:</p><p><img src="/img/post_camera_1.png" alt="Alt text"><br>根据架构图再深入源码研究调用流程,才能真正理解相机的架构.做相机开发的话主要有APP层开发和HAL层开发,HAL层由芯片厂商定制(比如高通等),手机厂商可以再其上增加一些内容.本文的分析基于android8.0源码,着重分析调用流程和层级数据传输,弄懂android架构.需要对binder机制,AIDL及HIDL有一定了解.</p><h1 id="Android相机调用流程解析"><a href="#Android相机调用流程解析" class="headerlink" title="Android相机调用流程解析"></a>Android相机调用流程解析</h1><p>相机api1最基础的方法是startPreview,我们根据startPreview的调用深入了解下api1的相机调用流程.</p><h2 id="从framework到jni"><a href="#从framework到jni" class="headerlink" title="从framework到jni"></a>从framework到jni</h2><p>  看下framework中android.hardware.Camera里面的对应方法,</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Starts capturing and drawing preview frames to the screen.</span></span><br><span class="line"><span class="comment">* Preview will not actually start until a surface is supplied</span></span><br><span class="line"><span class="comment">* with &#123;<span class="doctag">@link</span> #setPreviewDisplay(SurfaceHolder)&#125; or</span></span><br><span class="line"><span class="comment">* &#123;<span class="doctag">@link</span> #setPreviewTexture(SurfaceTexture)&#125;.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;p&gt;If &#123;<span class="doctag">@link</span> #setPreviewCallback(Camera.PreviewCallback)&#125;,</span></span><br><span class="line"><span class="comment">* &#123;<span class="doctag">@link</span> #setOneShotPreviewCallback(Camera.PreviewCallback)&#125;, or</span></span><br><span class="line"><span class="comment">* &#123;<span class="doctag">@link</span> #setPreviewCallbackWithBuffer(Camera.PreviewCallback)&#125; were</span></span><br><span class="line"><span class="comment">* called, &#123;<span class="doctag">@link</span> Camera.PreviewCallback#onPreviewFrame(byte[], Camera)&#125;</span></span><br><span class="line"><span class="comment">* will be called when preview data becomes available.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> RuntimeException if starting preview fails; usually this would be</span></span><br><span class="line"><span class="comment">*    because of a hardware or other low-level error, or because release()</span></span><br><span class="line"><span class="comment">*    has been called on this Camera instance.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">startPreview</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>讲到需要调用setPreviewDisplay或者setPreviewTexture方法,才能开始预览,如果setPreviewCallback就会在预览时回调.<br>jni方法在android_hardware_Camera.cpp中可以看到注册地方:</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> JNINativeMethod camMethods[] = &#123;</span><br><span class="line">  &#123; <span class="string">"_getNumberOfCameras"</span>,</span><br><span class="line">    <span class="string">"()I"</span>,</span><br><span class="line">    (<span class="keyword">void</span> *)android_hardware_Camera_getNumberOfCameras &#125;,</span><br><span class="line">  &#123; <span class="string">"_getCameraInfo"</span>,</span><br><span class="line">    <span class="string">"(ILandroid/hardware/Camera$CameraInfo;)V"</span>,</span><br><span class="line">    (<span class="keyword">void</span>*)android_hardware_Camera_getCameraInfo &#125;,</span><br><span class="line">  &#123; <span class="string">"native_setup"</span>,</span><br><span class="line">    <span class="string">"(Ljava/lang/Object;IILjava/lang/String;)I"</span>,</span><br><span class="line">    (<span class="keyword">void</span>*)android_hardware_Camera_native_setup &#125;,</span><br><span class="line">  &#123; <span class="string">"native_release"</span>,</span><br><span class="line">    <span class="string">"()V"</span>,</span><br><span class="line">    (<span class="keyword">void</span>*)android_hardware_Camera_release &#125;,</span><br><span class="line">  &#123; <span class="string">"setPreviewSurface"</span>,</span><br><span class="line">    <span class="string">"(Landroid/view/Surface;)V"</span>,</span><br><span class="line">    (<span class="keyword">void</span> *)android_hardware_Camera_setPreviewSurface &#125;,</span><br><span class="line">  &#123; <span class="string">"setPreviewTexture"</span>,</span><br><span class="line">    <span class="string">"(Landroid/graphics/SurfaceTexture;)V"</span>,</span><br><span class="line">    (<span class="keyword">void</span> *)android_hardware_Camera_setPreviewTexture &#125;,</span><br><span class="line">  &#123; <span class="string">"setPreviewCallbackSurface"</span>,</span><br><span class="line">    <span class="string">"(Landroid/view/Surface;)V"</span>,</span><br><span class="line">    (<span class="keyword">void</span> *)android_hardware_Camera_setPreviewCallbackSurface &#125;,</span><br><span class="line">  &#123; <span class="string">"startPreview"</span>,</span><br><span class="line">    <span class="string">"()V"</span>,</span><br><span class="line">    (<span class="keyword">void</span> *)android_hardware_Camera_startPreview &#125;,</span><br><span class="line">  &#123; <span class="string">"_stopPreview"</span>,</span><br><span class="line">    <span class="string">"()V"</span>,</span><br><span class="line">    (<span class="keyword">void</span> *)android_hardware_Camera_stopPreview &#125;,</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure><p>然后就找到对应jni方法:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_hardware_Camera_startPreview</span><span class="params">(JNIEnv *env, jobject thiz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     ALOGV(<span class="string">"startPreview"</span>);</span><br><span class="line">     sp&lt;Camera&gt; camera = get_native_camera(env, thiz, <span class="literal">NULL</span>);</span><br><span class="line">     <span class="keyword">if</span> (camera == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (camera-&gt;startPreview() != NO_ERROR) &#123;</span><br><span class="line">         jniThrowRuntimeException(env, <span class="string">"startPreview failed"</span>);</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> sp是强指针,获取到Camera对象,调用startPreview方法,另外我们再简单看下setPreviewCallbackSurface方法,</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_hardware_Camera_setPreviewCallbackSurface</span><span class="params">(JNIEnv *env,</span></span></span><br><span class="line"><span class="function"><span class="params">     jobject thiz, jobject jSurface)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     ALOGV(<span class="string">"setPreviewCallbackSurface"</span>);</span><br><span class="line">     JNICameraContext* context;</span><br><span class="line">     sp&lt;Camera&gt; camera = get_native_camera(env, thiz, &amp;context);</span><br><span class="line">     <span class="keyword">if</span> (camera == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">     sp&lt;IGraphicBufferProducer&gt; gbp;</span><br><span class="line">     sp&lt;Surface&gt; surface;</span><br><span class="line">     <span class="keyword">if</span> (jSurface) &#123;</span><br><span class="line">         surface = android_view_Surface_getSurface(env, jSurface);</span><br><span class="line">         <span class="keyword">if</span> (surface != <span class="literal">NULL</span>) &#123;</span><br><span class="line">             gbp = surface-&gt;getIGraphicBufferProducer();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// Clear out normal preview callbacks</span></span><br><span class="line">     context-&gt;setCallbackMode(env, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">     <span class="comment">// Then set up callback surface</span></span><br><span class="line">     <span class="keyword">if</span> (camera-&gt;setPreviewCallbackTarget(gbp) != NO_ERROR) &#123;</span><br><span class="line">         jniThrowException(env, <span class="string">"java/io/IOException"</span>, <span class="string">"setPreviewCallbackTarget failed"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这两个方法都是在android_hardware_Camera.cpp中的静态方法,android_hardware_Camera中还定义了JNICameraContext,用于JNI层调用转换.<br> JNICameraContext及JNI相机上下文,获取Camera同时获取到.这一步就完成android.hardware.camera到JNICameraContext调用逻辑了.<br> get_native_camera是获取native层相机,接下来继续探究底层代码.</p><h2 id="相机native-library"><a href="#相机native-library" class="headerlink" title="相机native library"></a>相机native library</h2><p>这一步我们调用到了相机client,代码在/frameworks/av/camera里,另外还会调用到相机service,代码在/frameworks/av/services/camera/libcameraservice里,先看Camera.cpp的代码.<br>Camera.cpp中startPreview方法,转调到ICamera中了:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// start preview mode</span></span><br><span class="line"><span class="keyword">status_t</span> Camera::startPreview()</span><br><span class="line">&#123;</span><br><span class="line">    ALOGV(<span class="string">"startPreview"</span>);</span><br><span class="line">    sp &lt;::android::hardware::ICamera&gt; c = mCamera;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) <span class="keyword">return</span> NO_INIT;</span><br><span class="line">    <span class="keyword">return</span> c-&gt;startPreview();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>startPreview方法在ICamera.h中的定义,CameraClient和CameraService都要使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// start preview mode, must call setPreviewTarget first</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> status_t        <span class="title">startPreview</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>在ICamera.cpp找到startPreview的实现:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BpCamera</span>:</span> <span class="keyword">public</span> BpInterface&lt;ICamera&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">BpCamera</span><span class="params">(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; impl)</span></span></span><br><span class="line">            : BpInterface&lt;ICamera&gt;(impl)</span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">         <span class="comment">// start preview mode, must call setPreviewTarget first</span></span><br><span class="line">         <span class="keyword">status_t</span> startPreview()</span><br><span class="line">         &#123;</span><br><span class="line">             ALOGV(<span class="string">"startPreview"</span>);</span><br><span class="line">             Parcel data, reply;</span><br><span class="line">             data.writeInterfaceToken(ICamera::getInterfaceDescriptor());</span><br><span class="line">             remote()-&gt;transact(START_PREVIEW, data, &amp;reply);</span><br><span class="line">             <span class="keyword">return</span> reply.readInt32();</span><br><span class="line">         &#125;</span><br><span class="line">     ...</span><br></pre></td></tr></table></figure><p>  BpCamera是相机BpBinder,就是Binder代理,通过remote()-&gt;transact(),这时会在服务进程中调用对应的BnCamera对象的onTransact()方法,根据对应的code(START_PREVIEW),这样就执行了服务端的startPreview方法,具体可详细了解android binder机制.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> START_PREVIEW: &#123;</span><br><span class="line">    ALOGV(<span class="string">"START_PREVIEW"</span>);</span><br><span class="line">    CHECK_INTERFACE(ICamera, data, reply);</span><br><span class="line">    reply-&gt;writeInt32(startPreview());</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125; <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>在CameraService.h中找到了BnCamera的方法定义,属于libcameraservice模块</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> :</span> <span class="keyword">public</span> hardware::BnCamera, <span class="keyword">public</span> BasicClient</span><br><span class="line">   &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">       <span class="keyword">typedef</span> hardware::ICameraClient TCamCallbacks;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// ICamera interface (see ICamera for details)</span></span><br><span class="line">       <span class="keyword">virtual</span> binder::<span class="function">Status <span class="title">disconnect</span><span class="params">()</span></span>;</span><br><span class="line">       <span class="function"><span class="keyword">virtual</span> status_t      <span class="title">connect</span><span class="params">(<span class="keyword">const</span> sp&lt;hardware::ICameraClient&gt;&amp; client)</span> </span>= <span class="number">0</span>;</span><br><span class="line">       <span class="function"><span class="keyword">virtual</span> status_t      <span class="title">lock</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">       <span class="function"><span class="keyword">virtual</span> status_t      <span class="title">unlock</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">       <span class="function"><span class="keyword">virtual</span> status_t      <span class="title">setPreviewTarget</span><span class="params">(<span class="keyword">const</span> sp&lt;IGraphicBufferProducer&gt;&amp; bufferProducer)</span></span>=<span class="number">0</span>;</span><br><span class="line">       <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span>          <span class="title">setPreviewCallbackFlag</span><span class="params">(<span class="keyword">int</span> flag)</span> </span>= <span class="number">0</span>;</span><br><span class="line">       <span class="function"><span class="keyword">virtual</span> status_t      <span class="title">setPreviewCallbackTarget</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">const</span> sp&lt;IGraphicBufferProducer&gt;&amp; callbackProducer)</span> </span>= <span class="number">0</span>;</span><br><span class="line">       <span class="function"><span class="keyword">virtual</span> status_t      <span class="title">startPreview</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">       ...</span><br></pre></td></tr></table></figure><p>CameraService::Client有API1和API2两种实现,转而定义在CameraClient.h中:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Interface between android.hardware.Camera API and Camera HAL device for version</span></span><br><span class="line"><span class="comment"> * CAMERA_DEVICE_API_VERSION_1_0.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CameraClient</span> :</span> <span class="keyword">public</span> CameraService::Client</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ICamera interface (see ICamera for details)</span></span><br><span class="line">    <span class="keyword">virtual</span> binder::<span class="function">Status  <span class="title">disconnect</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t        <span class="title">connect</span><span class="params">(<span class="keyword">const</span> sp&lt;hardware::ICameraClient&gt;&amp; client)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t        <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t        <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t        <span class="title">setPreviewTarget</span><span class="params">(<span class="keyword">const</span> sp&lt;IGraphicBufferProducer&gt;&amp; bufferProducer)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span>            <span class="title">setPreviewCallbackFlag</span><span class="params">(<span class="keyword">int</span> flag)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t        <span class="title">setPreviewCallbackTarget</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">const</span> sp&lt;IGraphicBufferProducer&gt;&amp; callbackProducer)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t        <span class="title">startPreview</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>在CameraServece.cpp找到实现方法:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// start preview mode</span></span><br><span class="line"><span class="keyword">status_t</span> CameraClient::startPreview() &#123;</span><br><span class="line">    LOG1(<span class="string">"startPreview (pid %d)"</span>, getCallingPid());</span><br><span class="line">    <span class="keyword">return</span> startCameraMode(CAMERA_PREVIEW_MODE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// start recording mode</span></span><br><span class="line"><span class="keyword">status_t</span> CameraClient::startRecording() &#123;</span><br><span class="line">    LOG1(<span class="string">"startRecording (pid %d)"</span>, getCallingPid());</span><br><span class="line">    <span class="keyword">return</span> startCameraMode(CAMERA_RECORDING_MODE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// start preview or recording</span></span><br><span class="line"><span class="keyword">status_t</span> CameraClient::startCameraMode(camera_mode mode) &#123;</span><br><span class="line">    LOG1(<span class="string">"startCameraMode(%d)"</span>, mode);</span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">lock</span><span class="params">(mLock)</span></span>;</span><br><span class="line">    <span class="keyword">status_t</span> result = checkPidAndHardware();</span><br><span class="line">    <span class="keyword">if</span> (result != NO_ERROR) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(mode) &#123;</span><br><span class="line">        <span class="keyword">case</span> CAMERA_PREVIEW_MODE:</span><br><span class="line">            <span class="keyword">if</span> (mSurface == <span class="number">0</span> &amp;&amp; mPreviewWindow == <span class="number">0</span>) &#123;</span><br><span class="line">                LOG1(<span class="string">"mSurface is not set yet."</span>);</span><br><span class="line">                <span class="comment">// still able to start preview in this case.</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> startPreviewMode();</span><br><span class="line">        <span class="keyword">case</span> CAMERA_RECORDING_MODE:</span><br><span class="line">            <span class="keyword">if</span> (mSurface == <span class="number">0</span> &amp;&amp; mPreviewWindow == <span class="number">0</span>) &#123;</span><br><span class="line">                ALOGE(<span class="string">"mSurface or mPreviewWindow must be set before startRecordingMode."</span>);</span><br><span class="line">                <span class="keyword">return</span> INVALID_OPERATION;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> startRecordingMode();</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> UNKNOWN_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">status_t</span> CameraClient::startPreviewMode() &#123;</span><br><span class="line">    LOG1(<span class="string">"startPreviewMode"</span>);</span><br><span class="line">    <span class="keyword">status_t</span> result = NO_ERROR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if preview has been enabled, nothing needs to be done</span></span><br><span class="line">    <span class="keyword">if</span> (mHardware-&gt;previewEnabled()) &#123;</span><br><span class="line">        <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mPreviewWindow != <span class="number">0</span>) &#123;</span><br><span class="line">        mHardware-&gt;setPreviewScalingMode(</span><br><span class="line">            NATIVE_WINDOW_SCALING_MODE_SCALE_TO_WINDOW);</span><br><span class="line">        mHardware-&gt;setPreviewTransform(mOrientation);</span><br><span class="line">    &#125;</span><br><span class="line">    mHardware-&gt;setPreviewWindow(mPreviewWindow);</span><br><span class="line">    result = mHardware-&gt;startPreview();</span><br><span class="line">    <span class="keyword">if</span> (result == NO_ERROR) &#123;</span><br><span class="line">        sCameraService-&gt;updateProxyDeviceState(</span><br><span class="line">            hardware::ICameraServiceProxy::CAMERA_STATE_ACTIVE,</span><br><span class="line">            mCameraIdStr, mCameraFacing, mClientPackageName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分preview模式和录像模式,我们只看preview模式,这里看到mHardware,是一个CameraHardwareInterface对象,终于要进入hal层了,调用了setPreviewWindow,然后startPreview,再使用CameraService对象sCameraService更新代理设备状态.</p><p>总结下本部分调用,从相机client到相机service,从Camera.cpp的方法实际调用了ICamera.cpp,ICamera实现了BpCamera,最后调用到了BnCamera,BnCamera回调写在ICamera.cpp中,但实际是由远程service调用的,这时是生成了服务端的一个代理.CameraService::Client实现了BnCamera,Client又有API1和API2两种实现,<br>最后的方法调入CameraClient中.</p><h2 id="从native到hal"><a href="#从native到hal" class="headerlink" title="从native到hal"></a>从native到hal</h2><p>CameraHardwareInterface承担了native到hal层的转换,代码在libcameraservice模块的device1包里,hidl定义在hardware/interface/camera里,继续研究如何调用到hal层的.直接看CameraHardwareInterface.cpp中的方法实现:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> CameraHardwareInterface::startPreview()</span><br><span class="line">&#123;</span><br><span class="line">    ALOGV(<span class="string">"%s(%s)"</span>, __FUNCTION__, mName.<span class="built_in">string</span>());</span><br><span class="line">    <span class="keyword">if</span> (CC_LIKELY(mHidlDevice != <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> CameraProviderManager::mapToStatusT(</span><br><span class="line">                mHidlDevice-&gt;startPreview());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> INVALID_OPERATION;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>mapToStatusT是公共方法,做了一个状态转换,CameraProviderManager在libcameraservice模块的common包里,我们主要看mHidlDevice,CameraHardwareInterface.h中看到mHidlDevice的定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;hardware::camera::device::V1_0::ICameraDevice&gt; mHidlDevice;</span><br></pre></td></tr></table></figure><p>hidl是硬件抽象层接口定义语言,以hidlDevice作为代理调用hal层方法,在hardware/interface/camera/device/1.0/ICameraDevice.hal中可以看到对象的方法定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Start preview mode.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return status The status code for this operation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">startPreview() generates (Status status);</span><br></pre></td></tr></table></figure><p>在CameraDevice.cpp中找到方法实现:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Return&lt;Status&gt; CameraDevice::startPreview() &#123;</span><br><span class="line">    ALOGV(<span class="string">"%s(%s)"</span>, __FUNCTION__, mCameraId.c_str());</span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line">    <span class="keyword">if</span> (!mDevice) &#123;</span><br><span class="line">        ALOGE(<span class="string">"%s called while camera is not opened"</span>, __FUNCTION__);</span><br><span class="line">        <span class="keyword">return</span> Status::OPERATION_NOT_SUPPORTED;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mDevice-&gt;ops-&gt;start_preview) &#123;</span><br><span class="line">        <span class="keyword">return</span> getHidlStatus(mDevice-&gt;ops-&gt;start_preview(mDevice));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Status::INTERNAL_ERROR; <span class="comment">// HAL should provide start_preview</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> mDevice是camera_device_t对象,定义在hardware/libhardware/include/hardware/camera.h中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">camera_device</span> &#123;</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * camera_device.common.version must be in the range</span></span><br><span class="line"><span class="comment">     * HARDWARE_DEVICE_API_VERSION(0,0)-(1,FF). CAMERA_DEVICE_API_VERSION_1_0 is</span></span><br><span class="line"><span class="comment">     * recommended.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">hw_device_t</span> common;</span><br><span class="line">    <span class="keyword">camera_device_ops_t</span> *ops;</span><br><span class="line">    <span class="keyword">void</span> *priv;</span><br><span class="line">&#125; <span class="keyword">camera_device_t</span>;</span><br></pre></td></tr></table></figure><p> camera_device_ops也在hardware/libhardware/include/hardware/camera.h中,定义了start_preview等hal层方法:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">camera_device_ops</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Start preview mode.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> (*start_preview)(struct camera_device *);</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>从CameraHardwareInterface通过camera_device调用到hal层的方法,hal层的方法定义在camera_device_ops_t里,接下来看hal层方法的实现.</p><h2 id="HAL层实现"><a href="#HAL层实现" class="headerlink" title="HAL层实现"></a>HAL层实现</h2><p>  终于进入了hal层,这里用的是高通相机框架,QCamera2HardwareInterface即高通对硬件接口的实现,2是to,在QCamera2HardwareInterface中可以看到对应的hal方法的对应关系:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">camera_device_ops_t</span> QCamera2HardwareInterface::mCameraOps = &#123;</span><br><span class="line">    .set_preview_window =        QCamera2HardwareInterface::set_preview_window,</span><br><span class="line">    .set_callbacks =             QCamera2HardwareInterface::set_CallBacks,</span><br><span class="line">    .enable_msg_type =           QCamera2HardwareInterface::enable_msg_type,</span><br><span class="line">    .disable_msg_type =          QCamera2HardwareInterface::disable_msg_type,</span><br><span class="line">    .msg_type_enabled =          QCamera2HardwareInterface::msg_type_enabled,</span><br><span class="line"></span><br><span class="line">    .start_preview =             QCamera2HardwareInterface::start_preview,</span><br><span class="line">    .stop_preview =              QCamera2HardwareInterface::stop_preview,</span><br><span class="line">    .preview_enabled =           QCamera2HardwareInterface::preview_enabled,</span><br><span class="line">    .store_meta_data_in_buffers= QCamera2HardwareInterface::store_meta_data_in_buffers,</span><br><span class="line"></span><br><span class="line">    .start_recording =           QCamera2HardwareInterface::start_recording,</span><br><span class="line">    .stop_recording =            QCamera2HardwareInterface::stop_recording,</span><br><span class="line">    .recording_enabled =         QCamera2HardwareInterface::recording_enabled,</span><br><span class="line">    .release_recording_frame =   QCamera2HardwareInterface::release_recording_frame,</span><br><span class="line"></span><br><span class="line">    .auto_focus =                QCamera2HardwareInterface::auto_focus,</span><br><span class="line">    .cancel_auto_focus =         QCamera2HardwareInterface::cancel_auto_focus,</span><br><span class="line"></span><br><span class="line">    .take_picture =              QCamera2HardwareInterface::take_picture,</span><br><span class="line">    .cancel_picture =            QCamera2HardwareInterface::cancel_picture,</span><br><span class="line"></span><br><span class="line">    .set_parameters =            QCamera2HardwareInterface::set_parameters,</span><br><span class="line">    .get_parameters =            QCamera2HardwareInterface::get_parameters,</span><br><span class="line">    .put_parameters =            QCamera2HardwareInterface::put_parameters,</span><br><span class="line">    .send_command =              QCamera2HardwareInterface::send_command,</span><br><span class="line"></span><br><span class="line">    .release =                   QCamera2HardwareInterface::release,</span><br><span class="line">    .dump =                      QCamera2HardwareInterface::dump,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>继续看start_preview方法:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*===========================================================================</span></span><br><span class="line"><span class="comment"> * FUNCTION   : start_preview</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * DESCRIPTION: start preview</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * PARAMETERS :</span></span><br><span class="line"><span class="comment"> *   @device  : ptr to camera device struct</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * RETURN     : int32_t type of status</span></span><br><span class="line"><span class="comment"> *              NO_ERROR  -- success</span></span><br><span class="line"><span class="comment"> *              none-zero failure code</span></span><br><span class="line"><span class="comment"> *==========================================================================*/</span></span><br><span class="line"><span class="keyword">int</span> QCamera2HardwareInterface::start_preview(struct camera_device *device)</span><br><span class="line">&#123;</span><br><span class="line">    KPI_ATRACE_CAMSCOPE_CALL(CAMSCOPE_HAL1_START_PREVIEW);</span><br><span class="line">    <span class="keyword">int</span> ret = NO_ERROR;</span><br><span class="line">    QCamera2HardwareInterface *hw =</span><br><span class="line">        <span class="keyword">reinterpret_cast</span>&lt;QCamera2HardwareInterface *&gt;(device-&gt;priv);</span><br><span class="line">    <span class="keyword">if</span> (!hw) &#123;</span><br><span class="line">        LOGE(<span class="string">"NULL camera device"</span>);</span><br><span class="line">        <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    LOGI(<span class="string">"[KPI Perf]: E PROFILE_START_PREVIEW camera id %d"</span>,</span><br><span class="line">             hw-&gt;getCameraId());</span><br><span class="line"></span><br><span class="line">    hw-&gt;m_perfLockMgr.acquirePerfLockIfExpired(PERF_LOCK_START_PREVIEW);</span><br><span class="line">    hw-&gt;lockAPI();</span><br><span class="line">    <span class="keyword">qcamera_api_result_t</span> apiResult;</span><br><span class="line">    <span class="keyword">qcamera_sm_evt_enum_t</span> evt = QCAMERA_SM_EVT_START_PREVIEW;</span><br><span class="line">    <span class="keyword">uint32_t</span> cam_type = CAM_TYPE_MAIN;</span><br><span class="line">    <span class="keyword">if</span> (hw-&gt;isDualCamera()) &#123;</span><br><span class="line">        cam_type = MM_CAMERA_DUAL_CAM;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hw-&gt;isNoDisplayMode(cam_type)) &#123;</span><br><span class="line">        evt = QCAMERA_SM_EVT_START_NODISPLAY_PREVIEW;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = hw-&gt;processAPI(evt, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == NO_ERROR) &#123;</span><br><span class="line">        hw-&gt;waitAPIResult(evt, &amp;apiResult);</span><br><span class="line">        ret = apiResult.status;</span><br><span class="line">    &#125;</span><br><span class="line">    hw-&gt;unlockAPI();</span><br><span class="line">    LOGI(<span class="string">"[KPI Perf]: X ret = %d"</span>, ret);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用qcamera_sm_evt_enum_t是一个枚举,用hw-&gt;processAPI处理,结果给apiResult,看processAPI方法:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*===========================================================================</span></span><br><span class="line"><span class="comment"> * FUNCTION   : processAPI</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * DESCRIPTION: process API calls from upper layer</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * PARAMETERS :</span></span><br><span class="line"><span class="comment"> *   @api         : API to be processed</span></span><br><span class="line"><span class="comment"> *   @api_payload : ptr to API payload if any</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * RETURN     : int32_t type of status</span></span><br><span class="line"><span class="comment"> *              NO_ERROR  -- success</span></span><br><span class="line"><span class="comment"> *              none-zero failure code</span></span><br><span class="line"><span class="comment"> *==========================================================================*/</span></span><br><span class="line"><span class="keyword">int</span> QCamera2HardwareInterface::processAPI(<span class="keyword">qcamera_sm_evt_enum_t</span> api, <span class="keyword">void</span> *api_payload)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = DEAD_OBJECT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m_smThreadActive) &#123;</span><br><span class="line">        ret = m_stateMachine.procAPI(api, api_payload);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转调给了m_stateMachine,含义是状态机,是一个QCameraStateMachine对象,继续看实现:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*===========================================================================</span></span><br><span class="line"><span class="comment"> * FUNCTION   : procAPI</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * DESCRIPTION: process incoming API request from framework layer.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * PARAMETERS :</span></span><br><span class="line"><span class="comment"> *   @evt          : event to be processed</span></span><br><span class="line"><span class="comment"> *   @api_payload  : API payload. Can be NULL if not needed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * RETURN     : int32_t type of status</span></span><br><span class="line"><span class="comment"> *              NO_ERROR  -- success</span></span><br><span class="line"><span class="comment"> *              none-zero failure code</span></span><br><span class="line"><span class="comment"> *==========================================================================*/</span></span><br><span class="line"><span class="keyword">int32_t</span> QCameraStateMachine::procAPI(<span class="keyword">qcamera_sm_evt_enum_t</span> evt,</span><br><span class="line">                                     <span class="keyword">void</span> *api_payload)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">qcamera_sm_cmd_t</span> *node =</span><br><span class="line">        (<span class="keyword">qcamera_sm_cmd_t</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">qcamera_sm_cmd_t</span>));</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == node) &#123;</span><br><span class="line">        LOGE(<span class="string">"No memory for qcamera_sm_cmd_t"</span>);</span><br><span class="line">        <span class="keyword">return</span> NO_MEMORY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(node, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">qcamera_sm_cmd_t</span>));</span><br><span class="line">    node-&gt;cmd = QCAMERA_SM_CMD_TYPE_API;</span><br><span class="line">    node-&gt;evt = evt;</span><br><span class="line">    node-&gt;evt_payload = api_payload;</span><br><span class="line">    <span class="keyword">if</span> (api_queue.enqueue((<span class="keyword">void</span> *)node)) &#123;</span><br><span class="line">        cam_sem_post(&amp;cmd_sem);</span><br><span class="line">        <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        LOGE(<span class="string">"API enqueue failed API = %d"</span>, evt);</span><br><span class="line">        <span class="built_in">free</span>(node);</span><br><span class="line">        <span class="keyword">return</span> UNKNOWN_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一个api_queue队列处理api请求,找到队列处理过程:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*===========================================================================</span></span><br><span class="line"><span class="comment"> * FUNCTION   : smEvtProcRoutine</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * DESCRIPTION: Statemachine process thread routine to handle events</span></span><br><span class="line"><span class="comment"> *              in different state.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * PARAMETERS :</span></span><br><span class="line"><span class="comment"> *   @data    : ptr to QCameraStateMachine object</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * RETURN     : none</span></span><br><span class="line"><span class="comment"> *==========================================================================*/</span></span><br><span class="line"><span class="keyword">void</span> *QCameraStateMachine::smEvtProcRoutine(<span class="keyword">void</span> *data)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> running = <span class="number">1</span>, ret;</span><br><span class="line">    QCameraStateMachine *pme = (QCameraStateMachine *)data;</span><br><span class="line"></span><br><span class="line">    LOGH(<span class="string">"E"</span>);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            ret = cam_sem_wait(&amp;pme-&gt;cmd_sem);</span><br><span class="line">            <span class="keyword">if</span> (ret != <span class="number">0</span> &amp;&amp; errno != EINVAL) &#123;</span><br><span class="line">                LOGE(<span class="string">"cam_sem_wait error (%s)"</span>,</span><br><span class="line">                            strerror(errno));</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (ret != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// we got notified about new cmd avail in cmd queue</span></span><br><span class="line">        <span class="comment">// first check API cmd queue</span></span><br><span class="line">        <span class="keyword">qcamera_sm_cmd_t</span> *node = (<span class="keyword">qcamera_sm_cmd_t</span> *)pme-&gt;api_queue.dequeue();</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// no API cmd, then check evt cmd queue</span></span><br><span class="line">            node = (<span class="keyword">qcamera_sm_cmd_t</span> *)pme-&gt;evt_queue.dequeue();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (node-&gt;cmd) &#123;</span><br><span class="line">            <span class="keyword">case</span> QCAMERA_SM_CMD_TYPE_API:</span><br><span class="line">                pme-&gt;stateMachine(node-&gt;evt, node-&gt;evt_payload);</span><br><span class="line">                <span class="comment">// API is in a way sync call, so evt_payload is managed by HWI</span></span><br><span class="line">                <span class="comment">// no need to free payload for API</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> QCAMERA_SM_CMD_TYPE_EVT:</span><br><span class="line">                pme-&gt;stateMachine(node-&gt;evt, node-&gt;evt_payload);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// EVT is async call, so payload need to be free after use</span></span><br><span class="line">                <span class="built_in">free</span>(node-&gt;evt_payload);</span><br><span class="line">                node-&gt;evt_payload = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> QCAMERA_SM_CMD_TYPE_EXIT:</span><br><span class="line">                running = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">free</span>(node);</span><br><span class="line">            node = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (running);</span><br><span class="line">    LOGH(<span class="string">"X"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大概明白smEvtProcRoutine是一个周期性方法,在其中处理各种类型的命令,注释很清楚,QCAMERA_SM_CMD_TYPE_API是由HWI调用的,不需要自己清理返回数据,QCAMERA_SM_CMD_TYPE_EVT是异步调用的,用于其它事件(例如人脸返回等数据),需要清理返回数据,QCAMERA_SM_CMD_TYPE_EXIT是退出.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*===========================================================================</span></span><br><span class="line"><span class="comment"> * FUNCTION   : stateMachine</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * DESCRIPTION: finite state machine entry function. Depends on state,</span></span><br><span class="line"><span class="comment"> *              incoming event will be handled differently.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * PARAMETERS :</span></span><br><span class="line"><span class="comment"> *   @evt      : event to be processed</span></span><br><span class="line"><span class="comment"> *   @payload  : event payload. Can be NULL if not needed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * RETURN     : int32_t type of status</span></span><br><span class="line"><span class="comment"> *              NO_ERROR  -- success</span></span><br><span class="line"><span class="comment"> *              none-zero failure code</span></span><br><span class="line"><span class="comment"> *==========================================================================*/</span></span><br><span class="line"><span class="keyword">int32_t</span> QCameraStateMachine::stateMachine(<span class="keyword">qcamera_sm_evt_enum_t</span> evt, <span class="keyword">void</span> *payload)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> rc = NO_ERROR;</span><br><span class="line">    LOGL(<span class="string">"m_state %d, event (%d)"</span>, m_state, evt);</span><br><span class="line">    <span class="keyword">switch</span> (m_state) &#123;</span><br><span class="line">    <span class="keyword">case</span> QCAMERA_SM_STATE_PREVIEW_STOPPED:</span><br><span class="line">        rc = procEvtPreviewStoppedState(evt, payload);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> QCAMERA_SM_STATE_PREVIEW_READY:</span><br><span class="line">        rc = procEvtPreviewReadyState(evt, payload);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> QCAMERA_SM_STATE_PREVIEWING:</span><br><span class="line">        rc = procEvtPreviewingState(evt, payload);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> QCAMERA_SM_STATE_PREPARE_SNAPSHOT:</span><br><span class="line">        rc = procEvtPrepareSnapshotState(evt, payload);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> QCAMERA_SM_STATE_PIC_TAKING:</span><br><span class="line">        rc = procEvtPicTakingState(evt, payload);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> QCAMERA_SM_STATE_RECORDING:</span><br><span class="line">        rc = procEvtRecordingState(evt, payload);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> QCAMERA_SM_STATE_VIDEO_PIC_TAKING:</span><br><span class="line">        rc = procEvtVideoPicTakingState(evt, payload);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> QCAMERA_SM_STATE_PREVIEW_PIC_TAKING:</span><br><span class="line">        rc = procEvtPreviewPicTakingState(evt, payload);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在不同状态下对应的处理,如果在preview状态:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int32_t</span> QCameraStateMachine::procEvtPreviewingState(<span class="keyword">qcamera_sm_evt_enum_t</span> evt,</span><br><span class="line">                                                    <span class="keyword">void</span> *payload)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> rc = NO_ERROR;</span><br><span class="line">    <span class="keyword">qcamera_api_result_t</span> result;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;result, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">qcamera_api_result_t</span>));</span><br><span class="line"></span><br><span class="line">    LOGL(<span class="string">"event (%d)"</span>, evt);</span><br><span class="line">    <span class="keyword">switch</span> (evt) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> QCAMERA_SM_EVT_START_PREVIEW:</span><br><span class="line">    <span class="keyword">case</span> QCAMERA_SM_EVT_START_NODISPLAY_PREVIEW:</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="comment">// no ops here</span></span><br><span class="line">         LOGW(<span class="string">"Already in previewing, no ops here to start preview"</span>);</span><br><span class="line">         applyDelayedMsgs();</span><br><span class="line">         rc = NO_ERROR;</span><br><span class="line">         result.status = rc;</span><br><span class="line">         result.request_api = evt;</span><br><span class="line">         result.result_type = QCAMERA_API_RESULT_TYPE_DEF;</span><br><span class="line">         m_parent-&gt;signalAPIResult(&amp;result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">     ...</span><br></pre></td></tr></table></figure></p><p>调用m_parent的signalAPIResult返回结果,LOG也看到已经在preview状态,不需要操作.再看下procEvtPreviewStoppedState中的处理:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> QCAMERA_SM_EVT_START_PREVIEW:</span><br><span class="line">    &#123;</span><br><span class="line">        rc = m_parent-&gt;waitDeferredWork(m_parent-&gt;mParamInitJob);</span><br><span class="line">        <span class="keyword">if</span> (NO_ERROR != rc) &#123;</span><br><span class="line">            LOGE(<span class="string">"Param init deferred work failed"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (m_parent-&gt;mPreviewWindow == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            rc = m_parent-&gt;preparePreview();</span><br><span class="line">            <span class="keyword">if</span>(rc == NO_ERROR) &#123;</span><br><span class="line">                <span class="comment">// preview window is not set yet, move to previewReady state</span></span><br><span class="line">                m_state = QCAMERA_SM_STATE_PREVIEW_READY;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                LOGE(<span class="string">"preparePreview failed"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            rc = m_parent-&gt;preparePreview();</span><br><span class="line">            <span class="keyword">if</span> (rc == NO_ERROR) &#123;</span><br><span class="line">                applyDelayedMsgs();</span><br><span class="line">                rc = m_parent-&gt;startPreview();</span><br><span class="line">                <span class="keyword">if</span> (rc != NO_ERROR) &#123;</span><br><span class="line">                    m_parent-&gt;unpreparePreview();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// start preview success, move to previewing state</span></span><br><span class="line">                    m_state = QCAMERA_SM_STATE_PREVIEWING;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result.status = rc;</span><br><span class="line">        result.request_api = evt;</span><br><span class="line">        result.result_type = QCAMERA_API_RESULT_TYPE_DEF;</span><br><span class="line">        m_parent-&gt;signalAPIResult(&amp;result);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>判断m_parent-&gt;mPreviewWindow的状态进行了不同处理,m_parent是QCamera2HardwareInterface对象,通过这个状态机可能又调回startPreview,正常应该是调用preparePreview方法:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*===========================================================================</span></span><br><span class="line"><span class="comment"> * FUNCTION   : preparePreview</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * DESCRIPTION: add channels needed for preview</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * PARAMETERS : none</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * RETURN     : int32_t type of status</span></span><br><span class="line"><span class="comment"> *              NO_ERROR  -- success</span></span><br><span class="line"><span class="comment"> *              none-zero failure code</span></span><br><span class="line"><span class="comment"> *==========================================================================*/</span></span><br><span class="line"><span class="keyword">int32_t</span> QCamera2HardwareInterface::preparePreview()</span><br><span class="line">&#123;</span><br><span class="line">    ATRACE_CAMSCOPE_CALL(CAMSCOPE_HAL1_PREPAREPREVIEW);</span><br><span class="line">    <span class="keyword">int32_t</span> rc = NO_ERROR;</span><br><span class="line"></span><br><span class="line">    LOGI(<span class="string">"E"</span>);</span><br><span class="line">    rc = mParameters.setStreamConfigure(<span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (rc != NO_ERROR) &#123;</span><br><span class="line">        LOGE(<span class="string">"setStreamConfigure failed %d"</span>, rc);</span><br><span class="line">        <span class="keyword">return</span> rc;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    LOGI(<span class="string">"X rc = %d"</span>, rc);</span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mParameters是QCameraParameterIntf对象,最后使用的是QCameraParameters对象,这里可以做很多配置操作.<br>本层的话看到了setPreview方法的由camera_device_ops_t到QCamera2HardwareInterface的对应,再看到了状态机QCameraStateMachine,又能回到QCamera2HardwareInterface,再进入调用QCameraParameters获取参数等.</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>整个setPreview方法从framework到hal层的调用步骤就完全走通了,借此对android的架构和相机的架构都更深入了解了.下一篇会分析相机api1的参数传递过程.</p>]]></content>
    
    <summary type="html">
    
      相机流程深入解析:从framework到hal调用
    
    </summary>
    
    
      <category term="Android" scheme="http://anddymao.com/tags/Android/"/>
    
      <category term="Camera" scheme="http://anddymao.com/tags/Camera/"/>
    
  </entry>
  
  <entry>
    <title>YUV和RGB互相转换及OpenGL显示YUV数据</title>
    <link href="http://anddymao.com/2017/12/04/2017-12-4-YUV%E5%92%8CRGB%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2%E5%8F%8AOpenGL%E6%98%BE%E7%A4%BAYUV%E6%95%B0%E6%8D%AE/"/>
    <id>http://anddymao.com/2017/12/04/2017-12-4-YUV和RGB互相转换及OpenGL显示YUV数据/</id>
    <published>2017-12-04T04:00:00.000Z</published>
    <updated>2019-10-25T03:38:48.883Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>人眼对亮度信息更敏感,所以显示器都是直接使用的YUV数据,Android从相机拿到的原始数据就是YUV格式,所以底层图像处理的算法都是基于YUV.<br>Android上层Bitmap使用的是RGBA格式,OpenGL也是用的RGBA数据,这就需要灵活转换.</p><h2 id="转换公式"><a href="#转换公式" class="headerlink" title="转换公式"></a>转换公式</h2><p>RGB转YUV</p><pre><code>Y = 0.299 R + 0.587 G + 0.114 BU = - 0.1687 R - 0.3313 G + 0.5 B + 128V = 0.5 R - 0.4187 G - 0.0813 B + 128</code></pre><p>YUV转RGB</p><pre><code>R = Y + 1.402 (V-128)G = Y - 0.34414 (U-128) - 0.71414 (V-128)B = Y + 1.772 (U-128)</code></pre><h2 id="YUV格式"><a href="#YUV格式" class="headerlink" title="YUV格式"></a>YUV格式</h2><p>YUV有很多种格式,android常用的YUV420sp.YUV的主要信息是亮度Y,YUV420sp格式也即NV21,Y会占4位,UV一共占2位,交替出现,就是一个UV数据要对应4个Y数据,这样YUV数据的size就是RGB数据的1.5倍,<br>虽然size增大了,但每一位是一个字节,RGBA的话每一位是int型,占4个字节,所以整体大小是减小了,且丢失了一部分UV信息,但这些肉眼也基本感觉不出来.</p><p>RGB转YUV420sp算法:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">encodeyuv420sp</span><span class="params">(<span class="keyword">int</span> *rgbData, MUInt8 *yuv, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> frameSize = width * height;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> yIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> uvIndex = frameSize;</span><br><span class="line">    <span class="keyword">int</span> R, G, B, Y, U, V;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; height; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; width; i++) &#123;</span><br><span class="line"></span><br><span class="line">            B = (rgbData[index] &amp; <span class="number">0xff0000</span>) &gt;&gt; <span class="number">16</span> ;</span><br><span class="line">            G = (rgbData[index] &amp; <span class="number">0xff00</span>) &gt;&gt; <span class="number">8</span> ;</span><br><span class="line">            R = (rgbData[index] &amp; <span class="number">0xff</span>) ;</span><br><span class="line"></span><br><span class="line">            Y = (<span class="keyword">int</span>)((<span class="number">0.299</span> * R + <span class="number">0.587</span> * G + <span class="number">0.114</span> * B ) + <span class="number">0.5</span> ) ;</span><br><span class="line">            U = (<span class="keyword">int</span>)((<span class="number">-0.147</span> * R - <span class="number">0.289</span> * G + <span class="number">0.436</span> * B ) + <span class="number">0.5</span> + <span class="number">128</span>);</span><br><span class="line">            V = (<span class="keyword">int</span>)((<span class="number">0.615</span> * R - <span class="number">0.515</span> * G - <span class="number">0.100</span> * B ) + <span class="number">0.5</span>  + <span class="number">128</span>);</span><br><span class="line"></span><br><span class="line">            yuv[yIndex++] = (Y &lt; <span class="number">0</span>) ? <span class="number">0</span> : ((Y &gt; <span class="number">255</span>) ? <span class="number">255</span> : Y);</span><br><span class="line">            <span class="keyword">if</span> (j % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; index % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                yuv[uvIndex++] = (V&lt;<span class="number">0</span>) ? <span class="number">0</span> : ((V &gt; <span class="number">255</span>) ? <span class="number">255</span> : V);</span><br><span class="line">                yuv[uvIndex++] = (U&lt;<span class="number">0</span>) ? <span class="number">0</span> : ((U &gt; <span class="number">255</span>) ? <span class="number">255</span> : U);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            index ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="OpenGL中加载NV21数据"><a href="#OpenGL中加载NV21数据" class="headerlink" title="OpenGL中加载NV21数据"></a>OpenGL中加载NV21数据</h2><p>先加载YUV数据,分割成YBuffer和uvBuffer,再在OpenGL线程加载成纹理.这里要非常注意宽度必须是4的倍数,否则显示会形变.<br>因为OpenGL纹理加载必须是2的倍数,YUVFilter需要传入UV的纹理,UV的纹理的宽度是原图宽度的一半.这个问题找了非常久,后面发现是和大小有关,才一步步找到原因.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * OpenGL纹理加载必须是2的倍数,YUVFilter需要传入UV的纹理,所以宽度必须是4的倍数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> width  必须是4的倍数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> height</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">genYUVTextures</span><span class="params">(<span class="keyword">final</span> <span class="keyword">byte</span>[] data, <span class="keyword">final</span> <span class="keyword">int</span> width, <span class="keyword">final</span> <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> bufferSize = width * height;</span><br><span class="line">    <span class="keyword">if</span> (mYBuffer == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mYBuffer = ByteBuffer.allocateDirect(bufferSize);</span><br><span class="line">        mYBuffer.order(ByteOrder.nativeOrder());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mUVBuffer == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mUVBuffer = ByteBuffer.allocateDirect(bufferSize / <span class="number">2</span>);</span><br><span class="line">        mUVBuffer.order(ByteOrder.nativeOrder());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mYBuffer.put(data, <span class="number">0</span>, bufferSize).position(<span class="number">0</span>);</span><br><span class="line">    mUVBuffer.put(data, bufferSize, bufferSize &gt;&gt; <span class="number">1</span>).position(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    runOnDraw(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            OpenGlUtils.loadYuvToTvextures(mYBuffer, mUVBuffer, width, height, yuvTextureIds);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> yBuffer是原图片大小的纹理,uvBuffer的宽高都为原图片的1/2,正好1/4大小,然后按位置即可对应到图片的RGB数据了.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadYuvToTextures</span><span class="params">(<span class="keyword">final</span> Buffer channelY, <span class="keyword">final</span> Buffer channelUV, <span class="keyword">final</span> <span class="keyword">int</span> width, <span class="keyword">final</span> <span class="keyword">int</span> height, <span class="keyword">int</span>[] yuvTextures)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (channelY == <span class="keyword">null</span> || channelUV == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (yuvTextures == <span class="keyword">null</span> || yuvTextures.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (yuvTextures[<span class="number">0</span>] == NO_TEXTURE) &#123;</span><br><span class="line">           GLES20.glGenTextures(<span class="number">1</span>, yuvTextures, <span class="number">0</span>);</span><br><span class="line">           GLES20.glActiveTexture(GLES20.GL_TEXTURE0);</span><br><span class="line">           GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, yuvTextures[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">           GLES20.glTexImage2D(GLES20.GL_TEXTURE_2D, <span class="number">0</span>, GLES20.GL_LUMINANCE, width, height, <span class="number">0</span>,</span><br><span class="line">                   GLES20.GL_LUMINANCE, GLES20.GL_UNSIGNED_BYTE, channelY);</span><br><span class="line">           GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,</span><br><span class="line">                   GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR);</span><br><span class="line">           GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,</span><br><span class="line">                   GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR);</span><br><span class="line">           GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,</span><br><span class="line">                   GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_CLAMP_TO_EDGE);</span><br><span class="line">           GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,</span><br><span class="line">                   GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_CLAMP_TO_EDGE);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           GLES20.glActiveTexture(GLES20.GL_TEXTURE0);</span><br><span class="line">           GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, yuvTextures[<span class="number">0</span>]);</span><br><span class="line">           GLES20.glTexImage2D(GLES20.GL_TEXTURE_2D, <span class="number">0</span>, GLES20.GL_LUMINANCE, width, height, <span class="number">0</span>,</span><br><span class="line">                   GLES20.GL_LUMINANCE, GLES20.GL_UNSIGNED_BYTE, channelY);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (yuvTextures[<span class="number">1</span>] == NO_TEXTURE) &#123;</span><br><span class="line">           GLES20.glGenTextures(<span class="number">1</span>, yuvTextures, <span class="number">1</span>);</span><br><span class="line">           GLES20.glActiveTexture(GLES20.GL_TEXTURE1);</span><br><span class="line">           GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, yuvTextures[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">           GLES20.glTexImage2D(GLES20.GL_TEXTURE_2D, <span class="number">0</span>, GLES20.GL_LUMINANCE_ALPHA, width / <span class="number">2</span>,</span><br><span class="line">                   height / <span class="number">2</span>, <span class="number">0</span>,</span><br><span class="line">                   GLES20.GL_LUMINANCE_ALPHA, GLES20.GL_UNSIGNED_BYTE, channelUV);</span><br><span class="line">           GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,</span><br><span class="line">                   GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR);</span><br><span class="line">           GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,</span><br><span class="line">                   GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR);</span><br><span class="line">           GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,</span><br><span class="line">                   GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_CLAMP_TO_EDGE);</span><br><span class="line">           GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,</span><br><span class="line">                   GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_CLAMP_TO_EDGE);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           GLES20.glActiveTexture(GLES20.GL_TEXTURE1);</span><br><span class="line">           GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, yuvTextures[<span class="number">1</span>]);</span><br><span class="line">           GLES20.glTexImage2D(GLES20.GL_TEXTURE_2D, <span class="number">0</span>, GLES20.GL_LUMINANCE_ALPHA, width / <span class="number">2</span>,</span><br><span class="line">                   height / <span class="number">2</span>, <span class="number">0</span>,</span><br><span class="line">                   GLES20.GL_LUMINANCE_ALPHA, GLES20.GL_UNSIGNED_BYTE, channelUV);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>片段着色器代码,从对应位置加载到YUV数据,然后转换成RGB,即可显示出来了.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String fragmentShader =</span><br><span class="line">        <span class="string">"precision highp float;                             \n"</span> +</span><br><span class="line"></span><br><span class="line">                <span class="string">"varying vec2 v_texCoord;                           \n"</span> +</span><br><span class="line">                <span class="string">"uniform sampler2D y_texture;                       \n"</span> +</span><br><span class="line">                <span class="string">"uniform sampler2D uv_texture;                      \n"</span> +</span><br><span class="line"></span><br><span class="line">                <span class="string">"void main (void)&#123;                                  \n"</span> +</span><br><span class="line">                <span class="string">"   float r, g, b, y, u, v;                         \n"</span> +</span><br><span class="line"></span><br><span class="line">                <span class="comment">//We had put the Y values of each pixel to the R,G,B components by GL_LUMINANCE,</span></span><br><span class="line">                <span class="comment">//that's why we're pulling it from the R component, we could also use G or B</span></span><br><span class="line">                <span class="string">"   y = texture2D(y_texture, v_texCoord).r;         \n"</span> +</span><br><span class="line"></span><br><span class="line">                <span class="comment">//We had put the U and V values of each pixel to the A and R,G,B components of the</span></span><br><span class="line">                <span class="comment">//texture respectively using GL_LUMINANCE_ALPHA. Since U,V bytes are interspread</span></span><br><span class="line">                <span class="comment">//in the texture, this is probably the fastest way to use them in the shader</span></span><br><span class="line">                <span class="string">"   u = texture2D(uv_texture, v_texCoord).a - 0.5;  \n"</span> +</span><br><span class="line">                <span class="string">"   v = texture2D(uv_texture, v_texCoord).r - 0.5;  \n"</span> +</span><br><span class="line"></span><br><span class="line">                <span class="comment">//The numbers are just YUV to RGB conversion constants</span></span><br><span class="line">                <span class="string">"   r = y + 1.402 * v;\n"</span> +</span><br><span class="line">                <span class="string">"   g = y - 0.34414 * u - 0.71414 * v;\n"</span> +</span><br><span class="line">                <span class="string">"   b = y + 1.772 * u;\n"</span> +</span><br><span class="line"></span><br><span class="line">                <span class="comment">//We finally set the RGB color of our pixel</span></span><br><span class="line">                <span class="string">"   gl_FragColor = vec4(r, g, b, 1.0);              \n"</span> +</span><br><span class="line">                <span class="string">"&#125;                                                  \n"</span>;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在处理算法是YUV格式的,且需要频繁调用时,用OpenGL直接加载YUV数据效率是非常高的,用OpenGL作为显示,最后保存时再处理一遍就行了.</p>]]></content>
    
    <summary type="html">
    
      人眼对亮度信息更敏感,所以显示器都是直接使用的YUV数据,Android从相机拿到的原始数据就是YUV格式,所以底层图像处理的算法都是基于YUV. Android上层Bitmap使用的是RGBA格式,OpenGL也是用的RGBA数据,这就需要灵活转换
    
    </summary>
    
    
      <category term="Android" scheme="http://anddymao.com/tags/Android/"/>
    
      <category term="OpenGL" scheme="http://anddymao.com/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>Android跨进程传输数据</title>
    <link href="http://anddymao.com/2017/12/01/2017-12-1-Android%E8%B7%A8%E8%BF%9B%E7%A8%8B%E4%BC%A0%E8%BE%93%E6%95%B0%E6%8D%AE/"/>
    <id>http://anddymao.com/2017/12/01/2017-12-1-Android跨进程传输数据/</id>
    <published>2017-12-01T04:00:00.000Z</published>
    <updated>2019-10-25T03:38:48.882Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>跨进程传输数据需要序列化对象,java自带的Serializable效率较低,Android推荐使用Parcelable.<br>Parcelable的原理十分简单,通过自定义顺序写入和读取基本类型数据到Parcel中,来生成和读取对象.<br>使用插件自动生成Parcelable的代码也十分方便.但对于一些特殊数据,自动生成不了,就需要手动写了,很灵活.</p><h2 id="Android没有实现Parcelable的数据"><a href="#Android没有实现Parcelable的数据" class="headerlink" title="Android没有实现Parcelable的数据"></a>Android没有实现Parcelable的数据</h2><p>对于这类,要了解类的信息,手动实现,我碰到的是Matrix和Path</p><h3 id="Matrix"><a href="#Matrix" class="headerlink" title="Matrix"></a>Matrix</h3><p>Matrix对象主要是float数组,读取到这个数据就可以.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel dest, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span>[] f = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">this</span>.getValues(f);</span><br><span class="line">    dest.writeFloatArray(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">ParcelableMatrix</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span>[] f = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">9</span>];</span><br><span class="line">    in.readFloatArray(f);</span><br><span class="line">    setValues(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Path"><a href="#Path" class="headerlink" title="Path"></a>Path</h3><p>Path数据主要在于路径点,单独写一个方法从路径点还原Path<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Path <span class="title">getPathFromPointList</span><span class="params">(List&lt;PointF&gt; pointFList)</span> </span>&#123;</span><br><span class="line">        Path path = <span class="keyword">new</span> Path();</span><br><span class="line">        PointF prePoint = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (PointF pointF : pointFList) &#123;</span><br><span class="line">            <span class="keyword">float</span> x = pointF.x;</span><br><span class="line">            <span class="keyword">float</span> y = pointF.y;</span><br><span class="line">            <span class="keyword">if</span> (prePoint == <span class="keyword">null</span>) &#123;</span><br><span class="line">                path.moveTo(x, y);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">float</span> currentX = (prePoint.x + x) / <span class="number">2f</span>;</span><br><span class="line">                <span class="keyword">float</span> currentY = (prePoint.y + y) / <span class="number">2f</span>;</span><br><span class="line">                path.quadTo(prePoint.x, prePoint.y, currentX, currentY);</span><br><span class="line">            &#125;</span><br><span class="line">            prePoint = pointF;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h2 id="抽象类型数据"><a href="#抽象类型数据" class="headerlink" title="抽象类型数据"></a>抽象类型数据</h2><p>Parcelable传输时需要一个确定的类类型,从而使用对应的Creator,但有时定义的是抽象类型,传输时是实际类型,传输时每次类型不一样,需要特殊处理.<br>另一种是抽象类型List,每一项的实际类型都可能不一样,也需要特殊处理.写了一个工具类处理这种情况,再Parcelable中写入list的数量和类型的名称从而准确的还原.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParcelableGenericCreator</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Parcelable</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DATA_NULL = <span class="string">"NULL"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeList</span><span class="params">(Parcel dest, <span class="keyword">int</span> flags, List&lt;T&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (list == <span class="keyword">null</span>) &#123;</span><br><span class="line">            dest.writeInt(-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        dest.writeInt(list.size());</span><br><span class="line">        <span class="keyword">for</span> (T t : list) &#123;</span><br><span class="line">            dest.writeString(t.getClass().getName());</span><br><span class="line">            dest.writeParcelable(t, flags);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">readList</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = in.readInt();</span><br><span class="line">        <span class="keyword">if</span> (size == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;T&gt; list = <span class="keyword">new</span> ArrayList&lt;T&gt;(size);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                list.add((T) in.readParcelable(Class.forName(in.readString()).getClassLoader()));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(Parcel dest, <span class="keyword">int</span> flags, T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">            dest.writeString(DATA_NULL);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dest.writeString(t.getClass().getName());</span><br><span class="line">            dest.writeParcelable(t, flags);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">readObject</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">        T t = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String className = in.readString();</span><br><span class="line">            <span class="keyword">if</span> (!TextUtils.equals(className, DATA_NULL)) &#123;</span><br><span class="line">                t = in.readParcelable(Class.forName(className).getClassLoader());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="占用空间较大的对象"><a href="#占用空间较大的对象" class="headerlink" title="占用空间较大的对象"></a>占用空间较大的对象</h2><p>Android的Binder机制传输数据大小限制是1M,如果较大的数据,比如Bitmap就传输不了了.这时可以使用MemoryFile,共享内存的方式.<br>MemoryFile可以创建一块共享内存区域,通过文件描述符去获取.FileDescriptor是非Parcelable的,需要用ParcelFileDescriptor.<br>ParcelFileDescriptor下面的创建方法是Hide的,需要通过反射调用.MemoryFile的参数设置和获取方法也是隐藏的,也需要反射调用.</p><h2 id="native对象"><a href="#native对象" class="headerlink" title="native对象"></a>native对象</h2><p>在jni开发时内部保存的对象在对应进程的native堆里面,跨进程传输时需要先传到java层,再序列化传输.<br>下面的方法实现了把native的unsigned char*和int数据传输到java.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transData</span><span class="params">(jobject j_data,unsigned <span class="keyword">char</span> *data,<span class="keyword">int</span> int_value)</span></span>&#123;</span><br><span class="line">    jbyteArray array = env-&gt;NewByteArray(array_size);</span><br><span class="line">    env-&gt;SetByteArrayRegion(array, <span class="number">0</span>, array_size, (jbyte*)data);</span><br><span class="line"></span><br><span class="line">    jclass cls = env-&gt;GetObjectClass(j_data);</span><br><span class="line">    jfieldID intFieldId = env-&gt;GetFieldID(cls , <span class="string">"intData"</span> , <span class="string">"I"</span>);</span><br><span class="line">    jfieldID byteArrayFieldId = env-&gt;GetFieldID(cls , <span class="string">"byteArray"</span> , <span class="string">"[B"</span>);</span><br><span class="line">    env-&gt;SetIntField(j_data , intFieldId , int_value);</span><br><span class="line">    env-&gt;SetObjectField(j_data , byteArrayFieldId , array);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="跨应用传输"><a href="#跨应用传输" class="headerlink" title="跨应用传输"></a>跨应用传输</h2><p>跨进程不跨应用的话,在aidl中定义好传输对象就可以.一旦设计到跨应用,那就需要定义好标准接口和标准数据格式,<br>为扩展和变更作准备.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>跨进程传输需要注意的点非常多,需要根据实际场景灵活设计.</p>]]></content>
    
    <summary type="html">
    
      特殊格式的序列化方法
    
    </summary>
    
    
      <category term="Android" scheme="http://anddymao.com/tags/Android/"/>
    
  </entry>
  
</feed>
